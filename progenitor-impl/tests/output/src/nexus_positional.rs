#![allow(elided_named_lifetimes)]
#[allow(unused_imports)]
use progenitor_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
#[cfg(feature = "middleware")]
#[allow(unused_imports)]
pub use reqwest_middleware;
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a `TryFrom` or `FromStr` implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }

        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }

        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }

        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }

    ///Describes properties that should uniquely identify a Gimlet.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes properties that should uniquely identify a
    /// Gimlet.",
    ///  "type": "object",
    ///  "required": [
    ///    "part",
    ///    "revision",
    ///    "serial"
    ///  ],
    ///  "properties": {
    ///    "part": {
    ///      "type": "string"
    ///    },
    ///    "revision": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "serial": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Baseboard {
        pub part: ::std::string::String,
        pub revision: i64,
        pub serial: ::std::string::String,
    }

    impl ::std::convert::From<&Baseboard> for Baseboard {
        fn from(value: &Baseboard) -> Self {
            value.clone()
        }
    }

    ///A type storing a range over `T`.
    ///
    ///This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "start": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type")]
    pub enum BinRangedouble {
        ///A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: f64 },
        ///A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: f64, start: f64 },
        ///A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: f64 },
    }

    impl ::std::convert::From<&Self> for BinRangedouble {
        fn from(value: &BinRangedouble) -> Self {
            value.clone()
        }
    }

    ///A type storing a range over `T`.
    ///
    ///This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type")]
    pub enum BinRangeint64 {
        ///A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: i64 },
        ///A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: i64, start: i64 },
        ///A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: i64 },
    }

    impl ::std::convert::From<&Self> for BinRangeint64 {
        fn from(value: &BinRangeint64) -> Self {
            value.clone()
        }
    }

    ///Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangedouble"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Bindouble {
        ///The total count of samples in this bin.
        pub count: u64,
        ///The range of the support covered by this bin.
        pub range: BinRangedouble,
    }

    impl ::std::convert::From<&Bindouble> for Bindouble {
        fn from(value: &Bindouble) -> Self {
            value.clone()
        }
    }

    ///Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangeint64"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Binint64 {
        ///The total count of samples in this bin.
        pub count: u64,
        ///The range of the support covered by this bin.
        pub range: BinRangeint64,
    }

    impl ::std::convert::From<&Binint64> for Binint64 {
        fn from(value: &Binint64) -> Self {
            value.clone()
        }
    }

    ///`BlockSize`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "disk block size in bytes",
    ///  "type": "integer",
    ///  "enum": [
    ///    512,
    ///    2048,
    ///    4096
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct BlockSize(i64);
    impl ::std::ops::Deref for BlockSize {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl ::std::convert::From<BlockSize> for i64 {
        fn from(value: BlockSize) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&BlockSize> for BlockSize {
        fn from(value: &BlockSize) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<i64> for BlockSize {
        type Error = self::error::ConversionError;
        fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![512_i64, 2048_i64, 4096_i64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BlockSize {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<i64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///A count of bytes, typically used either for memory or storage capacity
    ///
    ///The maximum supported byte count is [`i64::MAX`].  This makes it
    /// somewhat inconvenient to define constructors: a u32 constructor can be
    /// infallible, but an i64 constructor can fail (if the value is negative)
    /// and a u64 constructor can fail (if the value is larger than i64::MAX).
    /// We provide all of these for consumers' convenience.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A count of bytes, typically used either for memory or
    /// storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].
    /// This makes it somewhat inconvenient to define constructors: a u32
    /// constructor can be infallible, but an i64 constructor can fail (if the
    /// value is negative) and a u64 constructor can fail (if the value is
    /// larger than i64::MAX).  We provide all of these for consumers'
    /// convenience.",
    ///  "type": "integer",
    ///  "format": "uint64",
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct ByteCount(pub u64);
    impl ::std::ops::Deref for ByteCount {
        type Target = u64;
        fn deref(&self) -> &u64 {
            &self.0
        }
    }

    impl ::std::convert::From<ByteCount> for u64 {
        fn from(value: ByteCount) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&ByteCount> for ByteCount {
        fn from(value: &ByteCount) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<u64> for ByteCount {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for ByteCount {
        type Err = <u64 as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl ::std::convert::TryFrom<&str> for ByteCount {
        type Error = <u64 as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ByteCount {
        type Error = <u64 as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ByteCount {
        type Error = <u64 as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for ByteCount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///Client view of a [`Certificate`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Certificate`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "service",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "service": {
    ///      "$ref": "#/components/schemas/ServiceUsingCertificate"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Certificate {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub service: ServiceUsingCertificate,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Certificate> for Certificate {
        fn from(value: &Certificate) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a
    /// [`Certificate`](crate::external_api::views::Certificate)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Certificate`](crate::external_api::views::Certificate)",
    ///  "type": "object",
    ///  "required": [
    ///    "cert",
    ///    "description",
    ///    "key",
    ///    "name",
    ///    "service"
    ///  ],
    ///  "properties": {
    ///    "cert": {
    ///      "description": "PEM file containing public certificate chain",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint8",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "key": {
    ///      "description": "PEM file containing private key",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint8",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "service": {
    ///      "description": "The service using this certificate",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ServiceUsingCertificate"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CertificateCreate {
        ///PEM file containing public certificate chain
        pub cert: ::std::vec::Vec<u8>,
        pub description: ::std::string::String,
        ///PEM file containing private key
        pub key: ::std::vec::Vec<u8>,
        pub name: Name,
        ///The service using this certificate
        pub service: ServiceUsingCertificate,
    }

    impl ::std::convert::From<&CertificateCreate> for CertificateCreate {
        fn from(value: &CertificateCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Certificate"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CertificateResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Certificate>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CertificateResultsPage> for CertificateResultsPage {
        fn from(value: &CertificateResultsPage) -> Self {
            value.clone()
        }
    }

    ///Identity-related metadata that's included in "asset" public API objects
    /// (which generally have no name or description)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in \"asset\"
    /// public API objects (which generally have no name or description)",
    ///  "type": "object",
    ///  "required": [
    ///    "component_type",
    ///    "id",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "component_type": {
    ///      "$ref": "#/components/schemas/UpdateableComponentType"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ComponentUpdate {
        pub component_type: UpdateableComponentType,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl ::std::convert::From<&ComponentUpdate> for ComponentUpdate {
        fn from(value: &ComponentUpdate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ComponentUpdate"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ComponentUpdateResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<ComponentUpdate>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ComponentUpdateResultsPage> for ComponentUpdateResultsPage {
        fn from(value: &ComponentUpdateResultsPage) -> Self {
            value.clone()
        }
    }

    ///A cumulative or counter data type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A cumulative or counter data type.",
    ///  "type": "object",
    ///  "required": [
    ///    "start_time",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "value": {
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Cumulativedouble {
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        pub value: f64,
    }

    impl ::std::convert::From<&Cumulativedouble> for Cumulativedouble {
        fn from(value: &Cumulativedouble) -> Self {
            value.clone()
        }
    }

    ///A cumulative or counter data type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A cumulative or counter data type.",
    ///  "type": "object",
    ///  "required": [
    ///    "start_time",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "value": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Cumulativeint64 {
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        pub value: i64,
    }

    impl ::std::convert::From<&Cumulativeint64> for Cumulativeint64 {
        fn from(value: &Cumulativeint64) -> Self {
            value.clone()
        }
    }

    ///A `Datum` is a single sampled data point from a metric.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `Datum` is a single sampled data point from a
    /// metric.",
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "boolean"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bool"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "i64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "f64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "string"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "integer",
    ///            "format": "uint8",
    ///            "minimum": 0.0
    ///          }
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bytes"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Cumulativeint64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "cumulative_i64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Cumulativedouble"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "cumulative_f64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramint64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_i64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramdouble"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_f64"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type", content = "datum")]
    pub enum Datum {
        #[serde(rename = "bool")]
        Bool(bool),
        #[serde(rename = "i64")]
        I64(i64),
        #[serde(rename = "f64")]
        F64(f64),
        #[serde(rename = "string")]
        String(::std::string::String),
        #[serde(rename = "bytes")]
        Bytes(::std::vec::Vec<u8>),
        #[serde(rename = "cumulative_i64")]
        CumulativeI64(Cumulativeint64),
        #[serde(rename = "cumulative_f64")]
        CumulativeF64(Cumulativedouble),
        #[serde(rename = "histogram_i64")]
        HistogramI64(Histogramint64),
        #[serde(rename = "histogram_f64")]
        HistogramF64(Histogramdouble),
    }

    impl ::std::convert::From<&Self> for Datum {
        fn from(value: &Datum) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<bool> for Datum {
        fn from(value: bool) -> Self {
            Self::Bool(value)
        }
    }

    impl ::std::convert::From<i64> for Datum {
        fn from(value: i64) -> Self {
            Self::I64(value)
        }
    }

    impl ::std::convert::From<f64> for Datum {
        fn from(value: f64) -> Self {
            Self::F64(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<u8>> for Datum {
        fn from(value: ::std::vec::Vec<u8>) -> Self {
            Self::Bytes(value)
        }
    }

    impl ::std::convert::From<Cumulativeint64> for Datum {
        fn from(value: Cumulativeint64) -> Self {
            Self::CumulativeI64(value)
        }
    }

    impl ::std::convert::From<Cumulativedouble> for Datum {
        fn from(value: Cumulativedouble) -> Self {
            Self::CumulativeF64(value)
        }
    }

    impl ::std::convert::From<Histogramint64> for Datum {
        fn from(value: Histogramint64) -> Self {
            Self::HistogramI64(value)
        }
    }

    impl ::std::convert::From<Histogramdouble> for Datum {
        fn from(value: Histogramdouble) -> Self {
            Self::HistogramF64(value)
        }
    }

    ///The type of an individual datum of a metric.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The type of an individual datum of a metric.",
    ///  "type": "string",
    ///  "enum": [
    ///    "bool",
    ///    "i64",
    ///    "f64",
    ///    "string",
    ///    "bytes",
    ///    "cumulative_i64",
    ///    "cumulative_f64",
    ///    "histogram_i64",
    ///    "histogram_f64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum DatumType {
        #[serde(rename = "bool")]
        Bool,
        #[serde(rename = "i64")]
        I64,
        #[serde(rename = "f64")]
        F64,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "bytes")]
        Bytes,
        #[serde(rename = "cumulative_i64")]
        CumulativeI64,
        #[serde(rename = "cumulative_f64")]
        CumulativeF64,
        #[serde(rename = "histogram_i64")]
        HistogramI64,
        #[serde(rename = "histogram_f64")]
        HistogramF64,
    }

    impl ::std::convert::From<&Self> for DatumType {
        fn from(value: &DatumType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DatumType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bool => write!(f, "bool"),
                Self::I64 => write!(f, "i64"),
                Self::F64 => write!(f, "f64"),
                Self::String => write!(f, "string"),
                Self::Bytes => write!(f, "bytes"),
                Self::CumulativeI64 => write!(f, "cumulative_i64"),
                Self::CumulativeF64 => write!(f, "cumulative_f64"),
                Self::HistogramI64 => write!(f, "histogram_i64"),
                Self::HistogramF64 => write!(f, "histogram_f64"),
            }
        }
    }

    impl ::std::str::FromStr for DatumType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bool" => Ok(Self::Bool),
                "i64" => Ok(Self::I64),
                "f64" => Ok(Self::F64),
                "string" => Ok(Self::String),
                "bytes" => Ok(Self::Bytes),
                "cumulative_i64" => Ok(Self::CumulativeI64),
                "cumulative_f64" => Ok(Self::CumulativeF64),
                "histogram_i64" => Ok(Self::HistogramI64),
                "histogram_f64" => Ok(Self::HistogramF64),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DatumType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DatumType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DatumType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`DerEncodedKeyPair`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "private_key",
    ///    "public_cert"
    ///  ],
    ///  "properties": {
    ///    "private_key": {
    ///      "description": "request signing private key (base64 encoded der
    /// file)",
    ///      "type": "string"
    ///    },
    ///    "public_cert": {
    ///      "description": "request signing public certificate (base64 encoded
    /// der file)",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DerEncodedKeyPair {
        ///request signing private key (base64 encoded der file)
        pub private_key: ::std::string::String,
        ///request signing public certificate (base64 encoded der file)
        pub public_cert: ::std::string::String,
    }

    impl ::std::convert::From<&DerEncodedKeyPair> for DerEncodedKeyPair {
        fn from(value: &DerEncodedKeyPair) -> Self {
            value.clone()
        }
    }

    ///`DeviceAccessTokenRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "client_id",
    ///    "device_code",
    ///    "grant_type"
    ///  ],
    ///  "properties": {
    ///    "client_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "device_code": {
    ///      "type": "string"
    ///    },
    ///    "grant_type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeviceAccessTokenRequest {
        pub client_id: ::uuid::Uuid,
        pub device_code: ::std::string::String,
        pub grant_type: ::std::string::String,
    }

    impl ::std::convert::From<&DeviceAccessTokenRequest> for DeviceAccessTokenRequest {
        fn from(value: &DeviceAccessTokenRequest) -> Self {
            value.clone()
        }
    }

    ///`DeviceAuthRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "client_id"
    ///  ],
    ///  "properties": {
    ///    "client_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeviceAuthRequest {
        pub client_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&DeviceAuthRequest> for DeviceAuthRequest {
        fn from(value: &DeviceAuthRequest) -> Self {
            value.clone()
        }
    }

    ///`DeviceAuthVerify`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "user_code"
    ///  ],
    ///  "properties": {
    ///    "user_code": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeviceAuthVerify {
        pub user_code: ::std::string::String,
    }

    impl ::std::convert::From<&DeviceAuthVerify> for DeviceAuthVerify {
        fn from(value: &DeviceAuthVerify) -> Self {
            value.clone()
        }
    }

    ///`Digest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "sha256"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type", content = "value")]
    pub enum Digest {
        #[serde(rename = "sha256")]
        Sha256(::std::string::String),
    }

    impl ::std::convert::From<&Self> for Digest {
        fn from(value: &Digest) -> Self {
            value.clone()
        }
    }

    ///Client view of a [`Disk`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Disk`]",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "device_path",
    ///    "id",
    ///    "name",
    ///    "project_id",
    ///    "size",
    ///    "state",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "device_path": {
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "image_id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "size": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "snapshot_id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/DiskState"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Disk {
        pub block_size: ByteCount,
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        pub device_path: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_id: ::std::option::Option<::uuid::Uuid>,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub project_id: ::uuid::Uuid,
        pub size: ByteCount,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub snapshot_id: ::std::option::Option<::uuid::Uuid>,
        pub state: DiskState,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Disk> for Disk {
        fn from(value: &Disk) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a
    /// [`Disk`](omicron_common::api::external::Disk)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Disk`](omicron_common::api::external::Disk)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "disk_source",
    ///    "name",
    ///    "size"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "disk_source": {
    ///      "description": "initial source for this disk",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/DiskSource"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "size": {
    ///      "description": "total size of the Disk in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DiskCreate {
        pub description: ::std::string::String,
        ///initial source for this disk
        pub disk_source: DiskSource,
        pub name: Name,
        ///total size of the Disk in bytes
        pub size: ByteCount,
    }

    impl ::std::convert::From<&DiskCreate> for DiskCreate {
        fn from(value: &DiskCreate) -> Self {
            value.clone()
        }
    }

    ///TODO-v1: Delete this Parameters for the
    /// [`Disk`](omicron_common::api::external::Disk) to be attached or detached
    /// to an instance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "TODO-v1: Delete this Parameters for the
    /// [`Disk`](omicron_common::api::external::Disk) to be attached or detached
    /// to an instance",
    ///  "type": "object",
    ///  "required": [
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DiskIdentifier {
        pub name: Name,
    }

    impl ::std::convert::From<&DiskIdentifier> for DiskIdentifier {
        fn from(value: &DiskIdentifier) -> Self {
            value.clone()
        }
    }

    ///`DiskMetricName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "activated",
    ///    "flush",
    ///    "read",
    ///    "read_bytes",
    ///    "write",
    ///    "write_bytes"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum DiskMetricName {
        #[serde(rename = "activated")]
        Activated,
        #[serde(rename = "flush")]
        Flush,
        #[serde(rename = "read")]
        Read,
        #[serde(rename = "read_bytes")]
        ReadBytes,
        #[serde(rename = "write")]
        Write,
        #[serde(rename = "write_bytes")]
        WriteBytes,
    }

    impl ::std::convert::From<&Self> for DiskMetricName {
        fn from(value: &DiskMetricName) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DiskMetricName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Activated => write!(f, "activated"),
                Self::Flush => write!(f, "flush"),
                Self::Read => write!(f, "read"),
                Self::ReadBytes => write!(f, "read_bytes"),
                Self::Write => write!(f, "write"),
                Self::WriteBytes => write!(f, "write_bytes"),
            }
        }
    }

    impl ::std::str::FromStr for DiskMetricName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "activated" => Ok(Self::Activated),
                "flush" => Ok(Self::Flush),
                "read" => Ok(Self::Read),
                "read_bytes" => Ok(Self::ReadBytes),
                "write" => Ok(Self::Write),
                "write_bytes" => Ok(Self::WriteBytes),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DiskMetricName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DiskMetricName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DiskMetricName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`DiskPath`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "disk"
    ///  ],
    ///  "properties": {
    ///    "disk": {
    ///      "$ref": "#/components/schemas/NameOrId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DiskPath {
        pub disk: NameOrId,
    }

    impl ::std::convert::From<&DiskPath> for DiskPath {
        fn from(value: &DiskPath) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Disk"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DiskResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Disk>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&DiskResultsPage> for DiskResultsPage {
        fn from(value: &DiskResultsPage) -> Self {
            value.clone()
        }
    }

    ///Different sources for a disk
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Different sources for a disk",
    ///  "oneOf": [
    ///    {
    ///      "description": "Create a blank disk",
    ///      "type": "object",
    ///      "required": [
    ///        "block_size",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "block_size": {
    ///          "description": "size of blocks for this Disk. valid values are:
    /// 512, 2048, or 4096",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/BlockSize"
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "blank"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Create a disk from a disk snapshot",
    ///      "type": "object",
    ///      "required": [
    ///        "snapshot_id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "snapshot_id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "snapshot"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Create a disk from a project image",
    ///      "type": "object",
    ///      "required": [
    ///        "image_id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "image_id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "image"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Create a disk from a global image",
    ///      "type": "object",
    ///      "required": [
    ///        "image_id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "image_id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "global_image"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type")]
    pub enum DiskSource {
        ///Create a blank disk
        #[serde(rename = "blank")]
        Blank {
            ///size of blocks for this Disk. valid values are: 512, 2048, or
            /// 4096
            block_size: BlockSize,
        },
        ///Create a disk from a disk snapshot
        #[serde(rename = "snapshot")]
        Snapshot { snapshot_id: ::uuid::Uuid },
        ///Create a disk from a project image
        #[serde(rename = "image")]
        Image { image_id: ::uuid::Uuid },
        ///Create a disk from a global image
        #[serde(rename = "global_image")]
        GlobalImage { image_id: ::uuid::Uuid },
    }

    impl ::std::convert::From<&Self> for DiskSource {
        fn from(value: &DiskSource) -> Self {
            value.clone()
        }
    }

    ///State of a Disk (primarily: attached or not)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "State of a Disk (primarily: attached or not)",
    ///  "oneOf": [
    ///    {
    ///      "description": "Disk is being initialized",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "creating"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is ready but detached from any Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "detached"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is being attached to the given Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "instance",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "instance": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "attaching"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is attached to the given Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "instance",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "instance": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "attached"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is being detached from the given Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "instance",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "instance": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "detaching"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk has been destroyed",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "destroyed"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is unavailable",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "faulted"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "state", content = "instance")]
    pub enum DiskState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "detached")]
        Detached,
        ///Disk is being attached to the given Instance
        #[serde(rename = "attaching")]
        Attaching(::uuid::Uuid),
        ///Disk is attached to the given Instance
        #[serde(rename = "attached")]
        Attached(::uuid::Uuid),
        ///Disk is being detached from the given Instance
        #[serde(rename = "detaching")]
        Detaching(::uuid::Uuid),
        #[serde(rename = "destroyed")]
        Destroyed,
        #[serde(rename = "faulted")]
        Faulted,
    }

    impl ::std::convert::From<&Self> for DiskState {
        fn from(value: &DiskState) -> Self {
            value.clone()
        }
    }

    ///OS image distribution
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "OS image distribution",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "The name of the distribution (e.g. \"alpine\" or
    /// \"ubuntu\")",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "version": {
    ///      "description": "The version of the distribution (e.g. \"3.10\" or
    /// \"18.04\")",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Distribution {
        ///The name of the distribution (e.g. "alpine" or "ubuntu")
        pub name: Name,
        ///The version of the distribution (e.g. "3.10" or "18.04")
        pub version: ::std::string::String,
    }

    impl ::std::convert::From<&Distribution> for Distribution {
        fn from(value: &Distribution) -> Self {
            value.clone()
        }
    }

    ///Error information from a response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Error information from a response.",
    ///  "type": "object",
    ///  "required": [
    ///    "message",
    ///    "request_id"
    ///  ],
    ///  "properties": {
    ///    "error_code": {
    ///      "type": "string"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    },
    ///    "request_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Error {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_code: ::std::option::Option<::std::string::String>,
        pub message: ::std::string::String,
        pub request_id: ::std::string::String,
    }

    impl ::std::convert::From<&Error> for Error {
        fn from(value: &Error) -> Self {
            value.clone()
        }
    }

    ///`ExternalIp`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "ip",
    ///    "kind"
    ///  ],
    ///  "properties": {
    ///    "ip": {
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "kind": {
    ///      "$ref": "#/components/schemas/IpKind"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExternalIp {
        pub ip: ::std::net::IpAddr,
        pub kind: IpKind,
    }

    impl ::std::convert::From<&ExternalIp> for ExternalIp {
        fn from(value: &ExternalIp) -> Self {
            value.clone()
        }
    }

    ///Parameters for creating an external IP address for instances.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters for creating an external IP address for
    /// instances.",
    ///  "oneOf": [
    ///    {
    ///      "description": "An IP address providing both inbound and outbound
    /// access. The address is automatically-assigned from the provided IP Pool,
    /// or all available pools if not specified.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "pool_name": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/Name"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ephemeral"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type")]
    pub enum ExternalIpCreate {
        ///An IP address providing both inbound and outbound access. The
        /// address is automatically-assigned from the provided IP Pool, or all
        /// available pools if not specified.
        #[serde(rename = "ephemeral")]
        Ephemeral {
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            pool_name: ::std::option::Option<Name>,
        },
    }

    impl ::std::convert::From<&Self> for ExternalIpCreate {
        fn from(value: &ExternalIpCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExternalIp"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExternalIpResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<ExternalIp>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ExternalIpResultsPage> for ExternalIpResultsPage {
        fn from(value: &ExternalIpResultsPage) -> Self {
            value.clone()
        }
    }

    ///The name and type information for a field of a timeseries schema.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The name and type information for a field of a
    /// timeseries schema.",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "source",
    ///    "ty"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "source": {
    ///      "$ref": "#/components/schemas/FieldSource"
    ///    },
    ///    "ty": {
    ///      "$ref": "#/components/schemas/FieldType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FieldSchema {
        pub name: ::std::string::String,
        pub source: FieldSource,
        pub ty: FieldType,
    }

    impl ::std::convert::From<&FieldSchema> for FieldSchema {
        fn from(value: &FieldSchema) -> Self {
            value.clone()
        }
    }

    ///The source from which a field is derived, the target or metric.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The source from which a field is derived, the target or
    /// metric.",
    ///  "type": "string",
    ///  "enum": [
    ///    "target",
    ///    "metric"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum FieldSource {
        #[serde(rename = "target")]
        Target,
        #[serde(rename = "metric")]
        Metric,
    }

    impl ::std::convert::From<&Self> for FieldSource {
        fn from(value: &FieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Target => write!(f, "target"),
                Self::Metric => write!(f, "metric"),
            }
        }
    }

    impl ::std::str::FromStr for FieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "target" => Ok(Self::Target),
                "metric" => Ok(Self::Metric),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The `FieldType` identifies the data type of a target or metric field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The `FieldType` identifies the data type of a target or
    /// metric field.",
    ///  "type": "string",
    ///  "enum": [
    ///    "string",
    ///    "i64",
    ///    "ip_addr",
    ///    "uuid",
    ///    "bool"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum FieldType {
        #[serde(rename = "string")]
        String,
        #[serde(rename = "i64")]
        I64,
        #[serde(rename = "ip_addr")]
        IpAddr,
        #[serde(rename = "uuid")]
        Uuid,
        #[serde(rename = "bool")]
        Bool,
    }

    impl ::std::convert::From<&Self> for FieldType {
        fn from(value: &FieldType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FieldType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::String => write!(f, "string"),
                Self::I64 => write!(f, "i64"),
                Self::IpAddr => write!(f, "ip_addr"),
                Self::Uuid => write!(f, "uuid"),
                Self::Bool => write!(f, "bool"),
            }
        }
    }

    impl ::std::str::FromStr for FieldType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "string" => Ok(Self::String),
                "i64" => Ok(Self::I64),
                "ip_addr" => Ok(Self::IpAddr),
                "uuid" => Ok(Self::Uuid),
                "bool" => Ok(Self::Bool),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FieldType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FieldType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FieldType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`FleetRole`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum FleetRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl ::std::convert::From<&Self> for FleetRole {
        fn from(value: &FleetRole) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FleetRole {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Admin => write!(f, "admin"),
                Self::Collaborator => write!(f, "collaborator"),
                Self::Viewer => write!(f, "viewer"),
            }
        }
    }

    impl ::std::str::FromStr for FleetRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FleetRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FleetRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FleetRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Policy`], which describes how this
    /// resource may be accessed\n\nNote that the Policy only describes access
    /// granted explicitly for this resource.  The policies of parent resources
    /// can also cause a user to have access to this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FleetRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FleetRolePolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: ::std::vec::Vec<FleetRoleRoleAssignment>,
    }

    impl ::std::convert::From<&FleetRolePolicy> for FleetRolePolicy {
        fn from(value: &FleetRolePolicy) -> Self {
            value.clone()
        }
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, [`RoleAssignment`]s are
    /// put into a [`Policy`] and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/FleetRole"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FleetRoleRoleAssignment {
        pub identity_id: ::uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: FleetRole,
    }

    impl ::std::convert::From<&FleetRoleRoleAssignment> for FleetRoleRoleAssignment {
        fn from(value: &FleetRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    ///Client view of global Images
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of global Images",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "distribution",
    ///    "id",
    ///    "name",
    ///    "size",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "description": "size of blocks in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "digest": {
    ///      "description": "Hash of the image contents, if applicable",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Digest"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "distribution": {
    ///      "description": "Image distribution",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "size": {
    ///      "description": "total size in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "url": {
    ///      "description": "URL source of this image, if any",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "version": {
    ///      "description": "Image version",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GlobalImage {
        ///size of blocks in bytes
        pub block_size: ByteCount,
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///Hash of the image contents, if applicable
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub digest: ::std::option::Option<Digest>,
        ///Image distribution
        pub distribution: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///total size in bytes
        pub size: ByteCount,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        ///URL source of this image, if any
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub url: ::std::option::Option<::std::string::String>,
        ///Image version
        pub version: ::std::string::String,
    }

    impl ::std::convert::From<&GlobalImage> for GlobalImage {
        fn from(value: &GlobalImage) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for an
    /// [`GlobalImage`](crate::external_api::views::GlobalImage)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an
    /// [`GlobalImage`](crate::external_api::views::GlobalImage)",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "distribution",
    ///    "name",
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "description": "block size in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BlockSize"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "distribution": {
    ///      "description": "OS image distribution",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Distribution"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "source": {
    ///      "description": "The source of the image's contents.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ImageSource"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GlobalImageCreate {
        ///block size in bytes
        pub block_size: BlockSize,
        pub description: ::std::string::String,
        ///OS image distribution
        pub distribution: Distribution,
        pub name: Name,
        ///The source of the image's contents.
        pub source: ImageSource,
    }

    impl ::std::convert::From<&GlobalImageCreate> for GlobalImageCreate {
        fn from(value: &GlobalImageCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GlobalImage"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GlobalImageResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<GlobalImage>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GlobalImageResultsPage> for GlobalImageResultsPage {
        fn from(value: &GlobalImageResultsPage) -> Self {
            value.clone()
        }
    }

    ///Client view of a [`Group`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Group`]",
    ///  "type": "object",
    ///  "required": [
    ///    "display_name",
    ///    "id",
    ///    "silo_id"
    ///  ],
    ///  "properties": {
    ///    "display_name": {
    ///      "description": "Human-readable name that can identify the group",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "silo_id": {
    ///      "description": "Uuid of the silo to which this group belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Group {
        ///Human-readable name that can identify the group
        pub display_name: ::std::string::String,
        pub id: ::uuid::Uuid,
        ///Uuid of the silo to which this group belongs
        pub silo_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&Group> for Group {
        fn from(value: &Group) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Group"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GroupResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Group>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GroupResultsPage> for GroupResultsPage {
        fn from(value: &GroupResultsPage) -> Self {
            value.clone()
        }
    }

    ///A simple type for managing a histogram metric.
    ///
    ///A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    ///Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    ///Example ------- ```rust use oximeter::histogram::{BinRange, Histogram};
    ///
    ///let edges = [0i64, 10, 20]; let mut hist =
    /// Histogram::new(&edges).unwrap(); assert_eq!(hist.n_bins(), 4); // One
    /// additional bin for the range (20..) assert_eq!(hist.n_samples(), 0);
    /// hist.sample(4); hist.sample(100); assert_eq!(hist.n_samples(), 2);
    ///
    ///let data = hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range,
    /// BinRange::range(i64::MIN, 0)); // An additional bin for `..0`
    /// assert_eq!(data[0].count, 0); // Nothing is in this bin
    ///
    ///assert_eq!(data[1].range, BinRange::range(0, 10)); // The range `0..10`
    /// assert_eq!(data[1].count, 1); // 4 is sampled into this bin ```
    ///
    ///Notes -----
    ///
    ///Histograms may be constructed either from their left bin edges, or from
    /// a sequence of ranges. In either case, the left-most bin may be converted
    /// upon construction. In particular, if the left-most value is not equal to
    /// the minimum of the support, a new bin will be added from the minimum to
    /// that provided value. If the left-most value _is_ the support's minimum,
    /// because the provided bin was unbounded below, such as `(..0)`, then that
    /// bin will be converted into one bounded below, `(MIN..0)` in this case.
    ///
    ///The short of this is that, most of the time, it shouldn't matter. If one
    /// specifies the extremes of the support as their bins, be aware that the
    /// left-most may be converted from a `BinRange::RangeTo` into a
    /// `BinRange::Range`. In other words, the first bin of a histogram is
    /// _always_ a `Bin::Range` or a `Bin::RangeFrom` after construction. In
    /// fact, every bin is one of those variants, the `BinRange::RangeTo` is
    /// only provided as a convenience during construction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A simple type for managing a histogram metric.\n\nA
    /// histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any \"gaps\" in the bins, and an additional
    /// bin may be added to the left, right, or both so that the bins extend to
    /// the entire range of the support.\n\nNote that any gaps, unsorted bins,
    /// or non-finite values will result in an error.\n\nExample ------- ```rust
    /// use oximeter::histogram::{BinRange, Histogram};\n\nlet edges = [0i64,
    /// 10, 20]; let mut hist = Histogram::new(&edges).unwrap();
    /// assert_eq!(hist.n_bins(), 4); // One additional bin for the range (20..)
    /// assert_eq!(hist.n_samples(), 0); hist.sample(4); hist.sample(100);
    /// assert_eq!(hist.n_samples(), 2);\n\nlet data =
    /// hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range,
    /// BinRange::range(i64::MIN, 0)); // An additional bin for `..0`
    /// assert_eq!(data[0].count, 0); // Nothing is in this
    /// bin\n\nassert_eq!(data[1].range, BinRange::range(0, 10)); // The range
    /// `0..10` assert_eq!(data[1].count, 1); // 4 is sampled into this bin
    /// ```\n\nNotes -----\n\nHistograms may be constructed either from their
    /// left bin edges, or from a sequence of ranges. In either case, the
    /// left-most bin may be converted upon construction. In particular, if the
    /// left-most value is not equal to the minimum of the support, a new bin
    /// will be added from the minimum to that provided value. If the left-most
    /// value _is_ the support's minimum, because the provided bin was unbounded
    /// below, such as `(..0)`, then that bin will be converted into one bounded
    /// below, `(MIN..0)` in this case.\n\nThe short of this is that, most of
    /// the time, it shouldn't matter. If one specifies the extremes of the
    /// support as their bins, be aware that the left-most may be converted from
    /// a `BinRange::RangeTo` into a `BinRange::Range`. In other words, the
    /// first bin of a histogram is _always_ a `Bin::Range` or a
    /// `Bin::RangeFrom` after construction. In fact, every bin is one of those
    /// variants, the `BinRange::RangeTo` is only provided as a convenience
    /// during construction.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "n_samples",
    ///    "start_time"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Bindouble"
    ///      }
    ///    },
    ///    "n_samples": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Histogramdouble {
        pub bins: ::std::vec::Vec<Bindouble>,
        pub n_samples: u64,
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Histogramdouble> for Histogramdouble {
        fn from(value: &Histogramdouble) -> Self {
            value.clone()
        }
    }

    ///A simple type for managing a histogram metric.
    ///
    ///A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    ///Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    ///Example ------- ```rust use oximeter::histogram::{BinRange, Histogram};
    ///
    ///let edges = [0i64, 10, 20]; let mut hist =
    /// Histogram::new(&edges).unwrap(); assert_eq!(hist.n_bins(), 4); // One
    /// additional bin for the range (20..) assert_eq!(hist.n_samples(), 0);
    /// hist.sample(4); hist.sample(100); assert_eq!(hist.n_samples(), 2);
    ///
    ///let data = hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range,
    /// BinRange::range(i64::MIN, 0)); // An additional bin for `..0`
    /// assert_eq!(data[0].count, 0); // Nothing is in this bin
    ///
    ///assert_eq!(data[1].range, BinRange::range(0, 10)); // The range `0..10`
    /// assert_eq!(data[1].count, 1); // 4 is sampled into this bin ```
    ///
    ///Notes -----
    ///
    ///Histograms may be constructed either from their left bin edges, or from
    /// a sequence of ranges. In either case, the left-most bin may be converted
    /// upon construction. In particular, if the left-most value is not equal to
    /// the minimum of the support, a new bin will be added from the minimum to
    /// that provided value. If the left-most value _is_ the support's minimum,
    /// because the provided bin was unbounded below, such as `(..0)`, then that
    /// bin will be converted into one bounded below, `(MIN..0)` in this case.
    ///
    ///The short of this is that, most of the time, it shouldn't matter. If one
    /// specifies the extremes of the support as their bins, be aware that the
    /// left-most may be converted from a `BinRange::RangeTo` into a
    /// `BinRange::Range`. In other words, the first bin of a histogram is
    /// _always_ a `Bin::Range` or a `Bin::RangeFrom` after construction. In
    /// fact, every bin is one of those variants, the `BinRange::RangeTo` is
    /// only provided as a convenience during construction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A simple type for managing a histogram metric.\n\nA
    /// histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any \"gaps\" in the bins, and an additional
    /// bin may be added to the left, right, or both so that the bins extend to
    /// the entire range of the support.\n\nNote that any gaps, unsorted bins,
    /// or non-finite values will result in an error.\n\nExample ------- ```rust
    /// use oximeter::histogram::{BinRange, Histogram};\n\nlet edges = [0i64,
    /// 10, 20]; let mut hist = Histogram::new(&edges).unwrap();
    /// assert_eq!(hist.n_bins(), 4); // One additional bin for the range (20..)
    /// assert_eq!(hist.n_samples(), 0); hist.sample(4); hist.sample(100);
    /// assert_eq!(hist.n_samples(), 2);\n\nlet data =
    /// hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range,
    /// BinRange::range(i64::MIN, 0)); // An additional bin for `..0`
    /// assert_eq!(data[0].count, 0); // Nothing is in this
    /// bin\n\nassert_eq!(data[1].range, BinRange::range(0, 10)); // The range
    /// `0..10` assert_eq!(data[1].count, 1); // 4 is sampled into this bin
    /// ```\n\nNotes -----\n\nHistograms may be constructed either from their
    /// left bin edges, or from a sequence of ranges. In either case, the
    /// left-most bin may be converted upon construction. In particular, if the
    /// left-most value is not equal to the minimum of the support, a new bin
    /// will be added from the minimum to that provided value. If the left-most
    /// value _is_ the support's minimum, because the provided bin was unbounded
    /// below, such as `(..0)`, then that bin will be converted into one bounded
    /// below, `(MIN..0)` in this case.\n\nThe short of this is that, most of
    /// the time, it shouldn't matter. If one specifies the extremes of the
    /// support as their bins, be aware that the left-most may be converted from
    /// a `BinRange::RangeTo` into a `BinRange::Range`. In other words, the
    /// first bin of a histogram is _always_ a `Bin::Range` or a
    /// `Bin::RangeFrom` after construction. In fact, every bin is one of those
    /// variants, the `BinRange::RangeTo` is only provided as a convenience
    /// during construction.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "n_samples",
    ///    "start_time"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binint64"
    ///      }
    ///    },
    ///    "n_samples": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Histogramint64 {
        pub bins: ::std::vec::Vec<Binint64>,
        pub n_samples: u64,
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Histogramint64> for Histogramint64 {
        fn from(value: &Histogramint64) -> Self {
            value.clone()
        }
    }

    ///Supported set of sort modes for scanning by id only.
    ///
    ///Currently, we only support scanning in ascending order.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Supported set of sort modes for scanning by id
    /// only.\n\nCurrently, we only support scanning in ascending order.",
    ///  "oneOf": [
    ///    {
    ///      "description": "sort in increasing order of \"id\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "id_ascending"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum IdSortMode {
        ///sort in increasing order of "id"
        #[serde(rename = "id_ascending")]
        IdAscending,
    }

    impl ::std::convert::From<&Self> for IdSortMode {
        fn from(value: &IdSortMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IdSortMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::IdAscending => write!(f, "id_ascending"),
            }
        }
    }

    impl ::std::str::FromStr for IdSortMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "id_ascending" => Ok(Self::IdAscending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of an [`IdentityProvider`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of an [`IdentityProvider`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "provider_type",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "provider_type": {
    ///      "description": "Identity provider type",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IdentityProviderType"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IdentityProvider {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///Identity provider type
        pub provider_type: IdentityProviderType,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&IdentityProvider> for IdentityProvider {
        fn from(value: &IdentityProvider) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IdentityProvider"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IdentityProviderResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<IdentityProvider>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&IdentityProviderResultsPage> for IdentityProviderResultsPage {
        fn from(value: &IdentityProviderResultsPage) -> Self {
            value.clone()
        }
    }

    ///`IdentityProviderType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "description": "SAML identity provider",
    ///      "type": "string",
    ///      "enum": [
    ///        "saml"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum IdentityProviderType {
        ///SAML identity provider
        #[serde(rename = "saml")]
        Saml,
    }

    impl ::std::convert::From<&Self> for IdentityProviderType {
        fn from(value: &IdentityProviderType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IdentityProviderType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Saml => write!(f, "saml"),
            }
        }
    }

    impl ::std::str::FromStr for IdentityProviderType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "saml" => Ok(Self::Saml),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IdentityProviderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IdentityProviderType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IdentityProviderType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Describes what kind of identity is described by an id
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes what kind of identity is described by an id",
    ///  "type": "string",
    ///  "enum": [
    ///    "silo_user",
    ///    "silo_group"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum IdentityType {
        #[serde(rename = "silo_user")]
        SiloUser,
        #[serde(rename = "silo_group")]
        SiloGroup,
    }

    impl ::std::convert::From<&Self> for IdentityType {
        fn from(value: &IdentityType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IdentityType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SiloUser => write!(f, "silo_user"),
                Self::SiloGroup => write!(f, "silo_group"),
            }
        }
    }

    impl ::std::str::FromStr for IdentityType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "silo_user" => Ok(Self::SiloUser),
                "silo_group" => Ok(Self::SiloGroup),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IdentityType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IdentityType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IdentityType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`IdpMetadataSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "url"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "url"
    ///          ]
    ///        },
    ///        "url": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "data",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "data": {
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "base64_encoded_xml"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type")]
    pub enum IdpMetadataSource {
        #[serde(rename = "url")]
        Url { url: ::std::string::String },
        #[serde(rename = "base64_encoded_xml")]
        Base64EncodedXml { data: ::std::string::String },
    }

    impl ::std::convert::From<&Self> for IdpMetadataSource {
        fn from(value: &IdpMetadataSource) -> Self {
            value.clone()
        }
    }

    ///Client view of project Images
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of project Images",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "project_id",
    ///    "size",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "description": "size of blocks in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "digest": {
    ///      "description": "Hash of the image contents, if applicable",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Digest"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "description": "The project the disk belongs to",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "size": {
    ///      "description": "total size in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "url": {
    ///      "description": "URL source of this image, if any",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "version": {
    ///      "description": "Version of this, if any",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Image {
        ///size of blocks in bytes
        pub block_size: ByteCount,
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///Hash of the image contents, if applicable
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub digest: ::std::option::Option<Digest>,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///The project the disk belongs to
        pub project_id: ::uuid::Uuid,
        ///total size in bytes
        pub size: ByteCount,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        ///URL source of this image, if any
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub url: ::std::option::Option<::std::string::String>,
        ///Version of this, if any
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub version: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&Image> for Image {
        fn from(value: &Image) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for an
    /// [`Image`](crate::external_api::views::Image)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an
    /// [`Image`](crate::external_api::views::Image)",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "name",
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "description": "block size in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BlockSize"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "source": {
    ///      "description": "The source of the image's contents.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ImageSource"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ImageCreate {
        ///block size in bytes
        pub block_size: BlockSize,
        pub description: ::std::string::String,
        pub name: Name,
        ///The source of the image's contents.
        pub source: ImageSource,
    }

    impl ::std::convert::From<&ImageCreate> for ImageCreate {
        fn from(value: &ImageCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Image"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ImageResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Image>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ImageResultsPage> for ImageResultsPage {
        fn from(value: &ImageResultsPage) -> Self {
            value.clone()
        }
    }

    ///The source of the underlying image.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The source of the underlying image.",
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "url"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "url"
    ///          ]
    ///        },
    ///        "url": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "snapshot"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Boot the Alpine ISO that ships with the Propolis
    /// zone. Intended for development purposes only.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "you_can_boot_anything_as_long_as_its_alpine"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type")]
    pub enum ImageSource {
        #[serde(rename = "url")]
        Url { url: ::std::string::String },
        #[serde(rename = "snapshot")]
        Snapshot { id: ::uuid::Uuid },
        #[serde(rename = "you_can_boot_anything_as_long_as_its_alpine")]
        YouCanBootAnythingAsLongAsItsAlpine,
    }

    impl ::std::convert::From<&Self> for ImageSource {
        fn from(value: &ImageSource) -> Self {
            value.clone()
        }
    }

    ///Client view of an [`Instance`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of an [`Instance`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "hostname",
    ///    "id",
    ///    "memory",
    ///    "name",
    ///    "ncpus",
    ///    "project_id",
    ///    "run_state",
    ///    "time_created",
    ///    "time_modified",
    ///    "time_run_state_updated"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "hostname": {
    ///      "description": "RFC1035-compliant hostname for the Instance.",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "memory": {
    ///      "description": "memory allocated for this Instance",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "ncpus": {
    ///      "description": "number of CPUs allocated for this Instance",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/InstanceCpuCount"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "description": "id for the project containing this Instance",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "run_state": {
    ///      "$ref": "#/components/schemas/InstanceState"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_run_state_updated": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Instance {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///RFC1035-compliant hostname for the Instance.
        pub hostname: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///memory allocated for this Instance
        pub memory: ByteCount,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///number of CPUs allocated for this Instance
        pub ncpus: InstanceCpuCount,
        ///id for the project containing this Instance
        pub project_id: ::uuid::Uuid,
        pub run_state: InstanceState,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        pub time_run_state_updated: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Instance> for Instance {
        fn from(value: &Instance) -> Self {
            value.clone()
        }
    }

    ///The number of CPUs in an Instance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The number of CPUs in an Instance",
    ///  "type": "integer",
    ///  "format": "uint16",
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct InstanceCpuCount(pub u16);
    impl ::std::ops::Deref for InstanceCpuCount {
        type Target = u16;
        fn deref(&self) -> &u16 {
            &self.0
        }
    }

    impl ::std::convert::From<InstanceCpuCount> for u16 {
        fn from(value: InstanceCpuCount) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InstanceCpuCount> for InstanceCpuCount {
        fn from(value: &InstanceCpuCount) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<u16> for InstanceCpuCount {
        fn from(value: u16) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for InstanceCpuCount {
        type Err = <u16 as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl ::std::convert::TryFrom<&str> for InstanceCpuCount {
        type Error = <u16 as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for InstanceCpuCount {
        type Error = <u16 as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for InstanceCpuCount {
        type Error = <u16 as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for InstanceCpuCount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///Create-time parameters for an
    /// [`Instance`](omicron_common::api::external::Instance)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an
    /// [`Instance`](omicron_common::api::external::Instance)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "hostname",
    ///    "memory",
    ///    "name",
    ///    "ncpus"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "disks": {
    ///      "description": "The disks to be created or attached for this
    /// instance.",
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InstanceDiskAttachment"
    ///      }
    ///    },
    ///    "external_ips": {
    ///      "description": "The external IP addresses provided to this
    /// instance.\n\nBy default, all instances have outbound connectivity, but
    /// no inbound connectivity. These external addresses can be used to provide
    /// a fixed, known IP address for making inbound connections to the
    /// instance.",
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExternalIpCreate"
    ///      }
    ///    },
    ///    "hostname": {
    ///      "type": "string"
    ///    },
    ///    "memory": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "ncpus": {
    ///      "$ref": "#/components/schemas/InstanceCpuCount"
    ///    },
    ///    "network_interfaces": {
    ///      "description": "The network interfaces to be created for this
    /// instance.",
    ///      "default": {
    ///        "type": "default"
    ///      },
    ///      "allOf": [
    ///        {
    ///          "$ref":
    /// "#/components/schemas/InstanceNetworkInterfaceAttachment"
    ///        }
    ///      ]
    ///    },
    ///    "start": {
    ///      "description": "Should this instance be started upon creation; true
    /// by default.",
    ///      "default": true,
    ///      "type": "boolean"
    ///    },
    ///    "user_data": {
    ///      "description": "User data for instance initialization systems (such
    /// as cloud-init). Must be a Base64-encoded string, as specified in RFC
    /// 4648  4 (+ and / characters with padding). Maximum 32 KiB unencoded
    /// data.",
    ///      "default": "",
    ///      "type": "string",
    ///      "format": "byte"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InstanceCreate {
        pub description: ::std::string::String,
        ///The disks to be created or attached for this instance.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub disks: ::std::vec::Vec<InstanceDiskAttachment>,
        ///The external IP addresses provided to this instance.
        ///
        ///By default, all instances have outbound connectivity, but no inbound
        /// connectivity. These external addresses can be used to provide a
        /// fixed, known IP address for making inbound connections to the
        /// instance.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub external_ips: ::std::vec::Vec<ExternalIpCreate>,
        pub hostname: ::std::string::String,
        pub memory: ByteCount,
        pub name: Name,
        pub ncpus: InstanceCpuCount,
        ///The network interfaces to be created for this instance.
        #[serde(default = "defaults::instance_create_network_interfaces")]
        pub network_interfaces: InstanceNetworkInterfaceAttachment,
        ///Should this instance be started upon creation; true by default.
        #[serde(default = "defaults::default_bool::<true>")]
        pub start: bool,
        ///User data for instance initialization systems (such as cloud-init).
        /// Must be a Base64-encoded string, as specified in RFC 4648  4 (+ and
        /// / characters with padding). Maximum 32 KiB unencoded data.
        #[serde(default)]
        pub user_data: ::std::string::String,
    }

    impl ::std::convert::From<&InstanceCreate> for InstanceCreate {
        fn from(value: &InstanceCreate) -> Self {
            value.clone()
        }
    }

    ///Describe the instance's disks at creation time
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describe the instance's disks at creation time",
    ///  "oneOf": [
    ///    {
    ///      "description": "During instance creation, create and attach disks",
    ///      "type": "object",
    ///      "required": [
    ///        "description",
    ///        "disk_source",
    ///        "name",
    ///        "size",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "description": {
    ///          "type": "string"
    ///        },
    ///        "disk_source": {
    ///          "description": "initial source for this disk",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/DiskSource"
    ///            }
    ///          ]
    ///        },
    ///        "name": {
    ///          "$ref": "#/components/schemas/Name"
    ///        },
    ///        "size": {
    ///          "description": "total size of the Disk in bytes",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/ByteCount"
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "create"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "During instance creation, attach this disk",
    ///      "type": "object",
    ///      "required": [
    ///        "name",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "name": {
    ///          "description": "A disk name to attach",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "attach"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type")]
    pub enum InstanceDiskAttachment {
        ///During instance creation, create and attach disks
        #[serde(rename = "create")]
        Create {
            description: ::std::string::String,
            ///initial source for this disk
            disk_source: DiskSource,
            name: Name,
            ///total size of the Disk in bytes
            size: ByteCount,
        },
        ///During instance creation, attach this disk
        #[serde(rename = "attach")]
        Attach {
            ///A disk name to attach
            name: Name,
        },
    }

    impl ::std::convert::From<&Self> for InstanceDiskAttachment {
        fn from(value: &InstanceDiskAttachment) -> Self {
            value.clone()
        }
    }

    ///Migration parameters for an
    /// [`Instance`](omicron_common::api::external::Instance)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Migration parameters for an
    /// [`Instance`](omicron_common::api::external::Instance)",
    ///  "type": "object",
    ///  "required": [
    ///    "dst_sled_id"
    ///  ],
    ///  "properties": {
    ///    "dst_sled_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InstanceMigrate {
        pub dst_sled_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&InstanceMigrate> for InstanceMigrate {
        fn from(value: &InstanceMigrate) -> Self {
            value.clone()
        }
    }

    ///Describes an attachment of a `NetworkInterface` to an `Instance`, at the
    /// time the instance is created.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes an attachment of a `NetworkInterface` to an
    /// `Instance`, at the time the instance is created.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Create one or more `NetworkInterface`s for the
    /// `Instance`.\n\nIf more than one interface is provided, then the first
    /// will be designated the primary interface for the instance.",
    ///      "type": "object",
    ///      "required": [
    ///        "params",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "params": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/NetworkInterfaceCreate"
    ///          }
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "create"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The default networking configuration for an
    /// instance is to create a single primary interface with an
    /// automatically-assigned IP address. The IP will be pulled from the
    /// Project's default VPC / VPC Subnet.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "default"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "No network interfaces at all will be created for
    /// the instance.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "none"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type", content = "params")]
    pub enum InstanceNetworkInterfaceAttachment {
        ///Create one or more `NetworkInterface`s for the `Instance`.
        ///
        ///If more than one interface is provided, then the first will be
        /// designated the primary interface for the instance.
        #[serde(rename = "create")]
        Create(::std::vec::Vec<NetworkInterfaceCreate>),
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "none")]
        None,
    }

    impl ::std::convert::From<&Self> for InstanceNetworkInterfaceAttachment {
        fn from(value: &InstanceNetworkInterfaceAttachment) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::vec::Vec<NetworkInterfaceCreate>>
        for InstanceNetworkInterfaceAttachment
    {
        fn from(value: ::std::vec::Vec<NetworkInterfaceCreate>) -> Self {
            Self::Create(value)
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Instance"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InstanceResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Instance>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&InstanceResultsPage> for InstanceResultsPage {
        fn from(value: &InstanceResultsPage) -> Self {
            value.clone()
        }
    }

    ///Contents of an Instance's serial console buffer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contents of an Instance's serial console buffer.",
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "last_byte_offset"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "description": "The bytes starting from the requested offset up to
    /// either the end of the buffer or the request's `max_bytes`. Provided as a
    /// u8 array rather than a string, as it may not be UTF-8.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint8",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "last_byte_offset": {
    ///      "description": "The absolute offset since boot (suitable for use as
    /// `byte_offset` in a subsequent request) of the last byte returned in
    /// `data`.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InstanceSerialConsoleData {
        ///The bytes starting from the requested offset up to either the end of
        /// the buffer or the request's `max_bytes`. Provided as a u8 array
        /// rather than a string, as it may not be UTF-8.
        pub data: ::std::vec::Vec<u8>,
        ///The absolute offset since boot (suitable for use as `byte_offset` in
        /// a subsequent request) of the last byte returned in `data`.
        pub last_byte_offset: u64,
    }

    impl ::std::convert::From<&InstanceSerialConsoleData> for InstanceSerialConsoleData {
        fn from(value: &InstanceSerialConsoleData) -> Self {
            value.clone()
        }
    }

    ///Running state of an Instance (primarily: booted or stopped)
    ///
    ///This typically reflects whether it's starting, running, stopping, or
    /// stopped, but also includes states related to the Instance's lifecycle
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Running state of an Instance (primarily: booted or
    /// stopped)\n\nThis typically reflects whether it's starting, running,
    /// stopping, or stopped, but also includes states related to the Instance's
    /// lifecycle",
    ///  "oneOf": [
    ///    {
    ///      "description": "The instance is being created.",
    ///      "type": "string",
    ///      "enum": [
    ///        "creating"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is currently starting up.",
    ///      "type": "string",
    ///      "enum": [
    ///        "starting"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is currently running.",
    ///      "type": "string",
    ///      "enum": [
    ///        "running"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance has been requested to stop and a
    /// transition to \"Stopped\" is imminent.",
    ///      "type": "string",
    ///      "enum": [
    ///        "stopping"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is currently stopped.",
    ///      "type": "string",
    ///      "enum": [
    ///        "stopped"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is in the process of rebooting - it
    /// will remain in the \"rebooting\" state until the VM is starting once
    /// more.",
    ///      "type": "string",
    ///      "enum": [
    ///        "rebooting"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is in the process of migrating - it will remain in the \"migrating\" state until the migration process is complete and the destination propolis is ready to continue execution.",
    ///      "type": "string",
    ///      "enum": [
    ///        "migrating"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is attempting to recover from a
    /// failure.",
    ///      "type": "string",
    ///      "enum": [
    ///        "repairing"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance has encountered a failure.",
    ///      "type": "string",
    ///      "enum": [
    ///        "failed"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance has been deleted.",
    ///      "type": "string",
    ///      "enum": [
    ///        "destroyed"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InstanceState {
        ///The instance is being created.
        #[serde(rename = "creating")]
        Creating,
        ///The instance is currently starting up.
        #[serde(rename = "starting")]
        Starting,
        ///The instance is currently running.
        #[serde(rename = "running")]
        Running,
        ///The instance has been requested to stop and a transition to
        /// "Stopped" is imminent.
        #[serde(rename = "stopping")]
        Stopping,
        ///The instance is currently stopped.
        #[serde(rename = "stopped")]
        Stopped,
        ///The instance is in the process of rebooting - it will remain in the
        /// "rebooting" state until the VM is starting once more.
        #[serde(rename = "rebooting")]
        Rebooting,
        ///The instance is in the process of migrating - it will remain in the
        /// "migrating" state until the migration process is complete and the
        /// destination propolis is ready to continue execution.
        #[serde(rename = "migrating")]
        Migrating,
        ///The instance is attempting to recover from a failure.
        #[serde(rename = "repairing")]
        Repairing,
        ///The instance has encountered a failure.
        #[serde(rename = "failed")]
        Failed,
        ///The instance has been deleted.
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl ::std::convert::From<&Self> for InstanceState {
        fn from(value: &InstanceState) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InstanceState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Creating => write!(f, "creating"),
                Self::Starting => write!(f, "starting"),
                Self::Running => write!(f, "running"),
                Self::Stopping => write!(f, "stopping"),
                Self::Stopped => write!(f, "stopped"),
                Self::Rebooting => write!(f, "rebooting"),
                Self::Migrating => write!(f, "migrating"),
                Self::Repairing => write!(f, "repairing"),
                Self::Failed => write!(f, "failed"),
                Self::Destroyed => write!(f, "destroyed"),
            }
        }
    }

    impl ::std::str::FromStr for InstanceState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "creating" => Ok(Self::Creating),
                "starting" => Ok(Self::Starting),
                "running" => Ok(Self::Running),
                "stopping" => Ok(Self::Stopping),
                "stopped" => Ok(Self::Stopped),
                "rebooting" => Ok(Self::Rebooting),
                "migrating" => Ok(Self::Migrating),
                "repairing" => Ok(Self::Repairing),
                "failed" => Ok(Self::Failed),
                "destroyed" => Ok(Self::Destroyed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InstanceState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InstanceState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InstanceState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The kind of an external IP address for an instance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The kind of an external IP address for an instance",
    ///  "type": "string",
    ///  "enum": [
    ///    "ephemeral",
    ///    "floating"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum IpKind {
        #[serde(rename = "ephemeral")]
        Ephemeral,
        #[serde(rename = "floating")]
        Floating,
    }

    impl ::std::convert::From<&Self> for IpKind {
        fn from(value: &IpKind) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IpKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ephemeral => write!(f, "ephemeral"),
                Self::Floating => write!(f, "floating"),
            }
        }
    }

    impl ::std::str::FromStr for IpKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ephemeral" => Ok(Self::Ephemeral),
                "floating" => Ok(Self::Floating),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IpKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IpKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IpKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`IpNet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "title": "v4",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "title": "v6",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum IpNet {
        V4(Ipv4Net),
        V6(Ipv6Net),
    }

    impl ::std::convert::From<&Self> for IpNet {
        fn from(value: &IpNet) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for IpNet {
        type Err = self::error::ConversionError;
        #[allow(irrefutable_let_patterns)]
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::V4(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::V6(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IpNet {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IpNet {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IpNet {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for IpNet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::V4(x) => x.fmt(f),
                Self::V6(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<Ipv4Net> for IpNet {
        fn from(value: Ipv4Net) -> Self {
            Self::V4(value)
        }
    }

    impl ::std::convert::From<Ipv6Net> for IpNet {
        fn from(value: Ipv6Net) -> Self {
            Self::V6(value)
        }
    }

    ///Identity-related metadata that's included in nearly all public API
    /// objects
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in nearly all
    /// public API objects",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IpPool {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&IpPool> for IpPool {
        fn from(value: &IpPool) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for an IP Pool.
    ///
    ///See [`IpPool`](crate::external_api::views::IpPool)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an IP Pool.\n\nSee
    /// [`IpPool`](crate::external_api::views::IpPool)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IpPoolCreate {
        pub description: ::std::string::String,
        pub name: Name,
    }

    impl ::std::convert::From<&IpPoolCreate> for IpPoolCreate {
        fn from(value: &IpPoolCreate) -> Self {
            value.clone()
        }
    }

    ///`IpPoolRange`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "range",
    ///    "time_created"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "range": {
    ///      "$ref": "#/components/schemas/IpRange"
    ///    },
    ///    "time_created": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IpPoolRange {
        pub id: ::uuid::Uuid,
        pub range: IpRange,
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&IpPoolRange> for IpPoolRange {
        fn from(value: &IpPoolRange) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpPoolRange"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IpPoolRangeResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<IpPoolRange>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&IpPoolRangeResultsPage> for IpPoolRangeResultsPage {
        fn from(value: &IpPoolRangeResultsPage) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpPool"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IpPoolResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<IpPool>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&IpPoolResultsPage> for IpPoolResultsPage {
        fn from(value: &IpPoolResultsPage) -> Self {
            value.clone()
        }
    }

    ///Parameters for updating an IP Pool
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters for updating an IP Pool",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IpPoolUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&IpPoolUpdate> for IpPoolUpdate {
        fn from(value: &IpPoolUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for IpPoolUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    ///`IpRange`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "title": "v4",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Range"
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "title": "v6",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Range"
    ///        }
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum IpRange {
        V4(Ipv4Range),
        V6(Ipv6Range),
    }

    impl ::std::convert::From<&Self> for IpRange {
        fn from(value: &IpRange) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<Ipv4Range> for IpRange {
        fn from(value: Ipv4Range) -> Self {
            Self::V4(value)
        }
    }

    impl ::std::convert::From<Ipv6Range> for IpRange {
        fn from(value: Ipv6Range) -> Self {
            Self::V6(value)
        }
    }

    ///An IPv4 subnet, including prefix and subnet mask
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "An IPv4 subnet",
    ///  "description": "An IPv4 subnet, including prefix and subnet mask",
    ///  "examples": [
    ///    "192.168.1.0/24"
    ///  ],
    ///  "type": "string",
    ///  "pattern":
    /// "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.
    /// ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/
    /// ([8-9]|1[0-9]|2[0-9]|3[0-2])$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct Ipv4Net(::std::string::String);
    impl ::std::ops::Deref for Ipv4Net {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<Ipv4Net> for ::std::string::String {
        fn from(value: Ipv4Net) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Ipv4Net> for Ipv4Net {
        fn from(value: &Ipv4Net) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Ipv4Net {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.\
                         ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/\
                         ([8-9]|1[0-9]|2[0-9]|3[0-2])$",
                    )
                    .expect("Invalid regex pattern in schema")
                });
            if (&*PATTERN).find(value).is_none() {
                return Err("doesn't match pattern \
                            \"^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.\
                            ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/\
                            ([8-9]|1[0-9]|2[0-9]|3[0-2])$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Ipv4Net {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Ipv4Net {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Ipv4Net {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Ipv4Net {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A non-decreasing IPv4 address range, inclusive of both ends.
    ///
    ///The first address must be less than or equal to the last address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A non-decreasing IPv4 address range, inclusive of both
    /// ends.\n\nThe first address must be less than or equal to the last
    /// address.",
    ///  "type": "object",
    ///  "required": [
    ///    "first",
    ///    "last"
    ///  ],
    ///  "properties": {
    ///    "first": {
    ///      "type": "string",
    ///      "format": "ipv4"
    ///    },
    ///    "last": {
    ///      "type": "string",
    ///      "format": "ipv4"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Ipv4Range {
        pub first: ::std::net::Ipv4Addr,
        pub last: ::std::net::Ipv4Addr,
    }

    impl ::std::convert::From<&Ipv4Range> for Ipv4Range {
        fn from(value: &Ipv4Range) -> Self {
            value.clone()
        }
    }

    ///An IPv6 subnet, including prefix and subnet mask
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "An IPv6 subnet",
    ///  "description": "An IPv6 subnet, including prefix and subnet mask",
    ///  "examples": [
    ///    "fd12:3456::/64"
    ///  ],
    ///  "type": "string",
    ///  "pattern":
    /// "^([fF][dD])[0-9a-fA-F]{2}:(([0-9a-fA-F]{1,4}:){6}[0-9a-fA-F]{1,
    /// 4}|([0-9a-fA-F]{1,4}:){1,6}:)\\/([1-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct Ipv6Net(::std::string::String);
    impl ::std::ops::Deref for Ipv6Net {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<Ipv6Net> for ::std::string::String {
        fn from(value: Ipv6Net) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Ipv6Net> for Ipv6Net {
        fn from(value: &Ipv6Net) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Ipv6Net {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^([fF][dD])[0-9a-fA-F]{2}:(([0-9a-fA-F]{1,4}:){6}[0-9a-fA-F]{1,\
                         4}|([0-9a-fA-F]{1,4}:){1,6}:)\\/([1-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$",
                    )
                    .expect("Invalid regex pattern in schema")
                });
            if (&*PATTERN).find(value).is_none() {
                return Err("doesn't match pattern \
                            \"^([fF][dD])[0-9a-fA-F]{2}:(([0-9a-fA-F]{1,4}:){6}[0-9a-fA-F]{1,\
                            4}|([0-9a-fA-F]{1,4}:){1,6}:)\\/\
                            ([1-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Ipv6Net {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Ipv6Net {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Ipv6Net {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Ipv6Net {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A non-decreasing IPv6 address range, inclusive of both ends.
    ///
    ///The first address must be less than or equal to the last address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A non-decreasing IPv6 address range, inclusive of both
    /// ends.\n\nThe first address must be less than or equal to the last
    /// address.",
    ///  "type": "object",
    ///  "required": [
    ///    "first",
    ///    "last"
    ///  ],
    ///  "properties": {
    ///    "first": {
    ///      "type": "string",
    ///      "format": "ipv6"
    ///    },
    ///    "last": {
    ///      "type": "string",
    ///      "format": "ipv6"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Ipv6Range {
        pub first: ::std::net::Ipv6Addr,
        pub last: ::std::net::Ipv6Addr,
    }

    impl ::std::convert::From<&Ipv6Range> for Ipv6Range {
        fn from(value: &Ipv6Range) -> Self {
            value.clone()
        }
    }

    ///An inclusive-inclusive range of IP ports. The second port may be omitted
    /// to represent a single port
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A range of IP ports",
    ///  "description": "An inclusive-inclusive range of IP ports. The second
    /// port may be omitted to represent a single port",
    ///  "examples": [
    ///    "22"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 11,
    ///  "minLength": 1,
    ///  "pattern": "^[0-9]{1,5}(-[0-9]{1,5})?$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct L4PortRange(::std::string::String);
    impl ::std::ops::Deref for L4PortRange {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<L4PortRange> for ::std::string::String {
        fn from(value: L4PortRange) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&L4PortRange> for L4PortRange {
        fn from(value: &L4PortRange) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for L4PortRange {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 11usize {
                return Err("longer than 11 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[0-9]{1,5}(-[0-9]{1,5})?$")
                        .expect("Invalid regex pattern in schema")
                });
            if (&*PATTERN).find(value).is_none() {
                return Err("doesn't match pattern \"^[0-9]{1,5}(-[0-9]{1,5})?$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for L4PortRange {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for L4PortRange {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for L4PortRange {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for L4PortRange {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A Media Access Control address, in EUI-48 format
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A MAC address",
    ///  "description": "A Media Access Control address, in EUI-48 format",
    ///  "examples": [
    ///    "ff:ff:ff:ff:ff:ff"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 17,
    ///  "minLength": 17,
    ///  "pattern": "^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct MacAddr(::std::string::String);
    impl ::std::ops::Deref for MacAddr {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<MacAddr> for ::std::string::String {
        fn from(value: MacAddr) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&MacAddr> for MacAddr {
        fn from(value: &MacAddr) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for MacAddr {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 17usize {
                return Err("longer than 17 characters".into());
            }
            if value.chars().count() < 17usize {
                return Err("shorter than 17 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$")
                        .expect("Invalid regex pattern in schema")
                });
            if (&*PATTERN).find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for MacAddr {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MacAddr {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MacAddr {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for MacAddr {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A `Measurement` is a timestamped datum from a single metric
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `Measurement` is a timestamped datum from a single
    /// metric",
    ///  "type": "object",
    ///  "required": [
    ///    "datum",
    ///    "timestamp"
    ///  ],
    ///  "properties": {
    ///    "datum": {
    ///      "$ref": "#/components/schemas/Datum"
    ///    },
    ///    "timestamp": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Measurement {
        pub datum: Datum,
        pub timestamp: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Measurement> for Measurement {
        fn from(value: &Measurement) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Measurement"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MeasurementResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Measurement>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MeasurementResultsPage> for MeasurementResultsPage {
        fn from(value: &MeasurementResultsPage) -> Self {
            value.clone()
        }
    }

    ///Names must begin with a lower case ASCII letter, be composed exclusively
    /// of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end
    /// with a '-'. Names cannot be a UUID though they may contain a UUID.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A name unique within the parent collection",
    ///  "description": "Names must begin with a lower case ASCII letter, be
    /// composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and
    /// '-', and may not end with a '-'. Names cannot be a UUID though they may
    /// contain a UUID.",
    ///  "type": "string",
    ///  "maxLength": 63,
    ///  "pattern":
    /// "^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*
    /// [a-zA-Z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct Name(::std::string::String);
    impl ::std::ops::Deref for Name {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<Name> for ::std::string::String {
        fn from(value: Name) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Name> for Name {
        fn from(value: &Name) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Name {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 63usize {
                return Err("longer than 63 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    :: regress :: Regex :: new ("^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]$") . expect ("Invalid regex pattern in schema")
                },
            );
            if (&*PATTERN).find(value).is_none() {
                return Err ("doesn't match pattern \"^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]$\"" . into ()) ;
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Name {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Name {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Name {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Name {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`NameOrId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "title": "id",
    ///      "allOf": [
    ///        {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "title": "name",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum NameOrId {
        Id(::uuid::Uuid),
        Name(Name),
    }

    impl ::std::convert::From<&Self> for NameOrId {
        fn from(value: &NameOrId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for NameOrId {
        type Err = self::error::ConversionError;
        #[allow(irrefutable_let_patterns)]
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Id(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Name(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for NameOrId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for NameOrId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for NameOrId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for NameOrId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Id(x) => x.fmt(f),
                Self::Name(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<::uuid::Uuid> for NameOrId {
        fn from(value: ::uuid::Uuid) -> Self {
            Self::Id(value)
        }
    }

    impl ::std::convert::From<Name> for NameOrId {
        fn from(value: Name) -> Self {
            Self::Name(value)
        }
    }

    ///Supported set of sort modes for scanning by name or id
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Supported set of sort modes for scanning by name or
    /// id",
    ///  "oneOf": [
    ///    {
    ///      "description": "sort in increasing order of \"name\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "name_ascending"
    ///      ]
    ///    },
    ///    {
    ///      "description": "sort in decreasing order of \"name\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "name_descending"
    ///      ]
    ///    },
    ///    {
    ///      "description": "sort in increasing order of \"id\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "id_ascending"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NameOrIdSortMode {
        ///sort in increasing order of "name"
        #[serde(rename = "name_ascending")]
        NameAscending,
        ///sort in decreasing order of "name"
        #[serde(rename = "name_descending")]
        NameDescending,
        ///sort in increasing order of "id"
        #[serde(rename = "id_ascending")]
        IdAscending,
    }

    impl ::std::convert::From<&Self> for NameOrIdSortMode {
        fn from(value: &NameOrIdSortMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for NameOrIdSortMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NameAscending => write!(f, "name_ascending"),
                Self::NameDescending => write!(f, "name_descending"),
                Self::IdAscending => write!(f, "id_ascending"),
            }
        }
    }

    impl ::std::str::FromStr for NameOrIdSortMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "name_ascending" => Ok(Self::NameAscending),
                "name_descending" => Ok(Self::NameDescending),
                "id_ascending" => Ok(Self::IdAscending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for NameOrIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for NameOrIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for NameOrIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Supported set of sort modes for scanning by name only
    ///
    ///Currently, we only support scanning in ascending order.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Supported set of sort modes for scanning by name
    /// only\n\nCurrently, we only support scanning in ascending order.",
    ///  "oneOf": [
    ///    {
    ///      "description": "sort in increasing order of \"name\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "name_ascending"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NameSortMode {
        ///sort in increasing order of "name"
        #[serde(rename = "name_ascending")]
        NameAscending,
    }

    impl ::std::convert::From<&Self> for NameSortMode {
        fn from(value: &NameSortMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for NameSortMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NameAscending => write!(f, "name_ascending"),
            }
        }
    }

    impl ::std::str::FromStr for NameSortMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "name_ascending" => Ok(Self::NameAscending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for NameSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for NameSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for NameSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A `NetworkInterface` represents a virtual network interface device.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `NetworkInterface` represents a virtual network
    /// interface device.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "instance_id",
    ///    "ip",
    ///    "mac",
    ///    "name",
    ///    "primary",
    ///    "subnet_id",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "instance_id": {
    ///      "description": "The Instance to which the interface belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ip": {
    ///      "description": "The IP address assigned to this interface.",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "mac": {
    ///      "description": "The MAC address assigned to this interface.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/MacAddr"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "primary": {
    ///      "description": "True if this interface is the primary for the
    /// instance to which it's attached.",
    ///      "type": "boolean"
    ///    },
    ///    "subnet_id": {
    ///      "description": "The subnet to which the interface belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which the interface belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NetworkInterface {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///The Instance to which the interface belongs.
        pub instance_id: ::uuid::Uuid,
        ///The IP address assigned to this interface.
        pub ip: ::std::net::IpAddr,
        ///The MAC address assigned to this interface.
        pub mac: MacAddr,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///True if this interface is the primary for the instance to which it's
        /// attached.
        pub primary: bool,
        ///The subnet to which the interface belongs.
        pub subnet_id: ::uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        ///The VPC to which the interface belongs.
        pub vpc_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&NetworkInterface> for NetworkInterface {
        fn from(value: &NetworkInterface) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a
    /// [`NetworkInterface`](omicron_common::api::external::NetworkInterface)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a [`NetworkInterface`](omicron_common::api::external::NetworkInterface)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name",
    ///    "subnet_name",
    ///    "vpc_name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "ip": {
    ///      "description": "The IP address for the interface. One will be
    /// auto-assigned if not provided.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "ip"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "subnet_name": {
    ///      "description": "The VPC Subnet in which to create the interface.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "vpc_name": {
    ///      "description": "The VPC in which to create the interface.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NetworkInterfaceCreate {
        pub description: ::std::string::String,
        ///The IP address for the interface. One will be auto-assigned if not
        /// provided.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ip: ::std::option::Option<::std::net::IpAddr>,
        pub name: Name,
        ///The VPC Subnet in which to create the interface.
        pub subnet_name: Name,
        ///The VPC in which to create the interface.
        pub vpc_name: Name,
    }

    impl ::std::convert::From<&NetworkInterfaceCreate> for NetworkInterfaceCreate {
        fn from(value: &NetworkInterfaceCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NetworkInterface"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NetworkInterfaceResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<NetworkInterface>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&NetworkInterfaceResultsPage> for NetworkInterfaceResultsPage {
        fn from(value: &NetworkInterfaceResultsPage) -> Self {
            value.clone()
        }
    }

    ///Parameters for updating a
    /// [`NetworkInterface`](omicron_common::api::external::NetworkInterface).
    ///
    ///Note that modifying IP addresses for an interface is not yet supported,
    /// a new interface must be created instead.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters for updating a
    /// [`NetworkInterface`](omicron_common::api::external::NetworkInterface).\
    /// n\nNote that modifying IP addresses for an interface is not yet
    /// supported, a new interface must be created instead.",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "primary": {
    ///      "description": "Make a secondary interface the instance's primary
    /// interface.\n\nIf applied to a secondary interface, that interface will
    /// become the primary on the next reboot of the instance. Note that this
    /// may have implications for routing between instances, as the new primary
    /// interface will be on a distinct subnet from the previous primary
    /// interface.\n\nNote that this can only be used to select a new primary
    /// interface for an instance. Requests to change the primary interface into
    /// a secondary will return an error.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NetworkInterfaceUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
        ///Make a secondary interface the instance's primary interface.
        ///
        ///If applied to a secondary interface, that interface will become the
        /// primary on the next reboot of the instance. Note that this may have
        /// implications for routing between instances, as the new primary
        /// interface will be on a distinct subnet from the previous primary
        /// interface.
        ///
        ///Note that this can only be used to select a new primary interface
        /// for an instance. Requests to change the primary interface into a
        /// secondary will return an error.
        #[serde(default)]
        pub primary: bool,
    }

    impl ::std::convert::From<&NetworkInterfaceUpdate> for NetworkInterfaceUpdate {
        fn from(value: &NetworkInterfaceUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for NetworkInterfaceUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
                primary: Default::default(),
            }
        }
    }

    ///Unique name for a saga [`Node`]
    ///
    ///Each node requires a string name that's unique within its DAG.  The name
    /// is used to identify its output.  Nodes that depend on a given node
    /// (either directly or indirectly) can access the node's output using its
    /// name.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unique name for a saga [`Node`]\n\nEach node requires a
    /// string name that's unique within its DAG.  The name is used to identify
    /// its output.  Nodes that depend on a given node (either directly or
    /// indirectly) can access the node's output using its name.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct NodeName(pub ::std::string::String);
    impl ::std::ops::Deref for NodeName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<NodeName> for ::std::string::String {
        fn from(value: NodeName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&NodeName> for NodeName {
        fn from(value: &NodeName) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for NodeName {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for NodeName {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for NodeName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///Client view of an [`Organization`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of an [`Organization`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Organization {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Organization> for Organization {
        fn from(value: &Organization) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for an
    /// [`Organization`](crate::external_api::views::Organization)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an
    /// [`Organization`](crate::external_api::views::Organization)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OrganizationCreate {
        pub description: ::std::string::String,
        pub name: Name,
    }

    impl ::std::convert::From<&OrganizationCreate> for OrganizationCreate {
        fn from(value: &OrganizationCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Organization"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OrganizationResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Organization>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&OrganizationResultsPage> for OrganizationResultsPage {
        fn from(value: &OrganizationResultsPage) -> Self {
            value.clone()
        }
    }

    ///`OrganizationRole`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OrganizationRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl ::std::convert::From<&Self> for OrganizationRole {
        fn from(value: &OrganizationRole) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OrganizationRole {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Admin => write!(f, "admin"),
                Self::Collaborator => write!(f, "collaborator"),
                Self::Viewer => write!(f, "viewer"),
            }
        }
    }

    impl ::std::str::FromStr for OrganizationRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for OrganizationRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for OrganizationRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for OrganizationRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Policy`], which describes how this
    /// resource may be accessed\n\nNote that the Policy only describes access
    /// granted explicitly for this resource.  The policies of parent resources
    /// can also cause a user to have access to this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/OrganizationRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OrganizationRolePolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: ::std::vec::Vec<OrganizationRoleRoleAssignment>,
    }

    impl ::std::convert::From<&OrganizationRolePolicy> for OrganizationRolePolicy {
        fn from(value: &OrganizationRolePolicy) -> Self {
            value.clone()
        }
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, [`RoleAssignment`]s are
    /// put into a [`Policy`] and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/OrganizationRole"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OrganizationRoleRoleAssignment {
        pub identity_id: ::uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: OrganizationRole,
    }

    impl ::std::convert::From<&OrganizationRoleRoleAssignment> for OrganizationRoleRoleAssignment {
        fn from(value: &OrganizationRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    ///Updateable properties of an
    /// [`Organization`](crate::external_api::views::Organization)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of an
    /// [`Organization`](crate::external_api::views::Organization)",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OrganizationUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&OrganizationUpdate> for OrganizationUpdate {
        fn from(value: &OrganizationUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for OrganizationUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    ///Passwords may be subject to additional constraints.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A password used to authenticate a user",
    ///  "description": "Passwords may be subject to additional constraints.",
    ///  "type": "string",
    ///  "maxLength": 512
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct Password(::std::string::String);
    impl ::std::ops::Deref for Password {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<Password> for ::std::string::String {
        fn from(value: Password) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Password> for Password {
        fn from(value: &Password) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Password {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Password {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Password {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Password {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Password {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Client view of a [`PhysicalDisk`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`PhysicalDisk`]",
    ///  "type": "object",
    ///  "required": [
    ///    "disk_type",
    ///    "id",
    ///    "model",
    ///    "serial",
    ///    "time_created",
    ///    "time_modified",
    ///    "vendor"
    ///  ],
    ///  "properties": {
    ///    "disk_type": {
    ///      "$ref": "#/components/schemas/PhysicalDiskType"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "model": {
    ///      "type": "string"
    ///    },
    ///    "serial": {
    ///      "type": "string"
    ///    },
    ///    "sled_id": {
    ///      "description": "The sled to which this disk is attached, if any.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vendor": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PhysicalDisk {
        pub disk_type: PhysicalDiskType,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        pub model: ::std::string::String,
        pub serial: ::std::string::String,
        ///The sled to which this disk is attached, if any.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sled_id: ::std::option::Option<::uuid::Uuid>,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        pub vendor: ::std::string::String,
    }

    impl ::std::convert::From<&PhysicalDisk> for PhysicalDisk {
        fn from(value: &PhysicalDisk) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PhysicalDisk"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PhysicalDiskResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<PhysicalDisk>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PhysicalDiskResultsPage> for PhysicalDiskResultsPage {
        fn from(value: &PhysicalDiskResultsPage) -> Self {
            value.clone()
        }
    }

    ///`PhysicalDiskType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "internal",
    ///    "external"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PhysicalDiskType {
        #[serde(rename = "internal")]
        Internal,
        #[serde(rename = "external")]
        External,
    }

    impl ::std::convert::From<&Self> for PhysicalDiskType {
        fn from(value: &PhysicalDiskType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PhysicalDiskType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Internal => write!(f, "internal"),
                Self::External => write!(f, "external"),
            }
        }
    }

    impl ::std::str::FromStr for PhysicalDiskType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "internal" => Ok(Self::Internal),
                "external" => Ok(Self::External),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PhysicalDiskType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PhysicalDiskType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PhysicalDiskType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`Project`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Project`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "organization_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "organization_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Project {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub organization_id: ::uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Project> for Project {
        fn from(value: &Project) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a
    /// [`Project`](crate::external_api::views::Project)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Project`](crate::external_api::views::Project)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProjectCreate {
        pub description: ::std::string::String,
        pub name: Name,
    }

    impl ::std::convert::From<&ProjectCreate> for ProjectCreate {
        fn from(value: &ProjectCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Project"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProjectResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Project>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ProjectResultsPage> for ProjectResultsPage {
        fn from(value: &ProjectResultsPage) -> Self {
            value.clone()
        }
    }

    ///`ProjectRole`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ProjectRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl ::std::convert::From<&Self> for ProjectRole {
        fn from(value: &ProjectRole) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ProjectRole {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Admin => write!(f, "admin"),
                Self::Collaborator => write!(f, "collaborator"),
                Self::Viewer => write!(f, "viewer"),
            }
        }
    }

    impl ::std::str::FromStr for ProjectRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ProjectRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ProjectRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ProjectRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Policy`], which describes how this
    /// resource may be accessed\n\nNote that the Policy only describes access
    /// granted explicitly for this resource.  The policies of parent resources
    /// can also cause a user to have access to this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ProjectRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProjectRolePolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: ::std::vec::Vec<ProjectRoleRoleAssignment>,
    }

    impl ::std::convert::From<&ProjectRolePolicy> for ProjectRolePolicy {
        fn from(value: &ProjectRolePolicy) -> Self {
            value.clone()
        }
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, [`RoleAssignment`]s are
    /// put into a [`Policy`] and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/ProjectRole"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProjectRoleRoleAssignment {
        pub identity_id: ::uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: ProjectRole,
    }

    impl ::std::convert::From<&ProjectRoleRoleAssignment> for ProjectRoleRoleAssignment {
        fn from(value: &ProjectRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    ///Updateable properties of a
    /// [`Project`](crate::external_api::views::Project)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a
    /// [`Project`](crate::external_api::views::Project)",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProjectUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&ProjectUpdate> for ProjectUpdate {
        fn from(value: &ProjectUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ProjectUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    ///Client view of an [`Rack`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of an [`Rack`]",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Rack {
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Rack> for Rack {
        fn from(value: &Rack) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Rack"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RackResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Rack>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RackResultsPage> for RackResultsPage {
        fn from(value: &RackResultsPage) -> Self {
            value.clone()
        }
    }

    ///Client view of a [`Role`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Role`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/RoleName"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Role {
        pub description: ::std::string::String,
        pub name: RoleName,
    }

    impl ::std::convert::From<&Role> for Role {
        fn from(value: &Role) -> Self {
            value.clone()
        }
    }

    ///Role names consist of two string components separated by dot (".").
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A name for a built-in role",
    ///  "description": "Role names consist of two string components separated
    /// by dot (\".\").",
    ///  "type": "string",
    ///  "maxLength": 63,
    ///  "pattern": "[a-z-]+\\.[a-z-]+"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct RoleName(::std::string::String);
    impl ::std::ops::Deref for RoleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<RoleName> for ::std::string::String {
        fn from(value: RoleName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RoleName> for RoleName {
        fn from(value: &RoleName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for RoleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 63usize {
                return Err("longer than 63 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("[a-z-]+\\.[a-z-]+")
                        .expect("Invalid regex pattern in schema")
                });
            if (&*PATTERN).find(value).is_none() {
                return Err("doesn't match pattern \"[a-z-]+\\.[a-z-]+\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for RoleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RoleName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RoleName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for RoleName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Role"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RoleResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Role>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RoleResultsPage> for RoleResultsPage {
        fn from(value: &RoleResultsPage) -> Self {
            value.clone()
        }
    }

    ///A `RouteDestination` is used to match traffic with a routing rule, on
    /// the destination of that traffic.
    ///
    ///When traffic is to be sent to a destination that is within a given
    /// `RouteDestination`, the corresponding [`RouterRoute`] applies, and
    /// traffic will be forward to the [`RouteTarget`] for that rule.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `RouteDestination` is used to match traffic with a
    /// routing rule, on the destination of that traffic.\n\nWhen traffic is to
    /// be sent to a destination that is within a given `RouteDestination`, the
    /// corresponding [`RouterRoute`] applies, and traffic will be forward to
    /// the [`RouteTarget`] for that rule.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Route applies to traffic destined for a specific IP
    /// address",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Route applies to traffic destined for a specific IP
    /// subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip_net"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Route applies to traffic destined for the given
    /// VPC.",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Route applies to traffic",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteDestination {
        ///Route applies to traffic destined for a specific IP address
        #[serde(rename = "ip")]
        Ip(::std::net::IpAddr),
        ///Route applies to traffic destined for a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
        ///Route applies to traffic destined for the given VPC.
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///Route applies to traffic
        #[serde(rename = "subnet")]
        Subnet(Name),
    }

    impl ::std::convert::From<&Self> for RouteDestination {
        fn from(value: &RouteDestination) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::net::IpAddr> for RouteDestination {
        fn from(value: ::std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    impl ::std::convert::From<IpNet> for RouteDestination {
        fn from(value: IpNet) -> Self {
            Self::IpNet(value)
        }
    }

    ///A `RouteTarget` describes the possible locations that traffic matching a
    /// route destination can be sent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `RouteTarget` describes the possible locations that
    /// traffic matching a route destination can be sent.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Forward traffic to a particular IP address.",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to a VPC",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to a VPC Subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to a specific instance",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to an internet gateway",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "internet_gateway"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteTarget {
        ///Forward traffic to a particular IP address.
        #[serde(rename = "ip")]
        Ip(::std::net::IpAddr),
        ///Forward traffic to a VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///Forward traffic to a VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        ///Forward traffic to a specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        ///Forward traffic to an internet gateway
        #[serde(rename = "internet_gateway")]
        InternetGateway(Name),
    }

    impl ::std::convert::From<&Self> for RouteTarget {
        fn from(value: &RouteTarget) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::net::IpAddr> for RouteTarget {
        fn from(value: ::std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    ///A route defines a rule that governs where traffic should be sent based
    /// on its destination.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A route defines a rule that governs where traffic
    /// should be sent based on its destination.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "destination",
    ///    "id",
    ///    "kind",
    ///    "name",
    ///    "target",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_router_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "destination": {
    ///      "$ref": "#/components/schemas/RouteDestination"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "kind": {
    ///      "description": "Describes the kind of router. Set at creation.
    /// `read-only`",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/RouterRouteKind"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "target": {
    ///      "$ref": "#/components/schemas/RouteTarget"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_router_id": {
    ///      "description": "The VPC Router to which the route belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouterRoute {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        pub destination: RouteDestination,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///Describes the kind of router. Set at creation. `read-only`
        pub kind: RouterRouteKind,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub target: RouteTarget,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        ///The VPC Router to which the route belongs.
        pub vpc_router_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&RouterRoute> for RouterRoute {
        fn from(value: &RouterRoute) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a [`RouterRoute`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a [`RouterRoute`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "destination",
    ///    "name",
    ///    "target"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "destination": {
    ///      "$ref": "#/components/schemas/RouteDestination"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "target": {
    ///      "$ref": "#/components/schemas/RouteTarget"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouterRouteCreateParams {
        pub description: ::std::string::String,
        pub destination: RouteDestination,
        pub name: Name,
        pub target: RouteTarget,
    }

    impl ::std::convert::From<&RouterRouteCreateParams> for RouterRouteCreateParams {
        fn from(value: &RouterRouteCreateParams) -> Self {
            value.clone()
        }
    }

    ///The classification of a [`RouterRoute`] as defined by the system. The
    /// kind determines certain attributes such as if the route is modifiable
    /// and describes how or where the route was created.
    ///
    ///See [RFD-21](https://rfd.shared.oxide.computer/rfd/0021#concept-router) for more context
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The classification of a [`RouterRoute`] as defined by the system. The kind determines certain attributes such as if the route is modifiable and describes how or where the route was created.\n\nSee [RFD-21](https://rfd.shared.oxide.computer/rfd/0021#concept-router) for more context",
    ///  "oneOf": [
    ///    {
    ///      "description": "Determines the default destination of traffic, such
    /// as whether it goes to the internet or not.\n\n`Destination: An Internet
    /// Gateway` `Modifiable: true`",
    ///      "type": "string",
    ///      "enum": [
    ///        "default"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Automatically added for each VPC Subnet in the
    /// VPC\n\n`Destination: A VPC Subnet` `Modifiable: false`",
    ///      "type": "string",
    ///      "enum": [
    ///        "vpc_subnet"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Automatically added when VPC peering is
    /// established\n\n`Destination: A different VPC` `Modifiable: false`",
    ///      "type": "string",
    ///      "enum": [
    ///        "vpc_peering"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Created by a user See
    /// [`RouteTarget`]\n\n`Destination: User defined` `Modifiable: true`",
    ///      "type": "string",
    ///      "enum": [
    ///        "custom"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RouterRouteKind {
        ///Determines the default destination of traffic, such as whether it
        /// goes to the internet or not.
        ///
        ///`Destination: An Internet Gateway` `Modifiable: true`
        #[serde(rename = "default")]
        Default,
        ///Automatically added for each VPC Subnet in the VPC
        ///
        ///`Destination: A VPC Subnet` `Modifiable: false`
        #[serde(rename = "vpc_subnet")]
        VpcSubnet,
        ///Automatically added when VPC peering is established
        ///
        ///`Destination: A different VPC` `Modifiable: false`
        #[serde(rename = "vpc_peering")]
        VpcPeering,
        ///Created by a user See [`RouteTarget`]
        ///
        ///`Destination: User defined` `Modifiable: true`
        #[serde(rename = "custom")]
        Custom,
    }

    impl ::std::convert::From<&Self> for RouterRouteKind {
        fn from(value: &RouterRouteKind) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RouterRouteKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Default => write!(f, "default"),
                Self::VpcSubnet => write!(f, "vpc_subnet"),
                Self::VpcPeering => write!(f, "vpc_peering"),
                Self::Custom => write!(f, "custom"),
            }
        }
    }

    impl ::std::str::FromStr for RouterRouteKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "default" => Ok(Self::Default),
                "vpc_subnet" => Ok(Self::VpcSubnet),
                "vpc_peering" => Ok(Self::VpcPeering),
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RouterRouteKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RouterRouteKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RouterRouteKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RouterRoute"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouterRouteResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<RouterRoute>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RouterRouteResultsPage> for RouterRouteResultsPage {
        fn from(value: &RouterRouteResultsPage) -> Self {
            value.clone()
        }
    }

    ///Updateable properties of a [`RouterRoute`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a [`RouterRoute`]",
    ///  "type": "object",
    ///  "required": [
    ///    "destination",
    ///    "target"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "destination": {
    ///      "$ref": "#/components/schemas/RouteDestination"
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "target": {
    ///      "$ref": "#/components/schemas/RouteTarget"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RouterRouteUpdateParams {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        pub destination: RouteDestination,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
        pub target: RouteTarget,
    }

    impl ::std::convert::From<&RouterRouteUpdateParams> for RouterRouteUpdateParams {
        fn from(value: &RouterRouteUpdateParams) -> Self {
            value.clone()
        }
    }

    ///`Saga`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "state"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/SagaState"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Saga {
        pub id: ::uuid::Uuid,
        pub state: SagaState,
    }

    impl ::std::convert::From<&Saga> for Saga {
        fn from(value: &Saga) -> Self {
            value.clone()
        }
    }

    ///`SagaErrorInfo`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error",
    ///        "source_error"
    ///      ],
    ///      "properties": {
    ///        "error": {
    ///          "type": "string",
    ///          "enum": [
    ///            "action_failed"
    ///          ]
    ///        },
    ///        "source_error": {}
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error",
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "error": {
    ///          "type": "string",
    ///          "enum": [
    ///            "deserialize_failed"
    ///          ]
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error"
    ///      ],
    ///      "properties": {
    ///        "error": {
    ///          "type": "string",
    ///          "enum": [
    ///            "injected_error"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error",
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "error": {
    ///          "type": "string",
    ///          "enum": [
    ///            "serialize_failed"
    ///          ]
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error",
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "error": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subsaga_create_failed"
    ///          ]
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "error")]
    pub enum SagaErrorInfo {
        #[serde(rename = "action_failed")]
        ActionFailed { source_error: ::serde_json::Value },
        #[serde(rename = "deserialize_failed")]
        DeserializeFailed { message: ::std::string::String },
        #[serde(rename = "injected_error")]
        InjectedError,
        #[serde(rename = "serialize_failed")]
        SerializeFailed { message: ::std::string::String },
        #[serde(rename = "subsaga_create_failed")]
        SubsagaCreateFailed { message: ::std::string::String },
    }

    impl ::std::convert::From<&Self> for SagaErrorInfo {
        fn from(value: &SagaErrorInfo) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Saga"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SagaResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Saga>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SagaResultsPage> for SagaResultsPage {
        fn from(value: &SagaResultsPage) -> Self {
            value.clone()
        }
    }

    ///`SagaState`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "running"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "succeeded"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "error_info",
    ///        "error_node_name",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "error_info": {
    ///          "$ref": "#/components/schemas/SagaErrorInfo"
    ///        },
    ///        "error_node_name": {
    ///          "$ref": "#/components/schemas/NodeName"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "failed"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "state")]
    pub enum SagaState {
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "succeeded")]
        Succeeded,
        #[serde(rename = "failed")]
        Failed {
            error_info: SagaErrorInfo,
            error_node_name: NodeName,
        },
    }

    impl ::std::convert::From<&Self> for SagaState {
        fn from(value: &SagaState) -> Self {
            value.clone()
        }
    }

    ///Identity-related metadata that's included in nearly all public API
    /// objects
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in nearly all
    /// public API objects",
    ///  "type": "object",
    ///  "required": [
    ///    "acs_url",
    ///    "description",
    ///    "id",
    ///    "idp_entity_id",
    ///    "name",
    ///    "slo_url",
    ///    "sp_client_id",
    ///    "technical_contact_email",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "acs_url": {
    ///      "description": "service provider endpoint where the response will
    /// be sent",
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "idp_entity_id": {
    ///      "description": "idp's entity id",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "public_cert": {
    ///      "description": "optional request signing public certificate (base64
    /// encoded der file)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "slo_url": {
    ///      "description": "service provider endpoint where the idp should send
    /// log out requests",
    ///      "type": "string"
    ///    },
    ///    "sp_client_id": {
    ///      "description": "sp's client id",
    ///      "type": "string"
    ///    },
    ///    "technical_contact_email": {
    ///      "description": "customer's technical contact for saml
    /// configuration",
    ///      "type": "string"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SamlIdentityProvider {
        ///service provider endpoint where the response will be sent
        pub acs_url: ::std::string::String,
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///idp's entity id
        pub idp_entity_id: ::std::string::String,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///optional request signing public certificate (base64 encoded der
        /// file)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub public_cert: ::std::option::Option<::std::string::String>,
        ///service provider endpoint where the idp should send log out requests
        pub slo_url: ::std::string::String,
        ///sp's client id
        pub sp_client_id: ::std::string::String,
        ///customer's technical contact for saml configuration
        pub technical_contact_email: ::std::string::String,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&SamlIdentityProvider> for SamlIdentityProvider {
        fn from(value: &SamlIdentityProvider) -> Self {
            value.clone()
        }
    }

    ///Create-time identity-related parameters
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time identity-related parameters",
    ///  "type": "object",
    ///  "required": [
    ///    "acs_url",
    ///    "description",
    ///    "idp_entity_id",
    ///    "idp_metadata_source",
    ///    "name",
    ///    "slo_url",
    ///    "sp_client_id",
    ///    "technical_contact_email"
    ///  ],
    ///  "properties": {
    ///    "acs_url": {
    ///      "description": "service provider endpoint where the response will
    /// be sent",
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "group_attribute_name": {
    ///      "description": "If set, SAML attributes with this name will be
    /// considered to denote a user's group membership, where the attribute
    /// value(s) should be a comma-separated list of group names.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "idp_entity_id": {
    ///      "description": "idp's entity id",
    ///      "type": "string"
    ///    },
    ///    "idp_metadata_source": {
    ///      "description": "the source of an identity provider metadata
    /// descriptor",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IdpMetadataSource"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "signing_keypair": {
    ///      "description": "optional request signing key pair",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/DerEncodedKeyPair"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "slo_url": {
    ///      "description": "service provider endpoint where the idp should send
    /// log out requests",
    ///      "type": "string"
    ///    },
    ///    "sp_client_id": {
    ///      "description": "sp's client id",
    ///      "type": "string"
    ///    },
    ///    "technical_contact_email": {
    ///      "description": "customer's technical contact for saml
    /// configuration",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SamlIdentityProviderCreate {
        ///service provider endpoint where the response will be sent
        pub acs_url: ::std::string::String,
        pub description: ::std::string::String,
        ///If set, SAML attributes with this name will be considered to denote
        /// a user's group membership, where the attribute value(s) should be a
        /// comma-separated list of group names.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group_attribute_name: ::std::option::Option<::std::string::String>,
        ///idp's entity id
        pub idp_entity_id: ::std::string::String,
        ///the source of an identity provider metadata descriptor
        pub idp_metadata_source: IdpMetadataSource,
        pub name: Name,
        ///optional request signing key pair
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub signing_keypair: ::std::option::Option<DerEncodedKeyPair>,
        ///service provider endpoint where the idp should send log out requests
        pub slo_url: ::std::string::String,
        ///sp's client id
        pub sp_client_id: ::std::string::String,
        ///customer's technical contact for saml configuration
        pub technical_contact_email: ::std::string::String,
    }

    impl ::std::convert::From<&SamlIdentityProviderCreate> for SamlIdentityProviderCreate {
        fn from(value: &SamlIdentityProviderCreate) -> Self {
            value.clone()
        }
    }

    ///`SemverVersion`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^\\d+\\.\\d+\\.\\d+([\\-\\+].+)?$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SemverVersion(::std::string::String);
    impl ::std::ops::Deref for SemverVersion {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<SemverVersion> for ::std::string::String {
        fn from(value: SemverVersion) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SemverVersion> for SemverVersion {
        fn from(value: &SemverVersion) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SemverVersion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d+\\.\\d+\\.\\d+([\\-\\+].+)?$")
                        .expect("Invalid regex pattern in schema")
                });
            if (&*PATTERN).find(value).is_none() {
                return Err("doesn't match pattern \"^\\d+\\.\\d+\\.\\d+([\\-\\+].+)?$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SemverVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SemverVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SemverVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SemverVersion {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The service intended to use this certificate.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The service intended to use this certificate.",
    ///  "oneOf": [
    ///    {
    ///      "description": "This certificate is intended for access to the
    /// external API.",
    ///      "type": "string",
    ///      "enum": [
    ///        "external_api"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ServiceUsingCertificate {
        ///This certificate is intended for access to the external API.
        #[serde(rename = "external_api")]
        ExternalApi,
    }

    impl ::std::convert::From<&Self> for ServiceUsingCertificate {
        fn from(value: &ServiceUsingCertificate) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ServiceUsingCertificate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ExternalApi => write!(f, "external_api"),
            }
        }
    }

    impl ::std::str::FromStr for ServiceUsingCertificate {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "external_api" => Ok(Self::ExternalApi),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ServiceUsingCertificate {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ServiceUsingCertificate {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ServiceUsingCertificate {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a ['Silo']
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a ['Silo']",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "discoverable",
    ///    "id",
    ///    "identity_mode",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "discoverable": {
    ///      "description": "A silo where discoverable is false can be retrieved only by its id - it will not be part of the \"list all silos\" output.",
    ///      "type": "boolean"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_mode": {
    ///      "description": "How users and groups are managed in this Silo",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SiloIdentityMode"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Silo {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///A silo where discoverable is false can be retrieved only by its id -
        /// it will not be part of the "list all silos" output.
        pub discoverable: bool,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///How users and groups are managed in this Silo
        pub identity_mode: SiloIdentityMode,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Silo> for Silo {
        fn from(value: &Silo) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a [`Silo`](crate::external_api::views::Silo)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Silo`](crate::external_api::views::Silo)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "discoverable",
    ///    "identity_mode",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "admin_group_name": {
    ///      "description": "If set, this group will be created during Silo
    /// creation and granted the \"Silo Admin\" role. Identity providers can
    /// assert that users belong to this group and those users can log in and
    /// further initialize the Silo.\n\nNote that if configuring a SAML based
    /// identity provider, group_attribute_name must be set for users to be
    /// considered part of a group. See [`SamlIdentityProviderCreate`] for more
    /// information.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "discoverable": {
    ///      "type": "boolean"
    ///    },
    ///    "identity_mode": {
    ///      "$ref": "#/components/schemas/SiloIdentityMode"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SiloCreate {
        ///If set, this group will be created during Silo creation and granted
        /// the "Silo Admin" role. Identity providers can assert that users
        /// belong to this group and those users can log in and further
        /// initialize the Silo.
        ///
        ///Note that if configuring a SAML based identity provider,
        /// group_attribute_name must be set for users to be considered part of
        /// a group. See [`SamlIdentityProviderCreate`] for more information.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub admin_group_name: ::std::option::Option<::std::string::String>,
        pub description: ::std::string::String,
        pub discoverable: bool,
        pub identity_mode: SiloIdentityMode,
        pub name: Name,
    }

    impl ::std::convert::From<&SiloCreate> for SiloCreate {
        fn from(value: &SiloCreate) -> Self {
            value.clone()
        }
    }

    ///Describes how identities are managed and users are authenticated in this
    /// Silo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes how identities are managed and users are
    /// authenticated in this Silo",
    ///  "oneOf": [
    ///    {
    ///      "description": "Users are authenticated with SAML using an external
    /// authentication provider.  The system updates information about users and
    /// groups only during successful authentication (i.e,. \"JIT provisioning\"
    /// of users and groups).",
    ///      "type": "string",
    ///      "enum": [
    ///        "saml_jit"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The system is the source of truth about users.
    /// There is no linkage to an external authentication provider or identity
    /// provider.",
    ///      "type": "string",
    ///      "enum": [
    ///        "local_only"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SiloIdentityMode {
        ///Users are authenticated with SAML using an external authentication
        /// provider.  The system updates information about users and groups
        /// only during successful authentication (i.e,. "JIT provisioning" of
        /// users and groups).
        #[serde(rename = "saml_jit")]
        SamlJit,
        ///The system is the source of truth about users.  There is no linkage
        /// to an external authentication provider or identity provider.
        #[serde(rename = "local_only")]
        LocalOnly,
    }

    impl ::std::convert::From<&Self> for SiloIdentityMode {
        fn from(value: &SiloIdentityMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SiloIdentityMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SamlJit => write!(f, "saml_jit"),
                Self::LocalOnly => write!(f, "local_only"),
            }
        }
    }

    impl ::std::str::FromStr for SiloIdentityMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "saml_jit" => Ok(Self::SamlJit),
                "local_only" => Ok(Self::LocalOnly),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SiloIdentityMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SiloIdentityMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SiloIdentityMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Silo"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SiloResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Silo>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SiloResultsPage> for SiloResultsPage {
        fn from(value: &SiloResultsPage) -> Self {
            value.clone()
        }
    }

    ///`SiloRole`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SiloRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl ::std::convert::From<&Self> for SiloRole {
        fn from(value: &SiloRole) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SiloRole {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Admin => write!(f, "admin"),
                Self::Collaborator => write!(f, "collaborator"),
                Self::Viewer => write!(f, "viewer"),
            }
        }
    }

    impl ::std::str::FromStr for SiloRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SiloRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SiloRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SiloRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`Policy`], which describes how this resource may be
    /// accessed
    ///
    ///Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Policy`], which describes how this
    /// resource may be accessed\n\nNote that the Policy only describes access
    /// granted explicitly for this resource.  The policies of parent resources
    /// can also cause a user to have access to this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SiloRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SiloRolePolicy {
        ///Roles directly assigned on this resource
        pub role_assignments: ::std::vec::Vec<SiloRoleRoleAssignment>,
    }

    impl ::std::convert::From<&SiloRolePolicy> for SiloRolePolicy {
        fn from(value: &SiloRolePolicy) -> Self {
            value.clone()
        }
    }

    ///Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    ///The resource is not part of this structure.  Rather, [`RoleAssignment`]s
    /// are put into a [`Policy`] and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, [`RoleAssignment`]s are
    /// put into a [`Policy`] and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/SiloRole"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SiloRoleRoleAssignment {
        pub identity_id: ::uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: SiloRole,
    }

    impl ::std::convert::From<&SiloRoleRoleAssignment> for SiloRoleRoleAssignment {
        fn from(value: &SiloRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    ///Client view of a [`Sled`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Sled`]",
    ///  "type": "object",
    ///  "required": [
    ///    "baseboard",
    ///    "id",
    ///    "service_address",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "baseboard": {
    ///      "$ref": "#/components/schemas/Baseboard"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "service_address": {
    ///      "type": "string"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Sled {
        pub baseboard: Baseboard,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        pub service_address: ::std::string::String,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Sled> for Sled {
        fn from(value: &Sled) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Sled"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SledResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Sled>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SledResultsPage> for SledResultsPage {
        fn from(value: &SledResultsPage) -> Self {
            value.clone()
        }
    }

    ///Client view of a Snapshot
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a Snapshot",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "disk_id",
    ///    "id",
    ///    "name",
    ///    "project_id",
    ///    "size",
    ///    "state",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "disk_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "size": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/SnapshotState"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Snapshot {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        pub disk_id: ::uuid::Uuid,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub project_id: ::uuid::Uuid,
        pub size: ByteCount,
        pub state: SnapshotState,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Snapshot> for Snapshot {
        fn from(value: &Snapshot) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a
    /// [`Snapshot`](crate::external_api::views::Snapshot)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Snapshot`](crate::external_api::views::Snapshot)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "disk",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "disk": {
    ///      "description": "The name of the disk to be snapshotted",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SnapshotCreate {
        pub description: ::std::string::String,
        ///The name of the disk to be snapshotted
        pub disk: Name,
        pub name: Name,
    }

    impl ::std::convert::From<&SnapshotCreate> for SnapshotCreate {
        fn from(value: &SnapshotCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snapshot"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SnapshotResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Snapshot>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SnapshotResultsPage> for SnapshotResultsPage {
        fn from(value: &SnapshotResultsPage) -> Self {
            value.clone()
        }
    }

    ///`SnapshotState`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "creating",
    ///    "ready",
    ///    "faulted",
    ///    "destroyed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SnapshotState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "ready")]
        Ready,
        #[serde(rename = "faulted")]
        Faulted,
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl ::std::convert::From<&Self> for SnapshotState {
        fn from(value: &SnapshotState) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SnapshotState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Creating => write!(f, "creating"),
                Self::Ready => write!(f, "ready"),
                Self::Faulted => write!(f, "faulted"),
                Self::Destroyed => write!(f, "destroyed"),
            }
        }
    }

    impl ::std::str::FromStr for SnapshotState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "creating" => Ok(Self::Creating),
                "ready" => Ok(Self::Ready),
                "faulted" => Ok(Self::Faulted),
                "destroyed" => Ok(Self::Destroyed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SnapshotState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SnapshotState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SnapshotState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SpoofLoginBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "username": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpoofLoginBody {
        pub username: ::std::string::String,
    }

    impl ::std::convert::From<&SpoofLoginBody> for SpoofLoginBody {
        fn from(value: &SpoofLoginBody) -> Self {
            value.clone()
        }
    }

    ///Client view of a [`SshKey`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`SshKey`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "public_key",
    ///    "silo_user_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "public_key": {
    ///      "description": "SSH public key, e.g., `\"ssh-ed25519
    /// AAAAC3NzaC...\"`",
    ///      "type": "string"
    ///    },
    ///    "silo_user_id": {
    ///      "description": "The user to whom this key belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SshKey {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///SSH public key, e.g., `"ssh-ed25519 AAAAC3NzaC..."`
        pub public_key: ::std::string::String,
        ///The user to whom this key belongs
        pub silo_user_id: ::uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&SshKey> for SshKey {
        fn from(value: &SshKey) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for an
    /// [`SshKey`](crate::external_api::views::SshKey)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for an
    /// [`SshKey`](crate::external_api::views::SshKey)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name",
    ///    "public_key"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "public_key": {
    ///      "description": "SSH public key, e.g., `\"ssh-ed25519
    /// AAAAC3NzaC...\"`",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SshKeyCreate {
        pub description: ::std::string::String,
        pub name: Name,
        ///SSH public key, e.g., `"ssh-ed25519 AAAAC3NzaC..."`
        pub public_key: ::std::string::String,
    }

    impl ::std::convert::From<&SshKeyCreate> for SshKeyCreate {
        fn from(value: &SshKeyCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SshKey"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SshKeyResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<SshKey>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SshKeyResultsPage> for SshKeyResultsPage {
        fn from(value: &SshKeyResultsPage) -> Self {
            value.clone()
        }
    }

    ///`SystemMetricName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "virtual_disk_space_provisioned",
    ///    "cpus_provisioned",
    ///    "ram_provisioned"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SystemMetricName {
        #[serde(rename = "virtual_disk_space_provisioned")]
        VirtualDiskSpaceProvisioned,
        #[serde(rename = "cpus_provisioned")]
        CpusProvisioned,
        #[serde(rename = "ram_provisioned")]
        RamProvisioned,
    }

    impl ::std::convert::From<&Self> for SystemMetricName {
        fn from(value: &SystemMetricName) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SystemMetricName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::VirtualDiskSpaceProvisioned => write!(f, "virtual_disk_space_provisioned"),
                Self::CpusProvisioned => write!(f, "cpus_provisioned"),
                Self::RamProvisioned => write!(f, "ram_provisioned"),
            }
        }
    }

    impl ::std::str::FromStr for SystemMetricName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "virtual_disk_space_provisioned" => Ok(Self::VirtualDiskSpaceProvisioned),
                "cpus_provisioned" => Ok(Self::CpusProvisioned),
                "ram_provisioned" => Ok(Self::RamProvisioned),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SystemMetricName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SystemMetricName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SystemMetricName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Identity-related metadata that's included in "asset" public API objects
    /// (which generally have no name or description)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in \"asset\"
    /// public API objects (which generally have no name or description)",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SystemUpdate {
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl ::std::convert::From<&SystemUpdate> for SystemUpdate {
        fn from(value: &SystemUpdate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SystemUpdate"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SystemUpdateResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<SystemUpdate>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SystemUpdateResultsPage> for SystemUpdateResultsPage {
        fn from(value: &SystemUpdateResultsPage) -> Self {
            value.clone()
        }
    }

    ///`SystemUpdateStart`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SystemUpdateStart {
        pub version: SemverVersion,
    }

    impl ::std::convert::From<&SystemUpdateStart> for SystemUpdateStart {
        fn from(value: &SystemUpdateStart) -> Self {
            value.clone()
        }
    }

    ///`SystemVersion`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "status",
    ///    "version_range"
    ///  ],
    ///  "properties": {
    ///    "status": {
    ///      "$ref": "#/components/schemas/UpdateStatus"
    ///    },
    ///    "version_range": {
    ///      "$ref": "#/components/schemas/VersionRange"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SystemVersion {
        pub status: UpdateStatus,
        pub version_range: VersionRange,
    }

    impl ::std::convert::From<&SystemVersion> for SystemVersion {
        fn from(value: &SystemVersion) -> Self {
            value.clone()
        }
    }

    ///Names are constructed by concatenating the target and metric names with
    /// ':'. Target and metric names must be lowercase alphanumeric characters
    /// with '_' separating words.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "The name of a timeseries",
    ///  "description": "Names are constructed by concatenating the target and
    /// metric names with ':'. Target and metric names must be lowercase
    /// alphanumeric characters with '_' separating words.",
    ///  "type": "string",
    ///  "pattern":
    /// "(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*)"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct TimeseriesName(::std::string::String);
    impl ::std::ops::Deref for TimeseriesName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<TimeseriesName> for ::std::string::String {
        fn from(value: TimeseriesName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TimeseriesName> for TimeseriesName {
        fn from(value: &TimeseriesName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TimeseriesName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*)",
                    )
                    .expect("Invalid regex pattern in schema")
                });
            if (&*PATTERN).find(value).is_none() {
                return Err("doesn't match pattern \
                            \"(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*\
                            )(_([a-z0-9]+))*)\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TimeseriesName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TimeseriesName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TimeseriesName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TimeseriesName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The schema for a timeseries.
    ///
    ///This includes the name of the timeseries, as well as the datum type of
    /// its metric and the schema for each field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The schema for a timeseries.\n\nThis includes the name
    /// of the timeseries, as well as the datum type of its metric and the
    /// schema for each field.",
    ///  "type": "object",
    ///  "required": [
    ///    "created",
    ///    "datum_type",
    ///    "field_schema",
    ///    "timeseries_name"
    ///  ],
    ///  "properties": {
    ///    "created": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "datum_type": {
    ///      "$ref": "#/components/schemas/DatumType"
    ///    },
    ///    "field_schema": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FieldSchema"
    ///      }
    ///    },
    ///    "timeseries_name": {
    ///      "$ref": "#/components/schemas/TimeseriesName"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TimeseriesSchema {
        pub created: ::chrono::DateTime<::chrono::offset::Utc>,
        pub datum_type: DatumType,
        pub field_schema: ::std::vec::Vec<FieldSchema>,
        pub timeseries_name: TimeseriesName,
    }

    impl ::std::convert::From<&TimeseriesSchema> for TimeseriesSchema {
        fn from(value: &TimeseriesSchema) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TimeseriesSchema"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TimeseriesSchemaResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<TimeseriesSchema>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TimeseriesSchemaResultsPage> for TimeseriesSchemaResultsPage {
        fn from(value: &TimeseriesSchemaResultsPage) -> Self {
            value.clone()
        }
    }

    ///Identity-related metadata that's included in "asset" public API objects
    /// (which generally have no name or description)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in \"asset\"
    /// public API objects (which generally have no name or description)",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "status",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/UpdateStatus"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateDeployment {
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        pub status: UpdateStatus,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl ::std::convert::From<&UpdateDeployment> for UpdateDeployment {
        fn from(value: &UpdateDeployment) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UpdateDeployment"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateDeploymentResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<UpdateDeployment>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UpdateDeploymentResultsPage> for UpdateDeploymentResultsPage {
        fn from(value: &UpdateDeploymentResultsPage) -> Self {
            value.clone()
        }
    }

    ///`UpdateStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "status"
    ///      ],
    ///      "properties": {
    ///        "status": {
    ///          "type": "string",
    ///          "enum": [
    ///            "updating"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "status"
    ///      ],
    ///      "properties": {
    ///        "status": {
    ///          "type": "string",
    ///          "enum": [
    ///            "steady"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(tag = "status")]
    pub enum UpdateStatus {
        #[serde(rename = "updating")]
        Updating,
        #[serde(rename = "steady")]
        Steady,
    }

    impl ::std::convert::From<&Self> for UpdateStatus {
        fn from(value: &UpdateStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UpdateStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Updating => write!(f, "updating"),
                Self::Steady => write!(f, "steady"),
            }
        }
    }

    impl ::std::str::FromStr for UpdateStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "updating" => Ok(Self::Updating),
                "steady" => Ok(Self::Steady),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Identity-related metadata that's included in "asset" public API objects
    /// (which generally have no name or description)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identity-related metadata that's included in \"asset\"
    /// public API objects (which generally have no name or description)",
    ///  "type": "object",
    ///  "required": [
    ///    "component_type",
    ///    "device_id",
    ///    "id",
    ///    "status",
    ///    "system_version",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "component_type": {
    ///      "$ref": "#/components/schemas/UpdateableComponentType"
    ///    },
    ///    "device_id": {
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/UpdateStatus"
    ///    },
    ///    "system_version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "version": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateableComponent {
        pub component_type: UpdateableComponentType,
        pub device_id: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        pub status: UpdateStatus,
        pub system_version: SemverVersion,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl ::std::convert::From<&UpdateableComponent> for UpdateableComponent {
        fn from(value: &UpdateableComponent) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UpdateableComponent"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateableComponentResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<UpdateableComponent>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UpdateableComponentResultsPage> for UpdateableComponentResultsPage {
        fn from(value: &UpdateableComponentResultsPage) -> Self {
            value.clone()
        }
    }

    ///`UpdateableComponentType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bootloader_for_rot",
    ///    "bootloader_for_sp",
    ///    "bootloader_for_host_proc",
    ///    "hubris_for_psc_rot",
    ///    "hubris_for_psc_sp",
    ///    "hubris_for_sidecar_rot",
    ///    "hubris_for_sidecar_sp",
    ///    "hubris_for_gimlet_rot",
    ///    "hubris_for_gimlet_sp",
    ///    "helios_host_phase1",
    ///    "helios_host_phase2",
    ///    "host_omicron"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UpdateableComponentType {
        #[serde(rename = "bootloader_for_rot")]
        BootloaderForRot,
        #[serde(rename = "bootloader_for_sp")]
        BootloaderForSp,
        #[serde(rename = "bootloader_for_host_proc")]
        BootloaderForHostProc,
        #[serde(rename = "hubris_for_psc_rot")]
        HubrisForPscRot,
        #[serde(rename = "hubris_for_psc_sp")]
        HubrisForPscSp,
        #[serde(rename = "hubris_for_sidecar_rot")]
        HubrisForSidecarRot,
        #[serde(rename = "hubris_for_sidecar_sp")]
        HubrisForSidecarSp,
        #[serde(rename = "hubris_for_gimlet_rot")]
        HubrisForGimletRot,
        #[serde(rename = "hubris_for_gimlet_sp")]
        HubrisForGimletSp,
        #[serde(rename = "helios_host_phase1")]
        HeliosHostPhase1,
        #[serde(rename = "helios_host_phase2")]
        HeliosHostPhase2,
        #[serde(rename = "host_omicron")]
        HostOmicron,
    }

    impl ::std::convert::From<&Self> for UpdateableComponentType {
        fn from(value: &UpdateableComponentType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UpdateableComponentType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BootloaderForRot => write!(f, "bootloader_for_rot"),
                Self::BootloaderForSp => write!(f, "bootloader_for_sp"),
                Self::BootloaderForHostProc => write!(f, "bootloader_for_host_proc"),
                Self::HubrisForPscRot => write!(f, "hubris_for_psc_rot"),
                Self::HubrisForPscSp => write!(f, "hubris_for_psc_sp"),
                Self::HubrisForSidecarRot => write!(f, "hubris_for_sidecar_rot"),
                Self::HubrisForSidecarSp => write!(f, "hubris_for_sidecar_sp"),
                Self::HubrisForGimletRot => write!(f, "hubris_for_gimlet_rot"),
                Self::HubrisForGimletSp => write!(f, "hubris_for_gimlet_sp"),
                Self::HeliosHostPhase1 => write!(f, "helios_host_phase1"),
                Self::HeliosHostPhase2 => write!(f, "helios_host_phase2"),
                Self::HostOmicron => write!(f, "host_omicron"),
            }
        }
    }

    impl ::std::str::FromStr for UpdateableComponentType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bootloader_for_rot" => Ok(Self::BootloaderForRot),
                "bootloader_for_sp" => Ok(Self::BootloaderForSp),
                "bootloader_for_host_proc" => Ok(Self::BootloaderForHostProc),
                "hubris_for_psc_rot" => Ok(Self::HubrisForPscRot),
                "hubris_for_psc_sp" => Ok(Self::HubrisForPscSp),
                "hubris_for_sidecar_rot" => Ok(Self::HubrisForSidecarRot),
                "hubris_for_sidecar_sp" => Ok(Self::HubrisForSidecarSp),
                "hubris_for_gimlet_rot" => Ok(Self::HubrisForGimletRot),
                "hubris_for_gimlet_sp" => Ok(Self::HubrisForGimletSp),
                "helios_host_phase1" => Ok(Self::HeliosHostPhase1),
                "helios_host_phase2" => Ok(Self::HeliosHostPhase2),
                "host_omicron" => Ok(Self::HostOmicron),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateableComponentType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateableComponentType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateableComponentType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Client view of a [`User`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`User`]",
    ///  "type": "object",
    ///  "required": [
    ///    "display_name",
    ///    "id",
    ///    "silo_id"
    ///  ],
    ///  "properties": {
    ///    "display_name": {
    ///      "description": "Human-readable name that can identify the user",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "silo_id": {
    ///      "description": "Uuid of the silo to which this user belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct User {
        ///Human-readable name that can identify the user
        pub display_name: ::std::string::String,
        pub id: ::uuid::Uuid,
        ///Uuid of the silo to which this user belongs
        pub silo_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&User> for User {
        fn from(value: &User) -> Self {
            value.clone()
        }
    }

    ///Client view of a [`UserBuiltin`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`UserBuiltin`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserBuiltin {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&UserBuiltin> for UserBuiltin {
        fn from(value: &UserBuiltin) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UserBuiltin"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserBuiltinResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<UserBuiltin>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UserBuiltinResultsPage> for UserBuiltinResultsPage {
        fn from(value: &UserBuiltinResultsPage) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a [`User`](crate::external_api::views::User)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`User`](crate::external_api::views::User)",
    ///  "type": "object",
    ///  "required": [
    ///    "external_id",
    ///    "password"
    ///  ],
    ///  "properties": {
    ///    "external_id": {
    ///      "description": "username used to log in",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/UserId"
    ///        }
    ///      ]
    ///    },
    ///    "password": {
    ///      "description": "password used to log in",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/UserPassword"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserCreate {
        ///username used to log in
        pub external_id: UserId,
        ///password used to log in
        pub password: UserPassword,
    }

    impl ::std::convert::From<&UserCreate> for UserCreate {
        fn from(value: &UserCreate) -> Self {
            value.clone()
        }
    }

    ///Names must begin with a lower case ASCII letter, be composed exclusively
    /// of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end
    /// with a '-'. Names cannot be a UUID though they may contain a UUID.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "A name unique within the parent collection",
    ///  "description": "Names must begin with a lower case ASCII letter, be
    /// composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and
    /// '-', and may not end with a '-'. Names cannot be a UUID though they may
    /// contain a UUID.",
    ///  "type": "string",
    ///  "maxLength": 63,
    ///  "pattern":
    /// "^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*
    /// [a-zA-Z0-9]$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UserId(::std::string::String);
    impl ::std::ops::Deref for UserId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UserId> for ::std::string::String {
        fn from(value: UserId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UserId> for UserId {
        fn from(value: &UserId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UserId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 63usize {
                return Err("longer than 63 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> = ::std::sync::LazyLock::new(
                || {
                    :: regress :: Regex :: new ("^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]$") . expect ("Invalid regex pattern in schema")
                },
            );
            if (&*PATTERN).find(value).is_none() {
                return Err ("doesn't match pattern \"^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]$\"" . into ()) ;
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UserId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Parameters for setting a user's password
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters for setting a user's password",
    ///  "oneOf": [
    ///    {
    ///      "description": "Sets the user's password to the provided value",
    ///      "type": "object",
    ///      "required": [
    ///        "details",
    ///        "user_password_value"
    ///      ],
    ///      "properties": {
    ///        "details": {
    ///          "$ref": "#/components/schemas/Password"
    ///        },
    ///        "user_password_value": {
    ///          "type": "string",
    ///          "enum": [
    ///            "password"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Invalidates any current password (disabling
    /// password authentication)",
    ///      "type": "object",
    ///      "required": [
    ///        "user_password_value"
    ///      ],
    ///      "properties": {
    ///        "user_password_value": {
    ///          "type": "string",
    ///          "enum": [
    ///            "invalid_password"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "user_password_value", content = "details")]
    pub enum UserPassword {
        ///Sets the user's password to the provided value
        #[serde(rename = "password")]
        Password(Password),
        #[serde(rename = "invalid_password")]
        InvalidPassword,
    }

    impl ::std::convert::From<&Self> for UserPassword {
        fn from(value: &UserPassword) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<Password> for UserPassword {
        fn from(value: Password) -> Self {
            Self::Password(value)
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/User"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<User>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UserResultsPage> for UserResultsPage {
        fn from(value: &UserResultsPage) -> Self {
            value.clone()
        }
    }

    ///Credentials for local user login
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Credentials for local user login",
    ///  "type": "object",
    ///  "required": [
    ///    "password",
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "password": {
    ///      "$ref": "#/components/schemas/Password"
    ///    },
    ///    "username": {
    ///      "$ref": "#/components/schemas/UserId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UsernamePasswordCredentials {
        pub password: Password,
        pub username: UserId,
    }

    impl ::std::convert::From<&UsernamePasswordCredentials> for UsernamePasswordCredentials {
        fn from(value: &UsernamePasswordCredentials) -> Self {
            value.clone()
        }
    }

    ///`VersionRange`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "high",
    ///    "low"
    ///  ],
    ///  "properties": {
    ///    "high": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    },
    ///    "low": {
    ///      "$ref": "#/components/schemas/SemverVersion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VersionRange {
        pub high: SemverVersion,
        pub low: SemverVersion,
    }

    impl ::std::convert::From<&VersionRange> for VersionRange {
        fn from(value: &VersionRange) -> Self {
            value.clone()
        }
    }

    ///Client view of a [`Vpc`]
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Client view of a [`Vpc`]",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "dns_name",
    ///    "id",
    ///    "ipv6_prefix",
    ///    "name",
    ///    "project_id",
    ///    "system_router_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "dns_name": {
    ///      "description": "The name used for the VPC in DNS.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ipv6_prefix": {
    ///      "description": "The unique local IPv6 address range for subnets in
    /// this VPC",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "description": "id for the project containing this VPC",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "system_router_id": {
    ///      "description": "id for the system router where subnet default
    /// routes are registered",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Vpc {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///The name used for the VPC in DNS.
        pub dns_name: Name,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///The unique local IPv6 address range for subnets in this VPC
        pub ipv6_prefix: Ipv6Net,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///id for the project containing this VPC
        pub project_id: ::uuid::Uuid,
        ///id for the system router where subnet default routes are registered
        pub system_router_id: ::uuid::Uuid,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Vpc> for Vpc {
        fn from(value: &Vpc) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a [`Vpc`](crate::external_api::views::Vpc)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`Vpc`](crate::external_api::views::Vpc)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "dns_name",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "dns_name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "ipv6_prefix": {
    ///      "description": "The IPv6 prefix for this VPC.\n\nAll IPv6 subnets
    /// created from this VPC must be taken from this range, which sould be a
    /// Unique Local Address in the range `fd00::/48`. The default VPC Subnet
    /// will have the first `/64` range from this prefix.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Ipv6Net"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcCreate {
        pub description: ::std::string::String,
        pub dns_name: Name,
        ///The IPv6 prefix for this VPC.
        ///
        ///All IPv6 subnets created from this VPC must be taken from this
        /// range, which sould be a Unique Local Address in the range
        /// `fd00::/48`. The default VPC Subnet will have the first `/64` range
        /// from this prefix.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ipv6_prefix: ::std::option::Option<Ipv6Net>,
        pub name: Name,
    }

    impl ::std::convert::From<&VpcCreate> for VpcCreate {
        fn from(value: &VpcCreate) -> Self {
            value.clone()
        }
    }

    ///A single rule in a VPC firewall
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single rule in a VPC firewall",
    ///  "type": "object",
    ///  "required": [
    ///    "action",
    ///    "description",
    ///    "direction",
    ///    "filters",
    ///    "id",
    ///    "name",
    ///    "priority",
    ///    "status",
    ///    "targets",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "whether traffic matching the rule should be allowed
    /// or dropped",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleAction"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "direction": {
    ///      "description": "whether this rule is for incoming or outgoing
    /// traffic",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleDirection"
    ///        }
    ///      ]
    ///    },
    ///    "filters": {
    ///      "description": "reductions on the scope of the rule",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleFilter"
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "priority": {
    ///      "description": "the relative priority of this rule",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "status": {
    ///      "description": "whether this rule is in effect",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleStatus"
    ///        }
    ///      ]
    ///    },
    ///    "targets": {
    ///      "description": "list of sets of instances that the rule applies
    /// to",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleTarget"
    ///      }
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "the VPC to which this rule belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcFirewallRule {
        ///whether traffic matching the rule should be allowed or dropped
        pub action: VpcFirewallRuleAction,
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///whether this rule is for incoming or outgoing traffic
        pub direction: VpcFirewallRuleDirection,
        ///reductions on the scope of the rule
        pub filters: VpcFirewallRuleFilter,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///the relative priority of this rule
        pub priority: u16,
        ///whether this rule is in effect
        pub status: VpcFirewallRuleStatus,
        ///list of sets of instances that the rule applies to
        pub targets: ::std::vec::Vec<VpcFirewallRuleTarget>,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        ///the VPC to which this rule belongs
        pub vpc_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&VpcFirewallRule> for VpcFirewallRule {
        fn from(value: &VpcFirewallRule) -> Self {
            value.clone()
        }
    }

    ///`VpcFirewallRuleAction`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "allow",
    ///    "deny"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum VpcFirewallRuleAction {
        #[serde(rename = "allow")]
        Allow,
        #[serde(rename = "deny")]
        Deny,
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleAction {
        fn from(value: &VpcFirewallRuleAction) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for VpcFirewallRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Allow => write!(f, "allow"),
                Self::Deny => write!(f, "deny"),
            }
        }
    }

    impl ::std::str::FromStr for VpcFirewallRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "allow" => Ok(Self::Allow),
                "deny" => Ok(Self::Deny),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for VpcFirewallRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for VpcFirewallRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for VpcFirewallRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`VpcFirewallRuleDirection`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "inbound",
    ///    "outbound"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum VpcFirewallRuleDirection {
        #[serde(rename = "inbound")]
        Inbound,
        #[serde(rename = "outbound")]
        Outbound,
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleDirection {
        fn from(value: &VpcFirewallRuleDirection) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for VpcFirewallRuleDirection {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Inbound => write!(f, "inbound"),
                Self::Outbound => write!(f, "outbound"),
            }
        }
    }

    impl ::std::str::FromStr for VpcFirewallRuleDirection {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "inbound" => Ok(Self::Inbound),
                "outbound" => Ok(Self::Outbound),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for VpcFirewallRuleDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for VpcFirewallRuleDirection {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for VpcFirewallRuleDirection {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Filter for a firewall rule. A given packet must match every field that
    /// is present for the rule to apply to it. A packet matches a field if any
    /// entry in that field matches the packet.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Filter for a firewall rule. A given packet must match
    /// every field that is present for the rule to apply to it. A packet
    /// matches a field if any entry in that field matches the packet.",
    ///  "type": "object",
    ///  "properties": {
    ///    "hosts": {
    ///      "description": "If present, the sources (if incoming) or
    /// destinations (if outgoing) this rule applies to.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleHostFilter"
    ///      }
    ///    },
    ///    "ports": {
    ///      "description": "If present, the destination ports this rule applies
    /// to.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/L4PortRange"
    ///      }
    ///    },
    ///    "protocols": {
    ///      "description": "If present, the networking protocols this rule
    /// applies to.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleProtocol"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcFirewallRuleFilter {
        ///If present, the sources (if incoming) or destinations (if outgoing)
        /// this rule applies to.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hosts: ::std::option::Option<::std::vec::Vec<VpcFirewallRuleHostFilter>>,
        ///If present, the destination ports this rule applies to.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ports: ::std::option::Option<::std::vec::Vec<L4PortRange>>,
        ///If present, the networking protocols this rule applies to.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub protocols: ::std::option::Option<::std::vec::Vec<VpcFirewallRuleProtocol>>,
    }

    impl ::std::convert::From<&VpcFirewallRuleFilter> for VpcFirewallRuleFilter {
        fn from(value: &VpcFirewallRuleFilter) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VpcFirewallRuleFilter {
        fn default() -> Self {
            Self {
                hosts: Default::default(),
                ports: Default::default(),
                protocols: Default::default(),
            }
        }
    }

    ///The `VpcFirewallRuleHostFilter` is used to filter traffic on the basis
    /// of its source or destination host.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The `VpcFirewallRuleHostFilter` is used to filter
    /// traffic on the basis of its source or destination host.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The rule applies to traffic from/to all instances
    /// in the VPC",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to all instances
    /// in the VPC Subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to this specific
    /// instance",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to a specific IP
    /// address",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to a specific IP
    /// subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip_net"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleHostFilter {
        ///The rule applies to traffic from/to all instances in the VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///The rule applies to traffic from/to all instances in the VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        ///The rule applies to traffic from/to this specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        ///The rule applies to traffic from/to a specific IP address
        #[serde(rename = "ip")]
        Ip(::std::net::IpAddr),
        ///The rule applies to traffic from/to a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleHostFilter {
        fn from(value: &VpcFirewallRuleHostFilter) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::net::IpAddr> for VpcFirewallRuleHostFilter {
        fn from(value: ::std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    impl ::std::convert::From<IpNet> for VpcFirewallRuleHostFilter {
        fn from(value: IpNet) -> Self {
            Self::IpNet(value)
        }
    }

    ///The protocols that may be specified in a firewall rule's filter
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The protocols that may be specified in a firewall
    /// rule's filter",
    ///  "type": "string",
    ///  "enum": [
    ///    "TCP",
    ///    "UDP",
    ///    "ICMP"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum VpcFirewallRuleProtocol {
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(rename = "UDP")]
        Udp,
        #[serde(rename = "ICMP")]
        Icmp,
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleProtocol {
        fn from(value: &VpcFirewallRuleProtocol) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for VpcFirewallRuleProtocol {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Tcp => write!(f, "TCP"),
                Self::Udp => write!(f, "UDP"),
                Self::Icmp => write!(f, "ICMP"),
            }
        }
    }

    impl ::std::str::FromStr for VpcFirewallRuleProtocol {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "TCP" => Ok(Self::Tcp),
                "UDP" => Ok(Self::Udp),
                "ICMP" => Ok(Self::Icmp),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for VpcFirewallRuleProtocol {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for VpcFirewallRuleProtocol {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for VpcFirewallRuleProtocol {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`VpcFirewallRuleStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "disabled",
    ///    "enabled"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum VpcFirewallRuleStatus {
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "enabled")]
        Enabled,
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleStatus {
        fn from(value: &VpcFirewallRuleStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for VpcFirewallRuleStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Disabled => write!(f, "disabled"),
                Self::Enabled => write!(f, "enabled"),
            }
        }
    }

    impl ::std::str::FromStr for VpcFirewallRuleStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "disabled" => Ok(Self::Disabled),
                "enabled" => Ok(Self::Enabled),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for VpcFirewallRuleStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for VpcFirewallRuleStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for VpcFirewallRuleStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A `VpcFirewallRuleTarget` is used to specify the set of [`Instance`]s to
    /// which a firewall rule applies.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A `VpcFirewallRuleTarget` is used to specify the set of
    /// [`Instance`]s to which a firewall rule applies.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The rule applies to all instances in the VPC",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to all instances in the VPC
    /// Subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to this specific instance",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to a specific IP address",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to a specific IP subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip_net"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleTarget {
        ///The rule applies to all instances in the VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        ///The rule applies to all instances in the VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        ///The rule applies to this specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        ///The rule applies to a specific IP address
        #[serde(rename = "ip")]
        Ip(::std::net::IpAddr),
        ///The rule applies to a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleTarget {
        fn from(value: &VpcFirewallRuleTarget) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::net::IpAddr> for VpcFirewallRuleTarget {
        fn from(value: ::std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    impl ::std::convert::From<IpNet> for VpcFirewallRuleTarget {
        fn from(value: IpNet) -> Self {
            Self::IpNet(value)
        }
    }

    ///A single rule in a VPC firewall
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single rule in a VPC firewall",
    ///  "type": "object",
    ///  "required": [
    ///    "action",
    ///    "description",
    ///    "direction",
    ///    "filters",
    ///    "name",
    ///    "priority",
    ///    "status",
    ///    "targets"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "whether traffic matching the rule should be allowed
    /// or dropped",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleAction"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "direction": {
    ///      "description": "whether this rule is for incoming or outgoing
    /// traffic",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleDirection"
    ///        }
    ///      ]
    ///    },
    ///    "filters": {
    ///      "description": "reductions on the scope of the rule",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleFilter"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "name of the rule, unique to this VPC",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "priority": {
    ///      "description": "the relative priority of this rule",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "status": {
    ///      "description": "whether this rule is in effect",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleStatus"
    ///        }
    ///      ]
    ///    },
    ///    "targets": {
    ///      "description": "list of sets of instances that the rule applies
    /// to",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleTarget"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcFirewallRuleUpdate {
        ///whether traffic matching the rule should be allowed or dropped
        pub action: VpcFirewallRuleAction,
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///whether this rule is for incoming or outgoing traffic
        pub direction: VpcFirewallRuleDirection,
        ///reductions on the scope of the rule
        pub filters: VpcFirewallRuleFilter,
        ///name of the rule, unique to this VPC
        pub name: Name,
        ///the relative priority of this rule
        pub priority: u16,
        ///whether this rule is in effect
        pub status: VpcFirewallRuleStatus,
        ///list of sets of instances that the rule applies to
        pub targets: ::std::vec::Vec<VpcFirewallRuleTarget>,
    }

    impl ::std::convert::From<&VpcFirewallRuleUpdate> for VpcFirewallRuleUpdate {
        fn from(value: &VpcFirewallRuleUpdate) -> Self {
            value.clone()
        }
    }

    ///Updateable properties of a `Vpc`'s firewall Note that VpcFirewallRules
    /// are implicitly created along with a Vpc, so there is no explicit
    /// creation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a `Vpc`'s firewall Note that
    /// VpcFirewallRules are implicitly created along with a Vpc, so there is no
    /// explicit creation.",
    ///  "type": "object",
    ///  "required": [
    ///    "rules"
    ///  ],
    ///  "properties": {
    ///    "rules": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleUpdate"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcFirewallRuleUpdateParams {
        pub rules: ::std::vec::Vec<VpcFirewallRuleUpdate>,
    }

    impl ::std::convert::From<&VpcFirewallRuleUpdateParams> for VpcFirewallRuleUpdateParams {
        fn from(value: &VpcFirewallRuleUpdateParams) -> Self {
            value.clone()
        }
    }

    ///Collection of a Vpc's firewall rules
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Collection of a Vpc's firewall rules",
    ///  "type": "object",
    ///  "required": [
    ///    "rules"
    ///  ],
    ///  "properties": {
    ///    "rules": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRule"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcFirewallRules {
        pub rules: ::std::vec::Vec<VpcFirewallRule>,
    }

    impl ::std::convert::From<&VpcFirewallRules> for VpcFirewallRules {
        fn from(value: &VpcFirewallRules) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Vpc"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<Vpc>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&VpcResultsPage> for VpcResultsPage {
        fn from(value: &VpcResultsPage) -> Self {
            value.clone()
        }
    }

    ///A VPC router defines a series of rules that indicate where traffic
    /// should be sent depending on its destination.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A VPC router defines a series of rules that indicate
    /// where traffic should be sent depending on its destination.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "kind",
    ///    "name",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "kind": {
    ///      "$ref": "#/components/schemas/VpcRouterKind"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which the router belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcRouter {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        pub kind: VpcRouterKind,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        ///The VPC to which the router belongs.
        pub vpc_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&VpcRouter> for VpcRouter {
        fn from(value: &VpcRouter) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a
    /// [`VpcRouter`](crate::external_api::views::VpcRouter)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`VpcRouter`](crate::external_api::views::VpcRouter)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcRouterCreate {
        pub description: ::std::string::String,
        pub name: Name,
    }

    impl ::std::convert::From<&VpcRouterCreate> for VpcRouterCreate {
        fn from(value: &VpcRouterCreate) -> Self {
            value.clone()
        }
    }

    ///`VpcRouterKind`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "system",
    ///    "custom"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum VpcRouterKind {
        #[serde(rename = "system")]
        System,
        #[serde(rename = "custom")]
        Custom,
    }

    impl ::std::convert::From<&Self> for VpcRouterKind {
        fn from(value: &VpcRouterKind) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for VpcRouterKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::System => write!(f, "system"),
                Self::Custom => write!(f, "custom"),
            }
        }
    }

    impl ::std::str::FromStr for VpcRouterKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "system" => Ok(Self::System),
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for VpcRouterKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for VpcRouterKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for VpcRouterKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcRouter"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcRouterResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<VpcRouter>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&VpcRouterResultsPage> for VpcRouterResultsPage {
        fn from(value: &VpcRouterResultsPage) -> Self {
            value.clone()
        }
    }

    ///Updateable properties of a
    /// [`VpcRouter`](crate::external_api::views::VpcRouter)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a
    /// [`VpcRouter`](crate::external_api::views::VpcRouter)",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcRouterUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&VpcRouterUpdate> for VpcRouterUpdate {
        fn from(value: &VpcRouterUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VpcRouterUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    ///A VPC subnet represents a logical grouping for instances that allows
    /// network traffic between them, within a IPv4 subnetwork or optionall an
    /// IPv6 subnetwork.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A VPC subnet represents a logical grouping for
    /// instances that allows network traffic between them, within a IPv4
    /// subnetwork or optionall an IPv6 subnetwork.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "ipv4_block",
    ///    "ipv6_block",
    ///    "name",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ipv4_block": {
    ///      "description": "The IPv4 subnet CIDR block.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      ]
    ///    },
    ///    "ipv6_block": {
    ///      "description": "The IPv6 subnet CIDR block.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which the subnet belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcSubnet {
        ///human-readable free-form text about a resource
        pub description: ::std::string::String,
        ///unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        ///The IPv4 subnet CIDR block.
        pub ipv4_block: Ipv4Net,
        ///The IPv6 subnet CIDR block.
        pub ipv6_block: Ipv6Net,
        ///unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        ///timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        ///timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        ///The VPC to which the subnet belongs.
        pub vpc_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&VpcSubnet> for VpcSubnet {
        fn from(value: &VpcSubnet) -> Self {
            value.clone()
        }
    }

    ///Create-time parameters for a
    /// [`VpcSubnet`](crate::external_api::views::VpcSubnet)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Create-time parameters for a
    /// [`VpcSubnet`](crate::external_api::views::VpcSubnet)",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "ipv4_block",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "ipv4_block": {
    ///      "description": "The IPv4 address range for this subnet.\n\nIt must
    /// be allocated from an RFC 1918 private address range, and must not
    /// overlap with any other existing subnet in the VPC.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      ]
    ///    },
    ///    "ipv6_block": {
    ///      "description": "The IPv6 address range for this subnet.\n\nIt must
    /// be allocated from the RFC 4193 Unique Local Address range, with the
    /// prefix equal to the parent VPC's prefix. A random `/64` block will be
    /// assigned if one is not provided. It must not overlap with any existing
    /// subnet in the VPC.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Ipv6Net"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcSubnetCreate {
        pub description: ::std::string::String,
        ///The IPv4 address range for this subnet.
        ///
        ///It must be allocated from an RFC 1918 private address range, and
        /// must not overlap with any other existing subnet in the VPC.
        pub ipv4_block: Ipv4Net,
        ///The IPv6 address range for this subnet.
        ///
        ///It must be allocated from the RFC 4193 Unique Local Address range,
        /// with the prefix equal to the parent VPC's prefix. A random `/64`
        /// block will be assigned if one is not provided. It must not overlap
        /// with any existing subnet in the VPC.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ipv6_block: ::std::option::Option<Ipv6Net>,
        pub name: Name,
    }

    impl ::std::convert::From<&VpcSubnetCreate> for VpcSubnetCreate {
        fn from(value: &VpcSubnetCreate) -> Self {
            value.clone()
        }
    }

    ///A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcSubnet"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcSubnetResultsPage {
        ///list of items on this page of results
        pub items: ::std::vec::Vec<VpcSubnet>,
        ///token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&VpcSubnetResultsPage> for VpcSubnetResultsPage {
        fn from(value: &VpcSubnetResultsPage) -> Self {
            value.clone()
        }
    }

    ///Updateable properties of a
    /// [`VpcSubnet`](crate::external_api::views::VpcSubnet)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a
    /// [`VpcSubnet`](crate::external_api::views::VpcSubnet)",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcSubnetUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&VpcSubnetUpdate> for VpcSubnetUpdate {
        fn from(value: &VpcSubnetUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VpcSubnetUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    ///Updateable properties of a [`Vpc`](crate::external_api::views::Vpc)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Updateable properties of a
    /// [`Vpc`](crate::external_api::views::Vpc)",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "dns_name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VpcUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub dns_name: ::std::option::Option<Name>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&VpcUpdate> for VpcUpdate {
        fn from(value: &VpcUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VpcUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                dns_name: Default::default(),
                name: Default::default(),
            }
        }
    }

    /// Generation of default values for serde.
    pub mod defaults {
        pub(super) fn default_bool<const V: bool>() -> bool {
            V
        }

        pub(super) fn instance_create_network_interfaces(
        ) -> super::InstanceNetworkInterfaceAttachment {
            super::InstanceNetworkInterfaceAttachment::Default
        }
    }

    ///Error enum for the `disk_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DiskViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DiskViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `image_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ImageViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ImageViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_network_interface_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceNetworkInterfaceViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceNetworkInterfaceViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `snapshot_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SnapshotViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SnapshotViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_route_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterRouteViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterRouteViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_subnet_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcSubnetViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcSubnetViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `device_auth_confirm` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DeviceAuthConfirmError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DeviceAuthConfirmError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `group_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum GroupListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for GroupListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `login_spoof` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum LoginSpoofError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for LoginSpoofError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `login_local` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum LoginLocalError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for LoginLocalError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `login_saml_begin` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum LoginSamlBeginError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for LoginSamlBeginError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `login_saml` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum LoginSamlError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for LoginSamlError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `logout` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum LogoutError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for LogoutError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_policy_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationPolicyViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationPolicyViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_policy_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationPolicyUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationPolicyUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `disk_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DiskListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DiskListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `disk_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DiskCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DiskCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `disk_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DiskViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DiskViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `disk_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DiskDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DiskDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `disk_metrics_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DiskMetricsListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DiskMetricsListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `image_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ImageListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ImageListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `image_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ImageCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ImageCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `image_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ImageViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ImageViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `image_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ImageDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ImageDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_disk_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceDiskListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceDiskListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_disk_attach` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceDiskAttachError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceDiskAttachError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_disk_detach` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceDiskDetachError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceDiskDetachError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_external_ip_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceExternalIpListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceExternalIpListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_migrate` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceMigrateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceMigrateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_network_interface_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceNetworkInterfaceListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceNetworkInterfaceListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_network_interface_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceNetworkInterfaceCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceNetworkInterfaceCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_network_interface_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceNetworkInterfaceViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceNetworkInterfaceViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_network_interface_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceNetworkInterfaceUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceNetworkInterfaceUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_network_interface_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceNetworkInterfaceDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceNetworkInterfaceDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_reboot` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceRebootError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceRebootError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_serial_console` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceSerialConsoleError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceSerialConsoleError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_start` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceStartError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceStartError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_stop` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceStopError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceStopError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_policy_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectPolicyViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectPolicyViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_policy_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectPolicyUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectPolicyUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `snapshot_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SnapshotListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SnapshotListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `snapshot_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SnapshotCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SnapshotCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `snapshot_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SnapshotViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SnapshotViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `snapshot_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SnapshotDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SnapshotDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_firewall_rules_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcFirewallRulesViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcFirewallRulesViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_firewall_rules_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcFirewallRulesUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcFirewallRulesUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_route_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterRouteListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterRouteListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_route_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterRouteCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterRouteCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_route_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterRouteViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterRouteViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_route_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterRouteUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterRouteUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_router_route_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcRouterRouteDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcRouterRouteDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_subnet_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcSubnetListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcSubnetListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_subnet_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcSubnetCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcSubnetCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_subnet_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcSubnetViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcSubnetViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_subnet_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcSubnetUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcSubnetUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_subnet_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcSubnetDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcSubnetDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `vpc_subnet_list_network_interfaces` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum VpcSubnetListNetworkInterfacesError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for VpcSubnetListNetworkInterfacesError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `policy_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum PolicyViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for PolicyViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `policy_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum PolicyUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for PolicyUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `role_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum RoleListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for RoleListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `role_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum RoleViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for RoleViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `session_me` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SessionMeError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SessionMeError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `session_me_groups` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SessionMeGroupsError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SessionMeGroupsError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `session_sshkey_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SessionSshkeyListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SessionSshkeyListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `session_sshkey_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SessionSshkeyCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SessionSshkeyCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `session_sshkey_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SessionSshkeyViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SessionSshkeyViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `session_sshkey_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SessionSshkeyDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SessionSshkeyDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_image_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemImageViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemImageViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `silo_view_by_id` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SiloViewByIdError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SiloViewByIdError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `certificate_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum CertificateListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for CertificateListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `certificate_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum CertificateCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for CertificateCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `certificate_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum CertificateViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for CertificateViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `certificate_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum CertificateDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for CertificateDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `physical_disk_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum PhysicalDiskListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for PhysicalDiskListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `rack_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum RackListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for RackListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `rack_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum RackViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for RackViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `sled_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SledListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SledListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `sled_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SledViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SledViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `sled_physical_disk_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SledPhysicalDiskListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SledPhysicalDiskListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_image_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemImageListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemImageListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_image_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemImageCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemImageCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_image_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemImageViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemImageViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_image_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemImageDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemImageDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_range_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolRangeListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolRangeListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_range_add` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolRangeAddError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolRangeAddError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_range_remove` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolRangeRemoveError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolRangeRemoveError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_service_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolServiceViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolServiceViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_service_range_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolServiceRangeListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolServiceRangeListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_service_range_add` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolServiceRangeAddError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolServiceRangeAddError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `ip_pool_service_range_remove` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum IpPoolServiceRangeRemoveError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for IpPoolServiceRangeRemoveError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_metric` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemMetricError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemMetricError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_policy_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemPolicyViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemPolicyViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_policy_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemPolicyUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemPolicyUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `saga_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SagaListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SagaListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `saga_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SagaViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SagaViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `silo_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SiloListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SiloListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `silo_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SiloCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SiloCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `silo_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SiloViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SiloViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `silo_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SiloDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SiloDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `silo_identity_provider_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SiloIdentityProviderListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SiloIdentityProviderListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `local_idp_user_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum LocalIdpUserCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for LocalIdpUserCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `local_idp_user_delete` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum LocalIdpUserDeleteError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for LocalIdpUserDeleteError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `local_idp_user_set_password` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum LocalIdpUserSetPasswordError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for LocalIdpUserSetPasswordError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `saml_identity_provider_create` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SamlIdentityProviderCreateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SamlIdentityProviderCreateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `saml_identity_provider_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SamlIdentityProviderViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SamlIdentityProviderViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `silo_policy_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SiloPolicyViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SiloPolicyViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `silo_policy_update` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SiloPolicyUpdateError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SiloPolicyUpdateError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `silo_users_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SiloUsersListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SiloUsersListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `silo_user_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SiloUserViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SiloUserViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_user_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemUserListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemUserListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_user_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemUserViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemUserViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `timeseries_schema_get` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum TimeseriesSchemaGetError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for TimeseriesSchemaGetError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `user_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum UserListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for UserListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `disk_list_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DiskListV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DiskListV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `disk_create_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DiskCreateV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DiskCreateV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `disk_view_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DiskViewV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DiskViewV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `disk_delete_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum DiskDeleteV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for DiskDeleteV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_list_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceListV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceListV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_create_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceCreateV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceCreateV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_view_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceViewV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceViewV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_delete_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceDeleteV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceDeleteV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_disk_list_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceDiskListV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceDiskListV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_disk_attach_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceDiskAttachV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceDiskAttachV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_disk_detach_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceDiskDetachV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceDiskDetachV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_migrate_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceMigrateV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceMigrateV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_reboot_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceRebootV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceRebootV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_serial_console_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceSerialConsoleV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceSerialConsoleV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_start_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceStartV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceStartV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `instance_stop_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum InstanceStopV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for InstanceStopV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_list_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationListV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationListV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_create_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationCreateV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationCreateV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_view_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationViewV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationViewV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_update_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationUpdateV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationUpdateV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_delete_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationDeleteV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationDeleteV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_policy_view_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationPolicyViewV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationPolicyViewV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `organization_policy_update_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum OrganizationPolicyUpdateV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for OrganizationPolicyUpdateV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_list_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectListV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectListV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_create_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectCreateV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectCreateV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_view_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectViewV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectViewV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_update_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectUpdateV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectUpdateV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_delete_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectDeleteV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectDeleteV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_policy_view_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectPolicyViewV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectPolicyViewV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `project_policy_update_v1` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ProjectPolicyUpdateV1Error {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for ProjectPolicyUpdateV1Error {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_component_version_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemComponentVersionListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemComponentVersionListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `update_deployments_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum UpdateDeploymentsListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for UpdateDeploymentsListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `update_deployment_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum UpdateDeploymentViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for UpdateDeploymentViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_update_refresh` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemUpdateRefreshError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemUpdateRefreshError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_update_start` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemUpdateStartError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemUpdateStartError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_update_stop` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemUpdateStopError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemUpdateStopError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_update_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemUpdateListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemUpdateListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_update_view` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemUpdateViewError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemUpdateViewError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_update_components_list` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemUpdateComponentsListError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemUpdateComponentsListError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }

    ///Error enum for the `system_version` operation
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SystemVersionError {
        # [doc = concat ! ("Error response for status code " , "4")]
        Status4xx(Error),
        # [doc = concat ! ("Error response for status code " , "5")]
        Status5xx(Error),
        /// Error response for an unknown status code
        UnknownValue(serde_json::Value),
    }

    impl std::str::FromStr for SystemVersionError {
        type Err = std::string::String;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let (status_code, value) = match s.split_once(':') {
                Some((status_code, value)) => (status_code, value),
                None => return Err("Unable to split status code and value".to_string()),
            };
            let status_code: u16 = match status_code.parse() {
                Ok(code) => code,
                Err(e) => return Err(format!("Unable to parse status code: {}", e)),
            };
            match status_code {
                _ => match serde_json::from_str(value) {
                    Ok(json_value) => Ok(Self::UnknownValue(json_value)),
                    Err(_) => Err("Unable to parse as JSON".to_string()),
                },
            }
        }
    }
}

#[derive(Clone, Debug)]
///Client for Oxide Region API
///
///API for interacting with the Oxide control plane
///
///Version: 0.0.1
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

/// Client with middleware support for enhanced request/response processing.
///
/// This client type is only available when the "middleware" feature is enabled.
#[cfg(feature = "middleware")]
#[derive(Clone, Debug)]
///Client for Oxide Region API
///
///API for interacting with the Oxide control plane
///
///Version: 0.0.1
pub struct MiddlewareClient {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest_middleware::ClientWithMiddleware,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(
            baseurl,
            client.build().expect("Failed to build HTTP client"),
        )
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }

    /// Construct a new client with an existing
    /// `reqwest_middleware::ClientWithMiddleware`,
    /// allowing the use of middleware for requests.
    ///
    /// `baseurl` is the base URL provided to the internal client, and should
    /// include
    /// a scheme and hostname, as well as port and a path stem if applicable.
    ///
    /// This method is only available when the "middleware" feature is enabled.
    #[cfg(feature = "middleware")]
    pub fn new_with_client_middleware(
        baseurl: &str,
        client: reqwest_middleware::ClientWithMiddleware,
    ) -> MiddlewareClient {
        MiddlewareClient {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}

impl ClientInfo<(), reqwest::Client> for Client {
    fn api_version() -> &'static str {
        "0.0.1"
    }

    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }

    fn client(&self) -> &reqwest::Client {
        &self.client
    }

    fn inner(&self) -> &() {
        &()
    }
}

impl ClientHooks<(), reqwest::Client> for &Client {}
#[cfg(feature = "middleware")]
impl ClientHooks<(), reqwest_middleware::ClientWithMiddleware> for &MiddlewareClient {}
#[cfg(feature = "middleware")]
impl ClientInfo<(), reqwest_middleware::ClientWithMiddleware> for MiddlewareClient {
    fn api_version() -> &'static str {
        "0.0.1"
    }

    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }

    fn client(&self) -> &reqwest_middleware::ClientWithMiddleware {
        &self.client
    }

    fn inner(&self) -> &() {
        &()
    }
}

#[allow(clippy::all)]
#[allow(mismatched_lifetime_syntaxes)]
impl Client {
    ///Fetch a disk by id
    ///
    ///Use `GET /v1/disks/{disk}` instead
    ///
    ///Sends a 'GET' request to '/by-id/disks/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Disk>, Error<types::DiskViewByIdError>> {
        let url = format!(
            "{}/by-id/disks/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskViewByIdError>::from_response::<
                        types::DiskViewByIdError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskViewByIdError>::from_response::<
                        types::DiskViewByIdError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an image by id
    ///
    ///Sends a 'GET' request to '/by-id/images/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn image_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Image>, Error<types::ImageViewByIdError>> {
        let url = format!(
            "{}/by-id/images/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "image_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageViewByIdError>::from_response::<
                    types::ImageViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageViewByIdError>::from_response::<
                    types::ImageViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an instance by id
    ///
    ///Sends a 'GET' request to '/by-id/instances/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceViewByIdError>> {
        let url = format!(
            "{}/by-id/instances/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceViewByIdError>::from_response::<
                    types::InstanceViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceViewByIdError>::from_response::<
                    types::InstanceViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a network interface by id
    ///
    ///Sends a 'GET' request to '/by-id/network-interfaces/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<
        ResponseValue<types::NetworkInterface>,
        Error<types::InstanceNetworkInterfaceViewByIdError>,
    > {
        let url = format!(
            "{}/by-id/network-interfaces/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceViewByIdError>::from_response::<
                    types::InstanceNetworkInterfaceViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceViewByIdError>::from_response::<
                    types::InstanceNetworkInterfaceViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an organization by id
    ///
    ///Use `GET /v1/organizations/{organization}` instead
    ///
    ///Sends a 'GET' request to '/by-id/organizations/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationViewByIdError>> {
        let url = format!(
            "{}/by-id/organizations/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewByIdError>::from_response::<
                    types::OrganizationViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewByIdError>::from_response::<
                    types::OrganizationViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a project by id
    ///
    ///Use `GET /v1/projects/{project}` instead
    ///
    ///Sends a 'GET' request to '/by-id/projects/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectViewByIdError>> {
        let url = format!(
            "{}/by-id/projects/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewByIdError>::from_response::<
                    types::ProjectViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewByIdError>::from_response::<
                    types::ProjectViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a snapshot by id
    ///
    ///Sends a 'GET' request to '/by-id/snapshots/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn snapshot_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Snapshot>, Error<types::SnapshotViewByIdError>> {
        let url = format!(
            "{}/by-id/snapshots/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "snapshot_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotViewByIdError>::from_response::<
                    types::SnapshotViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotViewByIdError>::from_response::<
                    types::SnapshotViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a route by id
    ///
    ///Sends a 'GET' request to '/by-id/vpc-router-routes/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::VpcRouterRouteViewByIdError>> {
        let url = format!(
            "{}/by-id/vpc-router-routes/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteViewByIdError>::from_response::<
                    types::VpcRouterRouteViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteViewByIdError>::from_response::<
                    types::VpcRouterRouteViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Get a router by id
    ///
    ///Sends a 'GET' request to '/by-id/vpc-routers/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::VpcRouterViewByIdError>> {
        let url = format!(
            "{}/by-id/vpc-routers/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterViewByIdError>::from_response::<
                    types::VpcRouterViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterViewByIdError>::from_response::<
                    types::VpcRouterViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a subnet by id
    ///
    ///Sends a 'GET' request to '/by-id/vpc-subnets/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::VpcSubnetViewByIdError>> {
        let url = format!(
            "{}/by-id/vpc-subnets/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetViewByIdError>::from_response::<
                    types::VpcSubnetViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetViewByIdError>::from_response::<
                    types::VpcSubnetViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a VPC
    ///
    ///Sends a 'GET' request to '/by-id/vpcs/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::VpcViewByIdError>> {
        let url = format!(
            "{}/by-id/vpcs/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcViewByIdError>::from_response::<types::VpcViewByIdError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcViewByIdError>::from_response::<types::VpcViewByIdError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Start an OAuth 2.0 Device Authorization Grant
    ///
    ///This endpoint is designed to be accessed from an *unauthenticated* API
    /// client. It generates and records a `device_code` and `user_code` which
    /// must be verified and confirmed prior to a token being granted.
    ///
    ///Sends a 'POST' request to '/device/auth'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn device_auth_request<'a>(
        &'a self,
        body: &'a types::DeviceAuthRequest,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!("{}/device/auth", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .form_urlencoded(&body)?
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "device_auth_request",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::ErrorResponse(ResponseValue::empty(response))),
        }
    }

    ///Confirm an OAuth 2.0 Device Authorization Grant
    ///
    ///This endpoint is designed to be accessed by the user agent (browser),
    /// not the client requesting the token. So we do not actually return the
    /// token here; it will be returned in response to the poll on
    /// `/device/token`.
    ///
    ///Sends a 'POST' request to '/device/confirm'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn device_auth_confirm<'a>(
        &'a self,
        body: &'a types::DeviceAuthVerify,
    ) -> Result<ResponseValue<()>, Error<types::DeviceAuthConfirmError>> {
        let url = format!("{}/device/confirm", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "device_auth_confirm",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DeviceAuthConfirmError>::from_response::<
                    types::DeviceAuthConfirmError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DeviceAuthConfirmError>::from_response::<
                    types::DeviceAuthConfirmError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Request a device access token
    ///
    ///This endpoint should be polled by the client until the user code is
    /// verified and the grant is confirmed.
    ///
    ///Sends a 'POST' request to '/device/token'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn device_access_token<'a>(
        &'a self,
        body: &'a types::DeviceAccessTokenRequest,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!("{}/device/token", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .form_urlencoded(&body)?
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "device_access_token",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::ErrorResponse(ResponseValue::empty(response))),
        }
    }

    ///List groups
    ///
    ///Sends a 'GET' request to '/groups'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn group_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::GroupListError>> {
        let url = format!("{}/groups", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "group_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::GroupListError>::from_response::<types::GroupListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::GroupListError>::from_response::<types::GroupListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List groups as a Stream
    ///
    ///Sends repeated `GET` requests to `/groups` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn group_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Group, Error<types::GroupListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.group_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.group_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Sends a 'POST' request to '/login'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn login_spoof<'a>(
        &'a self,
        body: &'a types::SpoofLoginBody,
    ) -> Result<ResponseValue<()>, Error<types::LoginSpoofError>> {
        let url = format!("{}/login", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "login_spoof",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSpoofError>::from_response::<types::LoginSpoofError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSpoofError>::from_response::<types::LoginSpoofError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Authenticate a user (i.e., log in) via username and password
    ///
    ///Sends a 'POST' request to '/login/{silo_name}/local'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn login_local<'a>(
        &'a self,
        silo_name: &'a types::Name,
        body: &'a types::UsernamePasswordCredentials,
    ) -> Result<ResponseValue<ByteStream>, Error<types::LoginLocalError>> {
        let url = format!(
            "{}/login/{}/local",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "login_local",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginLocalError>::from_response::<types::LoginLocalError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginLocalError>::from_response::<types::LoginLocalError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Prompt user login
    ///
    ///Either display a page asking a user for their credentials, or redirect
    /// them to their identity provider.
    ///
    ///Sends a 'GET' request to '/login/{silo_name}/saml/{provider_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn login_saml_begin<'a>(
        &'a self,
        silo_name: &'a types::Name,
        provider_name: &'a types::Name,
    ) -> Result<ResponseValue<ByteStream>, Error<types::LoginSamlBeginError>> {
        let url = format!(
            "{}/login/{}/saml/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&provider_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self.client().get(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "login_saml_begin",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSamlBeginError>::from_response::<
                    types::LoginSamlBeginError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSamlBeginError>::from_response::<
                    types::LoginSamlBeginError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Authenticate a user (i.e., log in) via SAML
    ///
    ///Sends a 'POST' request to '/login/{silo_name}/saml/{provider_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn login_saml<'a, B: Into<reqwest::Body>>(
        &'a self,
        silo_name: &'a types::Name,
        provider_name: &'a types::Name,
        body: B,
    ) -> Result<ResponseValue<ByteStream>, Error<types::LoginSamlError>> {
        let url = format!(
            "{}/login/{}/saml/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&provider_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "login_saml",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSamlError>::from_response::<types::LoginSamlError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSamlError>::from_response::<types::LoginSamlError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Sends a 'POST' request to '/logout'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn logout<'a>(&'a self) -> Result<ResponseValue<()>, Error<types::LogoutError>> {
        let url = format!("{}/logout", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "logout",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LogoutError>::from_response::<types::LogoutError>(response)
                    .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LogoutError>::from_response::<types::LogoutError>(response)
                    .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List organizations
    ///
    ///Use `GET /v1/organizations` instead
    ///
    ///Sends a 'GET' request to '/organizations'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::OrganizationResultsPage>, Error<types::OrganizationListError>>
    {
        let url = format!("{}/organizations", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationListError>::from_response::<
                    types::OrganizationListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationListError>::from_response::<
                    types::OrganizationListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List organizations as a Stream
    ///
    ///Use `GET /v1/organizations` instead
    ///
    ///Sends repeated `GET` requests to `/organizations` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn organization_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Organization, Error<types::OrganizationListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.organization_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.organization_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an organization
    ///
    ///Use `POST /v1/organizations` instead
    ///
    ///Sends a 'POST' request to '/organizations'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_create<'a>(
        &'a self,
        body: &'a types::OrganizationCreate,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationCreateError>> {
        let url = format!("{}/organizations", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationCreateError>::from_response::<
                    types::OrganizationCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationCreateError>::from_response::<
                    types::OrganizationCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an organization
    ///
    ///Use `GET /v1/organizations/{organization}` instead
    ///
    ///Sends a 'GET' request to '/organizations/{organization_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationViewError>> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewError>::from_response::<
                    types::OrganizationViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewError>::from_response::<
                    types::OrganizationViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update an organization
    ///
    ///Use `PUT /v1/organizations/{organization}` instead
    ///
    ///Sends a 'PUT' request to '/organizations/{organization_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        body: &'a types::OrganizationUpdate,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationUpdateError>> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationUpdateError>::from_response::<
                    types::OrganizationUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationUpdateError>::from_response::<
                    types::OrganizationUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an organization
    ///
    ///Use `DELETE /v1/organizations/{organization}` instead
    ///
    ///Sends a 'DELETE' request to '/organizations/{organization_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::OrganizationDeleteError>> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationDeleteError>::from_response::<
                    types::OrganizationDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationDeleteError>::from_response::<
                    types::OrganizationDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an organization's IAM policy
    ///
    ///Use `GET /v1/organizations/{organization}/policy` instead
    ///
    ///Sends a 'GET' request to '/organizations/{organization_name}/policy'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_policy_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
    ) -> Result<
        ResponseValue<types::OrganizationRolePolicy>,
        Error<types::OrganizationPolicyViewError>,
    > {
        let url = format!(
            "{}/organizations/{}/policy",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_policy_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyViewError>::from_response::<
                    types::OrganizationPolicyViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyViewError>::from_response::<
                    types::OrganizationPolicyViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update an organization's IAM policy
    ///
    ///Use `PUT /v1/organizations/{organization}/policy` instead
    ///
    ///Sends a 'PUT' request to '/organizations/{organization_name}/policy'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_policy_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        body: &'a types::OrganizationRolePolicy,
    ) -> Result<
        ResponseValue<types::OrganizationRolePolicy>,
        Error<types::OrganizationPolicyUpdateError>,
    > {
        let url = format!(
            "{}/organizations/{}/policy",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_policy_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyUpdateError>::from_response::<
                    types::OrganizationPolicyUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyUpdateError>::from_response::<
                    types::OrganizationPolicyUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List projects
    ///
    ///Use `GET /v1/projects` instead
    ///
    ///Sends a 'GET' request to '/organizations/{organization_name}/projects'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::ProjectListError>> {
        let url = format!(
            "{}/organizations/{}/projects",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectListError>::from_response::<types::ProjectListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectListError>::from_response::<types::ProjectListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List projects as a Stream
    ///
    ///Use `GET /v1/projects` instead
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn project_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Project, Error<types::ProjectListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_list(organization_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_list(organization_name, limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a project
    ///
    ///Use `POST /v1/projects` instead
    ///
    ///Sends a 'POST' request to '/organizations/{organization_name}/projects'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        body: &'a types::ProjectCreate,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectCreateError>::from_response::<
                    types::ProjectCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectCreateError>::from_response::<
                    types::ProjectCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a project
    ///
    ///Use `GET /v1/projects/{project}` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewError>::from_response::<types::ProjectViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewError>::from_response::<types::ProjectViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a project
    ///
    ///Use `PUT /v1/projects/{project}` instead
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::ProjectUpdate,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectUpdateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectUpdateError>::from_response::<
                    types::ProjectUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectUpdateError>::from_response::<
                    types::ProjectUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a project
    ///
    ///Use `DELETE /v1/projects/{project}` instead
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::ProjectDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectDeleteError>::from_response::<
                    types::ProjectDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectDeleteError>::from_response::<
                    types::ProjectDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List disks
    ///
    ///Use `GET /v1/disks` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/disks'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::DiskListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskListError>::from_response::<types::DiskListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskListError>::from_response::<types::DiskListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List disks as a Stream
    ///
    ///Use `GET /v1/disks` instead
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/disks` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn disk_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::DiskListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.disk_list(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.disk_list(
                            organization_name,
                            project_name,
                            limit,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Use `POST /v1/disks` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/disks'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::DiskCreate,
    ) -> Result<ResponseValue<types::Disk>, Error<types::DiskCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskCreateError>::from_response::<types::DiskCreateError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskCreateError>::from_response::<types::DiskCreateError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a disk
    ///
    ///Use `GET /v1/disks/{disk}` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Disk>, Error<types::DiskViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&disk_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskViewError>::from_response::<types::DiskViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskViewError>::from_response::<types::DiskViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Use `DELETE /v1/disks/{disk}` instead
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::DiskDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&disk_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskDeleteError>::from_response::<types::DiskDeleteError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskDeleteError>::from_response::<types::DiskDeleteError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch disk metrics
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}/metrics/{metric_name}'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `disk_name`
    /// - `metric_name`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `start_time`: An inclusive start time of metrics.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_metrics_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
        metric_name: types::DiskMetricName,
        end_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        start_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
    ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::DiskMetricsListError>>
    {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks/{}/metrics/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&disk_name.to_string()),
            encode_path(&metric_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("end_time", &end_time))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new(
                "start_time",
                &start_time,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_metrics_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskMetricsListError>::from_response::<
                    types::DiskMetricsListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskMetricsListError>::from_response::<
                    types::DiskMetricsListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch disk metrics as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}/metrics/{metric_name}` until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `disk_name`
    /// - `metric_name`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `start_time`: An inclusive start time of metrics.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn disk_metrics_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
        metric_name: types::DiskMetricName,
        end_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
        limit: Option<::std::num::NonZeroU32>,
        start_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
    ) -> impl futures::Stream<Item = Result<types::Measurement, Error<types::DiskMetricsListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.disk_metrics_list(
            organization_name,
            project_name,
            disk_name,
            metric_name,
            end_time,
            limit,
            None,
            start_time,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.disk_metrics_list(
                        organization_name,
                        project_name,
                        disk_name,
                        metric_name,
                        None,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///List images
    ///
    ///List images in a project. The images are returned sorted by creation
    /// date, with the most recent images appearing first.
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/images'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn image_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::ImageResultsPage>, Error<types::ImageListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/images",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "image_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageListError>::from_response::<types::ImageListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageListError>::from_response::<types::ImageListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List images as a Stream
    ///
    ///List images in a project. The images are returned sorted by creation
    /// date, with the most recent images appearing first.
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/images`
    /// until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn image_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Image, Error<types::ImageListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.image_list(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.image_list(
                            organization_name,
                            project_name,
                            limit,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an image
    ///
    ///Create a new image in a project.
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/images'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn image_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::ImageCreate,
    ) -> Result<ResponseValue<types::Image>, Error<types::ImageCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/images",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "image_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageCreateError>::from_response::<types::ImageCreateError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageCreateError>::from_response::<types::ImageCreateError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an image
    ///
    ///Fetch the details for a specific image in a project.
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/images/
    /// {image_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn image_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        image_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Image>, Error<types::ImageViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/images/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&image_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "image_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageViewError>::from_response::<types::ImageViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageViewError>::from_response::<types::ImageViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an image
    ///
    ///Permanently delete an image from a project. This operation cannot be
    /// undone. Any instances in the project using the image will continue to
    /// run, however new instances can not be created with this image.
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/images/
    /// {image_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn image_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        image_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::ImageDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/images/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&image_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "image_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageDeleteError>::from_response::<types::ImageDeleteError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageDeleteError>::from_response::<types::ImageDeleteError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List instances
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::InstanceListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceListError>::from_response::<
                        types::InstanceListError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceListError>::from_response::<
                        types::InstanceListError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List instances as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/instances`
    /// until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn instance_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::InstanceListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_list(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.instance_list(
                            organization_name,
                            project_name,
                            limit,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an instance
    ///
    ///Use `POST /v1/instances` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::InstanceCreate,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceCreateError>::from_response::<
                    types::InstanceCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceCreateError>::from_response::<
                    types::InstanceCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an instance
    ///
    ///Use `GET /v1/instances/{instance}` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceViewError>::from_response::<
                        types::InstanceViewError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceViewError>::from_response::<
                        types::InstanceViewError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an instance
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::InstanceDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDeleteError>::from_response::<
                    types::InstanceDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDeleteError>::from_response::<
                    types::InstanceDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List an instance's disks
    ///
    ///Use `GET /v1/instances/{instance}/disks` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::InstanceDiskListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskListError>::from_response::<
                    types::InstanceDiskListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskListError>::from_response::<
                    types::InstanceDiskListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List an instance's disks as a Stream
    ///
    ///Use `GET /v1/instances/{instance}/disks` instead
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks` until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn instance_disk_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::InstanceDiskListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_disk_list(
            organization_name,
            project_name,
            instance_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.instance_disk_list(
                        organization_name,
                        project_name,
                        instance_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Attach a disk to an instance
    ///
    ///Use `POST /v1/instances/{instance}/disks/attach` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks/attach'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_attach<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::DiskIdentifier,
    ) -> Result<ResponseValue<types::Disk>, Error<types::InstanceDiskAttachError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks/attach",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_attach",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskAttachError>::from_response::<
                    types::InstanceDiskAttachError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskAttachError>::from_response::<
                    types::InstanceDiskAttachError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Detach a disk from an instance
    ///
    ///Use `POST /v1/disks/{disk}/detach` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks/detach'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_detach<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::DiskIdentifier,
    ) -> Result<ResponseValue<types::Disk>, Error<types::InstanceDiskDetachError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks/detach",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_detach",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskDetachError>::from_response::<
                    types::InstanceDiskDetachError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskDetachError>::from_response::<
                    types::InstanceDiskDetachError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List external IP addresses
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/external-ips'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_external_ip_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<
        ResponseValue<types::ExternalIpResultsPage>,
        Error<types::InstanceExternalIpListError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/external-ips",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_external_ip_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceExternalIpListError>::from_response::<
                    types::InstanceExternalIpListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceExternalIpListError>::from_response::<
                    types::InstanceExternalIpListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Migrate an instance
    ///
    ///Use `POST /v1/instances/{instance}/migrate` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/migrate'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_migrate<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::InstanceMigrate,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceMigrateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/migrate",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_migrate",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceMigrateError>::from_response::<
                    types::InstanceMigrateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceMigrateError>::from_response::<
                    types::InstanceMigrateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List network interfaces
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<
        ResponseValue<types::NetworkInterfaceResultsPage>,
        Error<types::InstanceNetworkInterfaceListError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceListError>::from_response::<
                    types::InstanceNetworkInterfaceListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceListError>::from_response::<
                    types::InstanceNetworkInterfaceListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List network interfaces as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces` until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn instance_network_interface_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::NetworkInterface, Error<types::InstanceNetworkInterfaceListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_network_interface_list(
            organization_name,
            project_name,
            instance_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.instance_network_interface_list(
                        organization_name,
                        project_name,
                        instance_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Create a network interface
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::NetworkInterfaceCreate,
    ) -> Result<
        ResponseValue<types::NetworkInterface>,
        Error<types::InstanceNetworkInterfaceCreateError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceCreateError>::from_response::<
                    types::InstanceNetworkInterfaceCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceCreateError>::from_response::<
                    types::InstanceNetworkInterfaceCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a network interface
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        interface_name: &'a types::Name,
    ) -> Result<
        ResponseValue<types::NetworkInterface>,
        Error<types::InstanceNetworkInterfaceViewError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
            encode_path(&interface_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceViewError>::from_response::<
                    types::InstanceNetworkInterfaceViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceViewError>::from_response::<
                    types::InstanceNetworkInterfaceViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a network interface
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        interface_name: &'a types::Name,
        body: &'a types::NetworkInterfaceUpdate,
    ) -> Result<
        ResponseValue<types::NetworkInterface>,
        Error<types::InstanceNetworkInterfaceUpdateError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
            encode_path(&interface_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceUpdateError>::from_response::<
                    types::InstanceNetworkInterfaceUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceUpdateError>::from_response::<
                    types::InstanceNetworkInterfaceUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a network interface
    ///
    ///Note that the primary interface for an instance cannot be deleted if
    /// there are any secondary interfaces. A new primary interface must be
    /// designated first. The primary interface can be deleted if there are no
    /// secondary interfaces.
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        interface_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::InstanceNetworkInterfaceDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
            encode_path(&interface_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceDeleteError>::from_response::<
                    types::InstanceNetworkInterfaceDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceDeleteError>::from_response::<
                    types::InstanceNetworkInterfaceDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Reboot an instance
    ///
    ///Use `POST /v1/instances/{instance}/reboot` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/reboot'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_reboot<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceRebootError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/reboot",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_reboot",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceRebootError>::from_response::<
                    types::InstanceRebootError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceRebootError>::from_response::<
                    types::InstanceRebootError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an instance's serial console
    ///
    ///Use `GET /v1/instances/{instance}/serial-console` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/serial-console'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `from_start`: Character index in the serial buffer from which to read,
    ///   counting the bytes output since instance start. If this is not
    ///   provided, `most_recent` must be provided, and if this *is* provided,
    ///   `most_recent` must *not* be provided.
    /// - `max_bytes`: Maximum number of bytes of buffered serial console
    ///   contents to return. If the requested range runs to the end of the
    ///   available buffer, the data returned will be shorter than `max_bytes`.
    /// - `most_recent`: Character index in the serial buffer from which to
    ///   read, counting *backward* from the most recently buffered data
    ///   retrieved from the instance. (See note on `from_start` about mutual
    ///   exclusivity)
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_serial_console<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        from_start: Option<u64>,
        max_bytes: Option<u64>,
        most_recent: Option<u64>,
    ) -> Result<
        ResponseValue<types::InstanceSerialConsoleData>,
        Error<types::InstanceSerialConsoleError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/serial-console",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "from_start",
                &from_start,
            ))
            .query(&progenitor_client::QueryParam::new("max_bytes", &max_bytes))
            .query(&progenitor_client::QueryParam::new(
                "most_recent",
                &most_recent,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_serial_console",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceSerialConsoleError>::from_response::<
                    types::InstanceSerialConsoleError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceSerialConsoleError>::from_response::<
                    types::InstanceSerialConsoleError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Connect to an instance's serial console
    ///
    ///Use `GET /v1/instances/{instance}/serial-console/stream` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/serial-console/stream'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_serial_console_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<reqwest::Upgraded>, Error<()>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/serial-console/stream",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .headers(header_map)
            .header(::reqwest::header::CONNECTION, "Upgrade")
            .header(::reqwest::header::UPGRADE, "websocket")
            .header(::reqwest::header::SEC_WEBSOCKET_VERSION, "13")
            .header(
                ::reqwest::header::SEC_WEBSOCKET_KEY,
                ::base64::Engine::encode(
                    &::base64::engine::general_purpose::STANDARD,
                    ::rand::random::<[u8; 16]>(),
                ),
            )
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_serial_console_stream",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            101u16 => ResponseValue::upgrade(response).await,
            200..=299 => ResponseValue::upgrade(response).await,
            _ => Err(Error::ErrorResponse(ResponseValue::empty(response))),
        }
    }

    ///Boot an instance
    ///
    ///Use `POST /v1/instances/{instance}/start` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/start'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_start<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceStartError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/start",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_start",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStartError>::from_response::<
                    types::InstanceStartError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStartError>::from_response::<
                    types::InstanceStartError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Halt an instance
    ///
    ///Use `POST /v1/instances/{instance}/stop` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/stop'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_stop<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceStopError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/stop",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_stop",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceStopError>::from_response::<
                        types::InstanceStopError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceStopError>::from_response::<
                        types::InstanceStopError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a project's IAM policy
    ///
    ///Use `GET /v1/projects/{project}/policy` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/policy'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_policy_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
    ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::ProjectPolicyViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/policy",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_policy_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyViewError>::from_response::<
                    types::ProjectPolicyViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyViewError>::from_response::<
                    types::ProjectPolicyViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a project's IAM policy
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/policy'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_policy_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::ProjectRolePolicy,
    ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::ProjectPolicyUpdateError>>
    {
        let url = format!(
            "{}/organizations/{}/projects/{}/policy",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_policy_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyUpdateError>::from_response::<
                    types::ProjectPolicyUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyUpdateError>::from_response::<
                    types::ProjectPolicyUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List snapshots
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/snapshots'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn snapshot_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::SnapshotResultsPage>, Error<types::SnapshotListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "snapshot_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SnapshotListError>::from_response::<
                        types::SnapshotListError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SnapshotListError>::from_response::<
                        types::SnapshotListError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List snapshots as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/snapshots`
    /// until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn snapshot_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Snapshot, Error<types::SnapshotListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.snapshot_list(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.snapshot_list(
                            organization_name,
                            project_name,
                            limit,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a snapshot
    ///
    ///Creates a point-in-time snapshot from a disk.
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/snapshots'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn snapshot_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::SnapshotCreate,
    ) -> Result<ResponseValue<types::Snapshot>, Error<types::SnapshotCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "snapshot_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotCreateError>::from_response::<
                    types::SnapshotCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotCreateError>::from_response::<
                    types::SnapshotCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a snapshot
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/snapshots/
    /// {snapshot_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn snapshot_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        snapshot_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Snapshot>, Error<types::SnapshotViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&snapshot_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "snapshot_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SnapshotViewError>::from_response::<
                        types::SnapshotViewError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SnapshotViewError>::from_response::<
                        types::SnapshotViewError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a snapshot
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/snapshots/
    /// {snapshot_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn snapshot_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        snapshot_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::SnapshotDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&snapshot_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "snapshot_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotDeleteError>::from_response::<
                    types::SnapshotDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotDeleteError>::from_response::<
                    types::SnapshotDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List VPCs
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::VpcResultsPage>, Error<types::VpcListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcListError>::from_response::<types::VpcListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcListError>::from_response::<types::VpcListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List VPCs as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn vpc_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Vpc, Error<types::VpcListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_list(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.vpc_list(
                            organization_name,
                            project_name,
                            limit,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a VPC
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::VpcCreate,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::VpcCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcCreateError>::from_response::<types::VpcCreateError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcCreateError>::from_response::<types::VpcCreateError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a VPC
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::VpcViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcViewError>::from_response::<types::VpcViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcViewError>::from_response::<types::VpcViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a VPC
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcUpdate,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::VpcUpdateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcUpdateError>::from_response::<types::VpcUpdateError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcUpdateError>::from_response::<types::VpcUpdateError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a VPC
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::VpcDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcDeleteError>::from_response::<types::VpcDeleteError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcDeleteError>::from_response::<types::VpcDeleteError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List firewall rules
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/firewall/rules'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_firewall_rules_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::VpcFirewallRulesViewError>>
    {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_firewall_rules_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcFirewallRulesViewError>::from_response::<
                    types::VpcFirewallRulesViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcFirewallRulesViewError>::from_response::<
                    types::VpcFirewallRulesViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Replace firewall rules
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/firewall/rules'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_firewall_rules_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcFirewallRuleUpdateParams,
    ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::VpcFirewallRulesUpdateError>>
    {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_firewall_rules_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcFirewallRulesUpdateError>::from_response::<
                    types::VpcFirewallRulesUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcFirewallRulesUpdateError>::from_response::<
                    types::VpcFirewallRulesUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List routers
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::VpcRouterResultsPage>, Error<types::VpcRouterListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterListError>::from_response::<
                    types::VpcRouterListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterListError>::from_response::<
                    types::VpcRouterListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List routers as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers` until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn vpc_router_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::VpcRouter, Error<types::VpcRouterListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_router_list(
            organization_name,
            project_name,
            vpc_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_router_list(
                        organization_name,
                        project_name,
                        vpc_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Create a router
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcRouterCreate,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::VpcRouterCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterCreateError>::from_response::<
                    types::VpcRouterCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterCreateError>::from_response::<
                    types::VpcRouterCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Get a router
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::VpcRouterViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterViewError>::from_response::<
                    types::VpcRouterViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterViewError>::from_response::<
                    types::VpcRouterViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a router
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        body: &'a types::VpcRouterUpdate,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::VpcRouterUpdateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterUpdateError>::from_response::<
                    types::VpcRouterUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterUpdateError>::from_response::<
                    types::VpcRouterUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a router
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::VpcRouterDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterDeleteError>::from_response::<
                    types::VpcRouterDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterDeleteError>::from_response::<
                    types::VpcRouterDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List routes
    ///
    ///List the routes associated with a router in a particular VPC.
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `router_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::RouterRouteResultsPage>, Error<types::VpcRouterRouteListError>>
    {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteListError>::from_response::<
                    types::VpcRouterRouteListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteListError>::from_response::<
                    types::VpcRouterRouteListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List routes as a Stream
    ///
    ///List the routes associated with a router in a particular VPC.
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `router_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn vpc_router_route_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::RouterRoute, Error<types::VpcRouterRouteListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_router_route_list(
            organization_name,
            project_name,
            vpc_name,
            router_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_router_route_list(
                        organization_name,
                        project_name,
                        vpc_name,
                        router_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Create a router
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        body: &'a types::RouterRouteCreateParams,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::VpcRouterRouteCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteCreateError>::from_response::<
                    types::VpcRouterRouteCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteCreateError>::from_response::<
                    types::VpcRouterRouteCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a route
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::VpcRouterRouteViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
            encode_path(&route_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteViewError>::from_response::<
                    types::VpcRouterRouteViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteViewError>::from_response::<
                    types::VpcRouterRouteViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a route
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
        body: &'a types::RouterRouteUpdateParams,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::VpcRouterRouteUpdateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
            encode_path(&route_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteUpdateError>::from_response::<
                    types::VpcRouterRouteUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteUpdateError>::from_response::<
                    types::VpcRouterRouteUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a route
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::VpcRouterRouteDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
            encode_path(&route_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteDeleteError>::from_response::<
                    types::VpcRouterRouteDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteDeleteError>::from_response::<
                    types::VpcRouterRouteDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List subnets
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::VpcSubnetResultsPage>, Error<types::VpcSubnetListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetListError>::from_response::<
                    types::VpcSubnetListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetListError>::from_response::<
                    types::VpcSubnetListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List subnets as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets` until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn vpc_subnet_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::VpcSubnet, Error<types::VpcSubnetListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_subnet_list(
            organization_name,
            project_name,
            vpc_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_subnet_list(
                        organization_name,
                        project_name,
                        vpc_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Create a subnet
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcSubnetCreate,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::VpcSubnetCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetCreateError>::from_response::<
                    types::VpcSubnetCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetCreateError>::from_response::<
                    types::VpcSubnetCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a subnet
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::VpcSubnetViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&subnet_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetViewError>::from_response::<
                    types::VpcSubnetViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetViewError>::from_response::<
                    types::VpcSubnetViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a subnet
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        body: &'a types::VpcSubnetUpdate,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::VpcSubnetUpdateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&subnet_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetUpdateError>::from_response::<
                    types::VpcSubnetUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetUpdateError>::from_response::<
                    types::VpcSubnetUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a subnet
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::VpcSubnetDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&subnet_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetDeleteError>::from_response::<
                    types::VpcSubnetDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetDeleteError>::from_response::<
                    types::VpcSubnetDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List network interfaces
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}/network-interfaces'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `subnet_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_list_network_interfaces<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<
        ResponseValue<types::NetworkInterfaceResultsPage>,
        Error<types::VpcSubnetListNetworkInterfacesError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}/network-interfaces",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&subnet_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_list_network_interfaces",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetListNetworkInterfacesError>::from_response::<
                    types::VpcSubnetListNetworkInterfacesError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetListNetworkInterfacesError>::from_response::<
                    types::VpcSubnetListNetworkInterfacesError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List network interfaces as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}/network-interfaces` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `subnet_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn vpc_subnet_list_network_interfaces_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::NetworkInterface, Error<types::VpcSubnetListNetworkInterfacesError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_subnet_list_network_interfaces(
            organization_name,
            project_name,
            vpc_name,
            subnet_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_subnet_list_network_interfaces(
                        organization_name,
                        project_name,
                        vpc_name,
                        subnet_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Fetch the current silo's IAM policy
    ///
    ///Sends a 'GET' request to '/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn policy_view<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::PolicyViewError>> {
        let url = format!("{}/policy", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "policy_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::PolicyViewError>::from_response::<types::PolicyViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::PolicyViewError>::from_response::<types::PolicyViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update the current silo's IAM policy
    ///
    ///Sends a 'PUT' request to '/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn policy_update<'a>(
        &'a self,
        body: &'a types::SiloRolePolicy,
    ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::PolicyUpdateError>> {
        let url = format!("{}/policy", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "policy_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::PolicyUpdateError>::from_response::<
                        types::PolicyUpdateError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::PolicyUpdateError>::from_response::<
                        types::PolicyUpdateError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List built-in roles
    ///
    ///Sends a 'GET' request to '/roles'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn role_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<ResponseValue<types::RoleResultsPage>, Error<types::RoleListError>> {
        let url = format!("{}/roles", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "role_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RoleListError>::from_response::<types::RoleListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RoleListError>::from_response::<types::RoleListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List built-in roles as a Stream
    ///
    ///Sends repeated `GET` requests to `/roles` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn role_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
    ) -> impl futures::Stream<Item = Result<types::Role, Error<types::RoleListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.role_list(limit, None)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.role_list(limit, state.as_deref())
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a built-in role
    ///
    ///Sends a 'GET' request to '/roles/{role_name}'
    ///
    ///Arguments:
    /// - `role_name`: The built-in role's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn role_view<'a>(
        &'a self,
        role_name: &'a str,
    ) -> Result<ResponseValue<types::Role>, Error<types::RoleViewError>> {
        let url = format!(
            "{}/roles/{}",
            self.baseurl(),
            encode_path(&role_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "role_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RoleViewError>::from_response::<types::RoleViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RoleViewError>::from_response::<types::RoleViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch the user associated with the current session
    ///
    ///Sends a 'GET' request to '/session/me'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_me<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::User>, Error<types::SessionMeError>> {
        let url = format!("{}/session/me", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_me",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionMeError>::from_response::<types::SessionMeError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionMeError>::from_response::<types::SessionMeError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch the silogroups the current user belongs to
    ///
    ///Sends a 'GET' request to '/session/me/groups'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_me_groups<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::SessionMeGroupsError>> {
        let url = format!("{}/session/me/groups", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_me_groups",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionMeGroupsError>::from_response::<
                    types::SessionMeGroupsError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionMeGroupsError>::from_response::<
                    types::SessionMeGroupsError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch the silogroups the current user belongs to as a Stream
    ///
    ///Sends repeated `GET` requests to `/session/me/groups` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn session_me_groups_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Group, Error<types::SessionMeGroupsError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.session_me_groups(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.session_me_groups(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List SSH public keys
    ///
    ///Lists SSH public keys for the currently authenticated user.
    ///
    ///Sends a 'GET' request to '/session/me/sshkeys'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_sshkey_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::SshKeyResultsPage>, Error<types::SessionSshkeyListError>> {
        let url = format!("{}/session/me/sshkeys", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_sshkey_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyListError>::from_response::<
                    types::SessionSshkeyListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyListError>::from_response::<
                    types::SessionSshkeyListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List SSH public keys as a Stream
    ///
    ///Lists SSH public keys for the currently authenticated user.
    ///
    ///Sends repeated `GET` requests to `/session/me/sshkeys` until there are
    /// no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn session_sshkey_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::SshKey, Error<types::SessionSshkeyListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.session_sshkey_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.session_sshkey_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an SSH public key
    ///
    ///Create an SSH public key for the currently authenticated user.
    ///
    ///Sends a 'POST' request to '/session/me/sshkeys'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_sshkey_create<'a>(
        &'a self,
        body: &'a types::SshKeyCreate,
    ) -> Result<ResponseValue<types::SshKey>, Error<types::SessionSshkeyCreateError>> {
        let url = format!("{}/session/me/sshkeys", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_sshkey_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyCreateError>::from_response::<
                    types::SessionSshkeyCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyCreateError>::from_response::<
                    types::SessionSshkeyCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an SSH public key
    ///
    ///Fetch an SSH public key associated with the currently authenticated
    /// user.
    ///
    ///Sends a 'GET' request to '/session/me/sshkeys/{ssh_key_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_sshkey_view<'a>(
        &'a self,
        ssh_key_name: &'a types::Name,
    ) -> Result<ResponseValue<types::SshKey>, Error<types::SessionSshkeyViewError>> {
        let url = format!(
            "{}/session/me/sshkeys/{}",
            self.baseurl(),
            encode_path(&ssh_key_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_sshkey_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyViewError>::from_response::<
                    types::SessionSshkeyViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyViewError>::from_response::<
                    types::SessionSshkeyViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an SSH public key
    ///
    ///Delete an SSH public key associated with the currently authenticated
    /// user.
    ///
    ///Sends a 'DELETE' request to '/session/me/sshkeys/{ssh_key_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_sshkey_delete<'a>(
        &'a self,
        ssh_key_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::SessionSshkeyDeleteError>> {
        let url = format!(
            "{}/session/me/sshkeys/{}",
            self.baseurl(),
            encode_path(&ssh_key_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_sshkey_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyDeleteError>::from_response::<
                    types::SessionSshkeyDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyDeleteError>::from_response::<
                    types::SessionSshkeyDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a system-wide image by id
    ///
    ///Sends a 'GET' request to '/system/by-id/images/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_image_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::GlobalImage>, Error<types::SystemImageViewByIdError>> {
        let url = format!(
            "{}/system/by-id/images/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_image_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageViewByIdError>::from_response::<
                    types::SystemImageViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageViewByIdError>::from_response::<
                    types::SystemImageViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an IP pool by id
    ///
    ///Sends a 'GET' request to '/system/by-id/ip-pools/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::IpPool>, Error<types::IpPoolViewByIdError>> {
        let url = format!(
            "{}/system/by-id/ip-pools/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolViewByIdError>::from_response::<
                    types::IpPoolViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolViewByIdError>::from_response::<
                    types::IpPoolViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a silo by id
    ///
    ///Sends a 'GET' request to '/system/by-id/silos/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Silo>, Error<types::SiloViewByIdError>> {
        let url = format!(
            "{}/system/by-id/silos/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SiloViewByIdError>::from_response::<
                        types::SiloViewByIdError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SiloViewByIdError>::from_response::<
                        types::SiloViewByIdError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List system-wide certificates
    ///
    ///Returns a list of all the system-wide certificates. System-wide
    /// certificates are returned sorted by creation date, with the most recent
    /// certificates appearing first.
    ///
    ///Sends a 'GET' request to '/system/certificates'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn certificate_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::CertificateResultsPage>, Error<types::CertificateListError>>
    {
        let url = format!("{}/system/certificates", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "certificate_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateListError>::from_response::<
                    types::CertificateListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateListError>::from_response::<
                    types::CertificateListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List system-wide certificates as a Stream
    ///
    ///Returns a list of all the system-wide certificates. System-wide
    /// certificates are returned sorted by creation date, with the most recent
    /// certificates appearing first.
    ///
    ///Sends repeated `GET` requests to `/system/certificates` until there are
    /// no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn certificate_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Certificate, Error<types::CertificateListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.certificate_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.certificate_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a new system-wide x.509 certificate
    ///
    ///This certificate is automatically used by the Oxide Control plane to
    /// serve external connections.
    ///
    ///Sends a 'POST' request to '/system/certificates'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn certificate_create<'a>(
        &'a self,
        body: &'a types::CertificateCreate,
    ) -> Result<ResponseValue<types::Certificate>, Error<types::CertificateCreateError>> {
        let url = format!("{}/system/certificates", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "certificate_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateCreateError>::from_response::<
                    types::CertificateCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateCreateError>::from_response::<
                    types::CertificateCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a certificate
    ///
    ///Returns the details of a specific certificate
    ///
    ///Sends a 'GET' request to '/system/certificates/{certificate}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn certificate_view<'a>(
        &'a self,
        certificate: &'a types::NameOrId,
    ) -> Result<ResponseValue<types::Certificate>, Error<types::CertificateViewError>> {
        let url = format!(
            "{}/system/certificates/{}",
            self.baseurl(),
            encode_path(&certificate.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "certificate_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateViewError>::from_response::<
                    types::CertificateViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateViewError>::from_response::<
                    types::CertificateViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a certificate
    ///
    ///Permanently delete a certificate. This operation cannot be undone.
    ///
    ///Sends a 'DELETE' request to '/system/certificates/{certificate}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn certificate_delete<'a>(
        &'a self,
        certificate: &'a types::NameOrId,
    ) -> Result<ResponseValue<()>, Error<types::CertificateDeleteError>> {
        let url = format!(
            "{}/system/certificates/{}",
            self.baseurl(),
            encode_path(&certificate.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "certificate_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateDeleteError>::from_response::<
                    types::CertificateDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateDeleteError>::from_response::<
                    types::CertificateDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List physical disks
    ///
    ///Sends a 'GET' request to '/system/hardware/disks'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn physical_disk_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::PhysicalDiskResultsPage>, Error<types::PhysicalDiskListError>>
    {
        let url = format!("{}/system/hardware/disks", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "physical_disk_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::PhysicalDiskListError>::from_response::<
                    types::PhysicalDiskListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::PhysicalDiskListError>::from_response::<
                    types::PhysicalDiskListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List physical disks as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/hardware/disks` until there
    /// are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn physical_disk_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::PhysicalDisk, Error<types::PhysicalDiskListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.physical_disk_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.physical_disk_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List racks
    ///
    ///Sends a 'GET' request to '/system/hardware/racks'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn rack_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::RackResultsPage>, Error<types::RackListError>> {
        let url = format!("{}/system/hardware/racks", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "rack_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RackListError>::from_response::<types::RackListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RackListError>::from_response::<types::RackListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List racks as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/hardware/racks` until there
    /// are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn rack_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Rack, Error<types::RackListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.rack_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.rack_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a rack
    ///
    ///Sends a 'GET' request to '/system/hardware/racks/{rack_id}'
    ///
    ///Arguments:
    /// - `rack_id`: The rack's unique ID.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn rack_view<'a>(
        &'a self,
        rack_id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Rack>, Error<types::RackViewError>> {
        let url = format!(
            "{}/system/hardware/racks/{}",
            self.baseurl(),
            encode_path(&rack_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "rack_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RackViewError>::from_response::<types::RackViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RackViewError>::from_response::<types::RackViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List sleds
    ///
    ///Sends a 'GET' request to '/system/hardware/sleds'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn sled_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::SledResultsPage>, Error<types::SledListError>> {
        let url = format!("{}/system/hardware/sleds", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "sled_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledListError>::from_response::<types::SledListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledListError>::from_response::<types::SledListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List sleds as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/hardware/sleds` until there
    /// are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn sled_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Sled, Error<types::SledListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.sled_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.sled_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a sled
    ///
    ///Sends a 'GET' request to '/system/hardware/sleds/{sled_id}'
    ///
    ///Arguments:
    /// - `sled_id`: The sled's unique ID.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn sled_view<'a>(
        &'a self,
        sled_id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Sled>, Error<types::SledViewError>> {
        let url = format!(
            "{}/system/hardware/sleds/{}",
            self.baseurl(),
            encode_path(&sled_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "sled_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledViewError>::from_response::<types::SledViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledViewError>::from_response::<types::SledViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List physical disks attached to sleds
    ///
    ///Sends a 'GET' request to '/system/hardware/sleds/{sled_id}/disks'
    ///
    ///Arguments:
    /// - `sled_id`: The sled's unique ID.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn sled_physical_disk_list<'a>(
        &'a self,
        sled_id: &'a ::uuid::Uuid,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<
        ResponseValue<types::PhysicalDiskResultsPage>,
        Error<types::SledPhysicalDiskListError>,
    > {
        let url = format!(
            "{}/system/hardware/sleds/{}/disks",
            self.baseurl(),
            encode_path(&sled_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "sled_physical_disk_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledPhysicalDiskListError>::from_response::<
                    types::SledPhysicalDiskListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledPhysicalDiskListError>::from_response::<
                    types::SledPhysicalDiskListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List physical disks attached to sleds as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/system/hardware/sleds/{sled_id}/disks` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `sled_id`: The sled's unique ID.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn sled_physical_disk_list_stream<'a>(
        &'a self,
        sled_id: &'a ::uuid::Uuid,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::PhysicalDisk, Error<types::SledPhysicalDiskListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.sled_physical_disk_list(sled_id, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.sled_physical_disk_list(sled_id, limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List system-wide images
    ///
    ///Returns a list of all the system-wide images. System-wide images are
    /// returned sorted by creation date, with the most recent images appearing
    /// first.
    ///
    ///Sends a 'GET' request to '/system/images'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_image_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::GlobalImageResultsPage>, Error<types::SystemImageListError>>
    {
        let url = format!("{}/system/images", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_image_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageListError>::from_response::<
                    types::SystemImageListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageListError>::from_response::<
                    types::SystemImageListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List system-wide images as a Stream
    ///
    ///Returns a list of all the system-wide images. System-wide images are
    /// returned sorted by creation date, with the most recent images appearing
    /// first.
    ///
    ///Sends repeated `GET` requests to `/system/images` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn system_image_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::GlobalImage, Error<types::SystemImageListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.system_image_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.system_image_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a system-wide image
    ///
    ///Create a new system-wide image. This image can then be used by any user
    /// in any silo as a base for instances.
    ///
    ///Sends a 'POST' request to '/system/images'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_image_create<'a>(
        &'a self,
        body: &'a types::GlobalImageCreate,
    ) -> Result<ResponseValue<types::GlobalImage>, Error<types::SystemImageCreateError>> {
        let url = format!("{}/system/images", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_image_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageCreateError>::from_response::<
                    types::SystemImageCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageCreateError>::from_response::<
                    types::SystemImageCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a system-wide image
    ///
    ///Returns the details of a specific system-wide image.
    ///
    ///Sends a 'GET' request to '/system/images/{image_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_image_view<'a>(
        &'a self,
        image_name: &'a types::Name,
    ) -> Result<ResponseValue<types::GlobalImage>, Error<types::SystemImageViewError>> {
        let url = format!(
            "{}/system/images/{}",
            self.baseurl(),
            encode_path(&image_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_image_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageViewError>::from_response::<
                    types::SystemImageViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageViewError>::from_response::<
                    types::SystemImageViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a system-wide image
    ///
    ///Permanently delete a system-wide image. This operation cannot be undone.
    /// Any instances using the system-wide image will continue to run, however
    /// new instances can not be created with this image.
    ///
    ///Sends a 'DELETE' request to '/system/images/{image_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_image_delete<'a>(
        &'a self,
        image_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::SystemImageDeleteError>> {
        let url = format!(
            "{}/system/images/{}",
            self.baseurl(),
            encode_path(&image_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_image_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageDeleteError>::from_response::<
                    types::SystemImageDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageDeleteError>::from_response::<
                    types::SystemImageDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List IP pools
    ///
    ///Sends a 'GET' request to '/system/ip-pools'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::IpPoolResultsPage>, Error<types::IpPoolListError>> {
        let url = format!("{}/system/ip-pools", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolListError>::from_response::<types::IpPoolListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolListError>::from_response::<types::IpPoolListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List IP pools as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/ip-pools` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn ip_pool_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::IpPool, Error<types::IpPoolListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.ip_pool_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.ip_pool_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an IP pool
    ///
    ///Sends a 'POST' request to '/system/ip-pools'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_create<'a>(
        &'a self,
        body: &'a types::IpPoolCreate,
    ) -> Result<ResponseValue<types::IpPool>, Error<types::IpPoolCreateError>> {
        let url = format!("{}/system/ip-pools", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolCreateError>::from_response::<
                        types::IpPoolCreateError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolCreateError>::from_response::<
                        types::IpPoolCreateError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an IP pool
    ///
    ///Sends a 'GET' request to '/system/ip-pools/{pool_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_view<'a>(
        &'a self,
        pool_name: &'a types::Name,
    ) -> Result<ResponseValue<types::IpPool>, Error<types::IpPoolViewError>> {
        let url = format!(
            "{}/system/ip-pools/{}",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolViewError>::from_response::<types::IpPoolViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolViewError>::from_response::<types::IpPoolViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update an IP Pool
    ///
    ///Sends a 'PUT' request to '/system/ip-pools/{pool_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_update<'a>(
        &'a self,
        pool_name: &'a types::Name,
        body: &'a types::IpPoolUpdate,
    ) -> Result<ResponseValue<types::IpPool>, Error<types::IpPoolUpdateError>> {
        let url = format!(
            "{}/system/ip-pools/{}",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolUpdateError>::from_response::<
                        types::IpPoolUpdateError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolUpdateError>::from_response::<
                        types::IpPoolUpdateError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an IP Pool
    ///
    ///Sends a 'DELETE' request to '/system/ip-pools/{pool_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_delete<'a>(
        &'a self,
        pool_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::IpPoolDeleteError>> {
        let url = format!(
            "{}/system/ip-pools/{}",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolDeleteError>::from_response::<
                        types::IpPoolDeleteError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolDeleteError>::from_response::<
                        types::IpPoolDeleteError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List ranges for an IP pool
    ///
    ///Ranges are ordered by their first address.
    ///
    ///Sends a 'GET' request to '/system/ip-pools/{pool_name}/ranges'
    ///
    ///Arguments:
    /// - `pool_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_range_list<'a>(
        &'a self,
        pool_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<ResponseValue<types::IpPoolRangeResultsPage>, Error<types::IpPoolRangeListError>>
    {
        let url = format!(
            "{}/system/ip-pools/{}/ranges",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_range_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeListError>::from_response::<
                    types::IpPoolRangeListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeListError>::from_response::<
                    types::IpPoolRangeListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List ranges for an IP pool as a Stream
    ///
    ///Ranges are ordered by their first address.
    ///
    ///Sends repeated `GET` requests to `/system/ip-pools/{pool_name}/ranges`
    /// until there are no more results.
    ///
    ///Arguments:
    /// - `pool_name`
    /// - `limit`: Maximum number of items returned by a single call
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn ip_pool_range_list_stream<'a>(
        &'a self,
        pool_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
    ) -> impl futures::Stream<Item = Result<types::IpPoolRange, Error<types::IpPoolRangeListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.ip_pool_range_list(pool_name, limit, None)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.ip_pool_range_list(pool_name, limit, state.as_deref())
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Add a range to an IP pool
    ///
    ///Sends a 'POST' request to '/system/ip-pools/{pool_name}/ranges/add'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_range_add<'a>(
        &'a self,
        pool_name: &'a types::Name,
        body: &'a types::IpRange,
    ) -> Result<ResponseValue<types::IpPoolRange>, Error<types::IpPoolRangeAddError>> {
        let url = format!(
            "{}/system/ip-pools/{}/ranges/add",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_range_add",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeAddError>::from_response::<
                    types::IpPoolRangeAddError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeAddError>::from_response::<
                    types::IpPoolRangeAddError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Remove a range from an IP pool
    ///
    ///Sends a 'POST' request to '/system/ip-pools/{pool_name}/ranges/remove'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_range_remove<'a>(
        &'a self,
        pool_name: &'a types::Name,
        body: &'a types::IpRange,
    ) -> Result<ResponseValue<()>, Error<types::IpPoolRangeRemoveError>> {
        let url = format!(
            "{}/system/ip-pools/{}/ranges/remove",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_range_remove",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeRemoveError>::from_response::<
                    types::IpPoolRangeRemoveError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeRemoveError>::from_response::<
                    types::IpPoolRangeRemoveError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch the IP pool used for Oxide services
    ///
    ///Sends a 'GET' request to '/system/ip-pools-service'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_service_view<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::IpPool>, Error<types::IpPoolServiceViewError>> {
        let url = format!("{}/system/ip-pools-service", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_service_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceViewError>::from_response::<
                    types::IpPoolServiceViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceViewError>::from_response::<
                    types::IpPoolServiceViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List ranges for the IP pool used for Oxide services
    ///
    ///Ranges are ordered by their first address.
    ///
    ///Sends a 'GET' request to '/system/ip-pools-service/ranges'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_service_range_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::IpPoolRangeResultsPage>,
        Error<types::IpPoolServiceRangeListError>,
    > {
        let url = format!("{}/system/ip-pools-service/ranges", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_service_range_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeListError>::from_response::<
                    types::IpPoolServiceRangeListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeListError>::from_response::<
                    types::IpPoolServiceRangeListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List ranges for the IP pool used for Oxide services as a Stream
    ///
    ///Ranges are ordered by their first address.
    ///
    ///Sends repeated `GET` requests to `/system/ip-pools-service/ranges` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn ip_pool_service_range_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
    ) -> impl futures::Stream<
        Item = Result<types::IpPoolRange, Error<types::IpPoolServiceRangeListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.ip_pool_service_range_list(limit, None)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.ip_pool_service_range_list(limit, state.as_deref())
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Add a range to an IP pool used for Oxide services
    ///
    ///Sends a 'POST' request to '/system/ip-pools-service/ranges/add'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_service_range_add<'a>(
        &'a self,
        body: &'a types::IpRange,
    ) -> Result<ResponseValue<types::IpPoolRange>, Error<types::IpPoolServiceRangeAddError>> {
        let url = format!("{}/system/ip-pools-service/ranges/add", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_service_range_add",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeAddError>::from_response::<
                    types::IpPoolServiceRangeAddError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeAddError>::from_response::<
                    types::IpPoolServiceRangeAddError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Remove a range from an IP pool used for Oxide services
    ///
    ///Sends a 'POST' request to '/system/ip-pools-service/ranges/remove'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_service_range_remove<'a>(
        &'a self,
        body: &'a types::IpRange,
    ) -> Result<ResponseValue<()>, Error<types::IpPoolServiceRangeRemoveError>> {
        let url = format!("{}/system/ip-pools-service/ranges/remove", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_service_range_remove",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeRemoveError>::from_response::<
                    types::IpPoolServiceRangeRemoveError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeRemoveError>::from_response::<
                    types::IpPoolServiceRangeRemoveError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Access metrics data
    ///
    ///Sends a 'GET' request to '/system/metrics/{metric_name}'
    ///
    ///Arguments:
    /// - `metric_name`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `id`: The UUID of the container being queried
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `start_time`: An inclusive start time of metrics.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_metric<'a>(
        &'a self,
        metric_name: types::SystemMetricName,
        end_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
        id: &'a ::uuid::Uuid,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        start_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
    ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::SystemMetricError>> {
        let url = format!(
            "{}/system/metrics/{}",
            self.baseurl(),
            encode_path(&metric_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("end_time", &end_time))
            .query(&progenitor_client::QueryParam::new("id", &id))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new(
                "start_time",
                &start_time,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_metric",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SystemMetricError>::from_response::<
                        types::SystemMetricError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SystemMetricError>::from_response::<
                        types::SystemMetricError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch the top-level IAM policy
    ///
    ///Sends a 'GET' request to '/system/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_policy_view<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::SystemPolicyViewError>> {
        let url = format!("{}/system/policy", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_policy_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemPolicyViewError>::from_response::<
                    types::SystemPolicyViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemPolicyViewError>::from_response::<
                    types::SystemPolicyViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update the top-level IAM policy
    ///
    ///Sends a 'PUT' request to '/system/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_policy_update<'a>(
        &'a self,
        body: &'a types::FleetRolePolicy,
    ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::SystemPolicyUpdateError>> {
        let url = format!("{}/system/policy", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_policy_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemPolicyUpdateError>::from_response::<
                    types::SystemPolicyUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemPolicyUpdateError>::from_response::<
                    types::SystemPolicyUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List sagas
    ///
    ///Sends a 'GET' request to '/system/sagas'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn saga_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::SagaResultsPage>, Error<types::SagaListError>> {
        let url = format!("{}/system/sagas", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "saga_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SagaListError>::from_response::<types::SagaListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SagaListError>::from_response::<types::SagaListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List sagas as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/sagas` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn saga_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Saga, Error<types::SagaListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.saga_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.saga_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a saga
    ///
    ///Sends a 'GET' request to '/system/sagas/{saga_id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn saga_view<'a>(
        &'a self,
        saga_id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Saga>, Error<types::SagaViewError>> {
        let url = format!(
            "{}/system/sagas/{}",
            self.baseurl(),
            encode_path(&saga_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "saga_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SagaViewError>::from_response::<types::SagaViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SagaViewError>::from_response::<types::SagaViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List silos
    ///
    ///Lists silos that are discoverable based on the current permissions.
    ///
    ///Sends a 'GET' request to '/system/silos'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::SiloResultsPage>, Error<types::SiloListError>> {
        let url = format!("{}/system/silos", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloListError>::from_response::<types::SiloListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloListError>::from_response::<types::SiloListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List silos as a Stream
    ///
    ///Lists silos that are discoverable based on the current permissions.
    ///
    ///Sends repeated `GET` requests to `/system/silos` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn silo_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Silo, Error<types::SiloListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.silo_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.silo_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a silo
    ///
    ///Sends a 'POST' request to '/system/silos'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_create<'a>(
        &'a self,
        body: &'a types::SiloCreate,
    ) -> Result<ResponseValue<types::Silo>, Error<types::SiloCreateError>> {
        let url = format!("{}/system/silos", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloCreateError>::from_response::<types::SiloCreateError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloCreateError>::from_response::<types::SiloCreateError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a silo
    ///
    ///Fetch a silo by name.
    ///
    ///Sends a 'GET' request to '/system/silos/{silo_name}'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_view<'a>(
        &'a self,
        silo_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Silo>, Error<types::SiloViewError>> {
        let url = format!(
            "{}/system/silos/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloViewError>::from_response::<types::SiloViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloViewError>::from_response::<types::SiloViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a silo
    ///
    ///Delete a silo by name.
    ///
    ///Sends a 'DELETE' request to '/system/silos/{silo_name}'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_delete<'a>(
        &'a self,
        silo_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::SiloDeleteError>> {
        let url = format!(
            "{}/system/silos/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloDeleteError>::from_response::<types::SiloDeleteError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloDeleteError>::from_response::<types::SiloDeleteError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List a silo's IDPs
    ///
    ///Sends a 'GET' request to '/system/silos/{silo_name}/identity-providers'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_identity_provider_list<'a>(
        &'a self,
        silo_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<
        ResponseValue<types::IdentityProviderResultsPage>,
        Error<types::SiloIdentityProviderListError>,
    > {
        let url = format!(
            "{}/system/silos/{}/identity-providers",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_identity_provider_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloIdentityProviderListError>::from_response::<
                    types::SiloIdentityProviderListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloIdentityProviderListError>::from_response::<
                    types::SiloIdentityProviderListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List a silo's IDPs as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/system/silos/{silo_name}/identity-providers` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn silo_identity_provider_list_stream<'a>(
        &'a self,
        silo_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::IdentityProvider, Error<types::SiloIdentityProviderListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.silo_identity_provider_list(silo_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.silo_identity_provider_list(silo_name, limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a user
    ///
    ///Users can only be created in Silos with `provision_type` == `Fixed`.
    /// Otherwise, Silo users are just-in-time (JIT) provisioned when a user
    /// first logs in using an external Identity Provider.
    ///
    ///Sends a 'POST' request to
    /// '/system/silos/{silo_name}/identity-providers/local/users'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn local_idp_user_create<'a>(
        &'a self,
        silo_name: &'a types::Name,
        body: &'a types::UserCreate,
    ) -> Result<ResponseValue<types::User>, Error<types::LocalIdpUserCreateError>> {
        let url = format!(
            "{}/system/silos/{}/identity-providers/local/users",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "local_idp_user_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserCreateError>::from_response::<
                    types::LocalIdpUserCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserCreateError>::from_response::<
                    types::LocalIdpUserCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a user
    ///
    ///Sends a 'DELETE' request to
    /// '/system/silos/{silo_name}/identity-providers/local/users/{user_id}'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `user_id`: The user's internal id
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn local_idp_user_delete<'a>(
        &'a self,
        silo_name: &'a types::Name,
        user_id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<()>, Error<types::LocalIdpUserDeleteError>> {
        let url = format!(
            "{}/system/silos/{}/identity-providers/local/users/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "local_idp_user_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserDeleteError>::from_response::<
                    types::LocalIdpUserDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserDeleteError>::from_response::<
                    types::LocalIdpUserDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Set or invalidate a user's password
    ///
    ///Passwords can only be updated for users in Silos with identity mode
    /// `LocalOnly`.
    ///
    ///Sends a 'POST' request to
    /// '/system/silos/{silo_name}/identity-providers/local/users/{user_id}/
    /// set-password'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `user_id`: The user's internal id
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn local_idp_user_set_password<'a>(
        &'a self,
        silo_name: &'a types::Name,
        user_id: &'a ::uuid::Uuid,
        body: &'a types::UserPassword,
    ) -> Result<ResponseValue<()>, Error<types::LocalIdpUserSetPasswordError>> {
        let url = format!(
            "{}/system/silos/{}/identity-providers/local/users/{}/set-password",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "local_idp_user_set_password",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserSetPasswordError>::from_response::<
                    types::LocalIdpUserSetPasswordError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserSetPasswordError>::from_response::<
                    types::LocalIdpUserSetPasswordError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Create a SAML IDP
    ///
    ///Sends a 'POST' request to
    /// '/system/silos/{silo_name}/identity-providers/saml'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn saml_identity_provider_create<'a>(
        &'a self,
        silo_name: &'a types::Name,
        body: &'a types::SamlIdentityProviderCreate,
    ) -> Result<
        ResponseValue<types::SamlIdentityProvider>,
        Error<types::SamlIdentityProviderCreateError>,
    > {
        let url = format!(
            "{}/system/silos/{}/identity-providers/saml",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "saml_identity_provider_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SamlIdentityProviderCreateError>::from_response::<
                    types::SamlIdentityProviderCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SamlIdentityProviderCreateError>::from_response::<
                    types::SamlIdentityProviderCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a SAML IDP
    ///
    ///Sends a 'GET' request to
    /// '/system/silos/{silo_name}/identity-providers/saml/{provider_name}'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `provider_name`: The SAML identity provider's name
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn saml_identity_provider_view<'a>(
        &'a self,
        silo_name: &'a types::Name,
        provider_name: &'a types::Name,
    ) -> Result<
        ResponseValue<types::SamlIdentityProvider>,
        Error<types::SamlIdentityProviderViewError>,
    > {
        let url = format!(
            "{}/system/silos/{}/identity-providers/saml/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&provider_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "saml_identity_provider_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SamlIdentityProviderViewError>::from_response::<
                    types::SamlIdentityProviderViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SamlIdentityProviderViewError>::from_response::<
                    types::SamlIdentityProviderViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a silo's IAM policy
    ///
    ///Sends a 'GET' request to '/system/silos/{silo_name}/policy'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_policy_view<'a>(
        &'a self,
        silo_name: &'a types::Name,
    ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::SiloPolicyViewError>> {
        let url = format!(
            "{}/system/silos/{}/policy",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_policy_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloPolicyViewError>::from_response::<
                    types::SiloPolicyViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloPolicyViewError>::from_response::<
                    types::SiloPolicyViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a silo's IAM policy
    ///
    ///Sends a 'PUT' request to '/system/silos/{silo_name}/policy'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_policy_update<'a>(
        &'a self,
        silo_name: &'a types::Name,
        body: &'a types::SiloRolePolicy,
    ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::SiloPolicyUpdateError>> {
        let url = format!(
            "{}/system/silos/{}/policy",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_policy_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloPolicyUpdateError>::from_response::<
                    types::SiloPolicyUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloPolicyUpdateError>::from_response::<
                    types::SiloPolicyUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List users in a silo
    ///
    ///Sends a 'GET' request to '/system/silos/{silo_name}/users/all'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_users_list<'a>(
        &'a self,
        silo_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::SiloUsersListError>> {
        let url = format!(
            "{}/system/silos/{}/users/all",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_users_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloUsersListError>::from_response::<
                    types::SiloUsersListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloUsersListError>::from_response::<
                    types::SiloUsersListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List users in a silo as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/silos/{silo_name}/users/all`
    /// until there are no more results.
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn silo_users_list_stream<'a>(
        &'a self,
        silo_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::User, Error<types::SiloUsersListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.silo_users_list(silo_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.silo_users_list(silo_name, limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a user
    ///
    ///Sends a 'GET' request to '/system/silos/{silo_name}/users/id/{user_id}'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `user_id`: The user's internal id
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_user_view<'a>(
        &'a self,
        silo_name: &'a types::Name,
        user_id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::User>, Error<types::SiloUserViewError>> {
        let url = format!(
            "{}/system/silos/{}/users/id/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_user_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SiloUserViewError>::from_response::<
                        types::SiloUserViewError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SiloUserViewError>::from_response::<
                        types::SiloUserViewError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List built-in users
    ///
    ///Sends a 'GET' request to '/system/user'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_user_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::UserBuiltinResultsPage>, Error<types::SystemUserListError>>
    {
        let url = format!("{}/system/user", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_user_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUserListError>::from_response::<
                    types::SystemUserListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUserListError>::from_response::<
                    types::SystemUserListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List built-in users as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/user` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn system_user_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::UserBuiltin, Error<types::SystemUserListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.system_user_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.system_user_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a built-in user
    ///
    ///Sends a 'GET' request to '/system/user/{user_name}'
    ///
    ///Arguments:
    /// - `user_name`: The built-in user's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_user_view<'a>(
        &'a self,
        user_name: &'a types::Name,
    ) -> Result<ResponseValue<types::UserBuiltin>, Error<types::SystemUserViewError>> {
        let url = format!(
            "{}/system/user/{}",
            self.baseurl(),
            encode_path(&user_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_user_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUserViewError>::from_response::<
                    types::SystemUserViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUserViewError>::from_response::<
                    types::SystemUserViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List timeseries schema
    ///
    ///Sends a 'GET' request to '/timeseries/schema'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn timeseries_schema_get<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::TimeseriesSchemaResultsPage>,
        Error<types::TimeseriesSchemaGetError>,
    > {
        let url = format!("{}/timeseries/schema", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "timeseries_schema_get",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::TimeseriesSchemaGetError>::from_response::<
                    types::TimeseriesSchemaGetError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::TimeseriesSchemaGetError>::from_response::<
                    types::TimeseriesSchemaGetError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List timeseries schema as a Stream
    ///
    ///Sends repeated `GET` requests to `/timeseries/schema` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn timeseries_schema_get_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
    ) -> impl futures::Stream<
        Item = Result<types::TimeseriesSchema, Error<types::TimeseriesSchemaGetError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.timeseries_schema_get(limit, None)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.timeseries_schema_get(limit, state.as_deref())
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List users
    ///
    ///Sends a 'GET' request to '/users'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn user_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::UserListError>> {
        let url = format!("{}/users", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "user_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UserListError>::from_response::<types::UserListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UserListError>::from_response::<types::UserListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List users as a Stream
    ///
    ///Sends repeated `GET` requests to `/users` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn user_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::User, Error<types::UserListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.user_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.user_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List disks
    ///
    ///Sends a 'GET' request to '/v1/disks'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_list_v1<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        page_token: Option<&'a str>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::DiskListV1Error>> {
        let url = format!("{}/v1/disks", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_list_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskListV1Error>::from_response::<types::DiskListV1Error>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskListV1Error>::from_response::<types::DiskListV1Error>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List disks as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/disks` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn disk_list_v1_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::DiskListV1Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.disk_list_v1(limit, organization, None, project, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.disk_list_v1(limit, None, state.as_deref(), None, None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a disk
    ///
    ///Sends a 'POST' request to '/v1/disks'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_create_v1<'a>(
        &'a self,
        organization: Option<&'a types::NameOrId>,
        project: &'a types::NameOrId,
        body: &'a types::DiskCreate,
    ) -> Result<ResponseValue<types::Disk>, Error<types::DiskCreateV1Error>> {
        let url = format!("{}/v1/disks", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_create_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskCreateV1Error>::from_response::<
                        types::DiskCreateV1Error,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskCreateV1Error>::from_response::<
                        types::DiskCreateV1Error,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a disk
    ///
    ///Sends a 'GET' request to '/v1/disks/{disk}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_view_v1<'a>(
        &'a self,
        disk: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Disk>, Error<types::DiskViewV1Error>> {
        let url = format!(
            "{}/v1/disks/{}",
            self.baseurl(),
            encode_path(&disk.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskViewV1Error>::from_response::<types::DiskViewV1Error>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskViewV1Error>::from_response::<types::DiskViewV1Error>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a disk
    ///
    ///Sends a 'DELETE' request to '/v1/disks/{disk}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_delete_v1<'a>(
        &'a self,
        disk: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<()>, Error<types::DiskDeleteV1Error>> {
        let url = format!(
            "{}/v1/disks/{}",
            self.baseurl(),
            encode_path(&disk.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_delete_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskDeleteV1Error>::from_response::<
                        types::DiskDeleteV1Error,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskDeleteV1Error>::from_response::<
                        types::DiskDeleteV1Error,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List instances
    ///
    ///Sends a 'GET' request to '/v1/instances'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_list_v1<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        page_token: Option<&'a str>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::InstanceListV1Error>> {
        let url = format!("{}/v1/instances", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_list_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceListV1Error>::from_response::<
                    types::InstanceListV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceListV1Error>::from_response::<
                    types::InstanceListV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List instances as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/instances` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn instance_list_v1_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::InstanceListV1Error>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_list_v1(limit, organization, None, project, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.instance_list_v1(limit, None, state.as_deref(), None, None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an instance
    ///
    ///Sends a 'POST' request to '/v1/instances'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_create_v1<'a>(
        &'a self,
        organization: Option<&'a types::NameOrId>,
        project: &'a types::NameOrId,
        body: &'a types::InstanceCreate,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceCreateV1Error>> {
        let url = format!("{}/v1/instances", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_create_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceCreateV1Error>::from_response::<
                    types::InstanceCreateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceCreateV1Error>::from_response::<
                    types::InstanceCreateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an instance
    ///
    ///Sends a 'GET' request to '/v1/instances/{instance}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_view_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceViewV1Error>> {
        let url = format!(
            "{}/v1/instances/{}",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceViewV1Error>::from_response::<
                    types::InstanceViewV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceViewV1Error>::from_response::<
                    types::InstanceViewV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an instance
    ///
    ///Sends a 'DELETE' request to '/v1/instances/{instance}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_delete_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<()>, Error<types::InstanceDeleteV1Error>> {
        let url = format!(
            "{}/v1/instances/{}",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_delete_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDeleteV1Error>::from_response::<
                    types::InstanceDeleteV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDeleteV1Error>::from_response::<
                    types::InstanceDeleteV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List an instance's disks
    ///
    ///Sends a 'GET' request to '/v1/instances/{instance}/disks'
    ///
    ///Arguments:
    /// - `instance`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_list_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        page_token: Option<&'a str>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::InstanceDiskListV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/disks",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_list_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskListV1Error>::from_response::<
                    types::InstanceDiskListV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskListV1Error>::from_response::<
                    types::InstanceDiskListV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List an instance's disks as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/instances/{instance}/disks` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `instance`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn instance_disk_list_v1_stream<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::InstanceDiskListV1Error>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_disk_list_v1(instance, limit, organization, None, project, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.instance_disk_list_v1(
                            instance,
                            limit,
                            None,
                            state.as_deref(),
                            None,
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Attach a disk to an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/disks/attach'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_attach_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        body: &'a types::DiskPath,
    ) -> Result<ResponseValue<types::Disk>, Error<types::InstanceDiskAttachV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/disks/attach",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_attach_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskAttachV1Error>::from_response::<
                    types::InstanceDiskAttachV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskAttachV1Error>::from_response::<
                    types::InstanceDiskAttachV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Detach a disk from an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/disks/detach'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_detach_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        body: &'a types::DiskPath,
    ) -> Result<ResponseValue<types::Disk>, Error<types::InstanceDiskDetachV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/disks/detach",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_detach_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskDetachV1Error>::from_response::<
                    types::InstanceDiskDetachV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskDetachV1Error>::from_response::<
                    types::InstanceDiskDetachV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Migrate an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/migrate'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_migrate_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        body: &'a types::InstanceMigrate,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceMigrateV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/migrate",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_migrate_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceMigrateV1Error>::from_response::<
                    types::InstanceMigrateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceMigrateV1Error>::from_response::<
                    types::InstanceMigrateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Reboot an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/reboot'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_reboot_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceRebootV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/reboot",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_reboot_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceRebootV1Error>::from_response::<
                    types::InstanceRebootV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceRebootV1Error>::from_response::<
                    types::InstanceRebootV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an instance's serial console
    ///
    ///Sends a 'GET' request to '/v1/instances/{instance}/serial-console'
    ///
    ///Arguments:
    /// - `instance`
    /// - `from_start`: Character index in the serial buffer from which to read,
    ///   counting the bytes output since instance start. If this is not
    ///   provided, `most_recent` must be provided, and if this *is* provided,
    ///   `most_recent` must *not* be provided.
    /// - `max_bytes`: Maximum number of bytes of buffered serial console
    ///   contents to return. If the requested range runs to the end of the
    ///   available buffer, the data returned will be shorter than `max_bytes`.
    /// - `most_recent`: Character index in the serial buffer from which to
    ///   read, counting *backward* from the most recently buffered data
    ///   retrieved from the instance. (See note on `from_start` about mutual
    ///   exclusivity)
    /// - `organization`
    /// - `project`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_serial_console_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        from_start: Option<u64>,
        max_bytes: Option<u64>,
        most_recent: Option<u64>,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<
        ResponseValue<types::InstanceSerialConsoleData>,
        Error<types::InstanceSerialConsoleV1Error>,
    > {
        let url = format!(
            "{}/v1/instances/{}/serial-console",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "from_start",
                &from_start,
            ))
            .query(&progenitor_client::QueryParam::new("max_bytes", &max_bytes))
            .query(&progenitor_client::QueryParam::new(
                "most_recent",
                &most_recent,
            ))
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_serial_console_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceSerialConsoleV1Error>::from_response::<
                    types::InstanceSerialConsoleV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceSerialConsoleV1Error>::from_response::<
                    types::InstanceSerialConsoleV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Stream an instance's serial console
    ///
    ///Sends a 'GET' request to
    /// '/v1/instances/{instance}/serial-console/stream'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_serial_console_stream_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<reqwest::Upgraded>, Error<()>> {
        let url = format!(
            "{}/v1/instances/{}/serial-console/stream",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .header(::reqwest::header::CONNECTION, "Upgrade")
            .header(::reqwest::header::UPGRADE, "websocket")
            .header(::reqwest::header::SEC_WEBSOCKET_VERSION, "13")
            .header(
                ::reqwest::header::SEC_WEBSOCKET_KEY,
                ::base64::Engine::encode(
                    &::base64::engine::general_purpose::STANDARD,
                    ::rand::random::<[u8; 16]>(),
                ),
            )
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_serial_console_stream_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            101u16 => ResponseValue::upgrade(response).await,
            200..=299 => ResponseValue::upgrade(response).await,
            _ => Err(Error::ErrorResponse(ResponseValue::empty(response))),
        }
    }

    ///Boot an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/start'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_start_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceStartV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/start",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_start_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStartV1Error>::from_response::<
                    types::InstanceStartV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStartV1Error>::from_response::<
                    types::InstanceStartV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Stop an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/stop'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_stop_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceStopV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/stop",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_stop_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStopV1Error>::from_response::<
                    types::InstanceStopV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStopV1Error>::from_response::<
                    types::InstanceStopV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List organizations
    ///
    ///Sends a 'GET' request to '/v1/organizations'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_list_v1<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::OrganizationResultsPage>, Error<types::OrganizationListV1Error>>
    {
        let url = format!("{}/v1/organizations", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_list_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationListV1Error>::from_response::<
                    types::OrganizationListV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationListV1Error>::from_response::<
                    types::OrganizationListV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List organizations as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/organizations` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn organization_list_v1_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::Organization, Error<types::OrganizationListV1Error>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.organization_list_v1(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.organization_list_v1(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an organization
    ///
    ///Sends a 'POST' request to '/v1/organizations'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_create_v1<'a>(
        &'a self,
        body: &'a types::OrganizationCreate,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationCreateV1Error>> {
        let url = format!("{}/v1/organizations", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_create_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationCreateV1Error>::from_response::<
                    types::OrganizationCreateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationCreateV1Error>::from_response::<
                    types::OrganizationCreateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an organization
    ///
    ///Sends a 'GET' request to '/v1/organizations/{organization}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_view_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationViewV1Error>> {
        let url = format!(
            "{}/v1/organizations/{}",
            self.baseurl(),
            encode_path(&organization.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewV1Error>::from_response::<
                    types::OrganizationViewV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewV1Error>::from_response::<
                    types::OrganizationViewV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update an organization
    ///
    ///Sends a 'PUT' request to '/v1/organizations/{organization}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_update_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
        body: &'a types::OrganizationUpdate,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationUpdateV1Error>> {
        let url = format!(
            "{}/v1/organizations/{}",
            self.baseurl(),
            encode_path(&organization.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_update_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationUpdateV1Error>::from_response::<
                    types::OrganizationUpdateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationUpdateV1Error>::from_response::<
                    types::OrganizationUpdateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an organization
    ///
    ///Sends a 'DELETE' request to '/v1/organizations/{organization}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_delete_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
    ) -> Result<ResponseValue<()>, Error<types::OrganizationDeleteV1Error>> {
        let url = format!(
            "{}/v1/organizations/{}",
            self.baseurl(),
            encode_path(&organization.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_delete_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationDeleteV1Error>::from_response::<
                    types::OrganizationDeleteV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationDeleteV1Error>::from_response::<
                    types::OrganizationDeleteV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an organization's IAM policy
    ///
    ///Sends a 'GET' request to '/v1/organizations/{organization}/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_policy_view_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
    ) -> Result<
        ResponseValue<types::OrganizationRolePolicy>,
        Error<types::OrganizationPolicyViewV1Error>,
    > {
        let url = format!(
            "{}/v1/organizations/{}/policy",
            self.baseurl(),
            encode_path(&organization.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_policy_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyViewV1Error>::from_response::<
                    types::OrganizationPolicyViewV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyViewV1Error>::from_response::<
                    types::OrganizationPolicyViewV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update an organization's IAM policy
    ///
    ///Sends a 'PUT' request to '/v1/organizations/{organization}/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_policy_update_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
        body: &'a types::OrganizationRolePolicy,
    ) -> Result<
        ResponseValue<types::OrganizationRolePolicy>,
        Error<types::OrganizationPolicyUpdateV1Error>,
    > {
        let url = format!(
            "{}/v1/organizations/{}/policy",
            self.baseurl(),
            encode_path(&organization.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_policy_update_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyUpdateV1Error>::from_response::<
                    types::OrganizationPolicyUpdateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyUpdateV1Error>::from_response::<
                    types::OrganizationPolicyUpdateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List projects
    ///
    ///Sends a 'GET' request to '/v1/projects'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_list_v1<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::ProjectListV1Error>> {
        let url = format!("{}/v1/projects", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_list_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectListV1Error>::from_response::<
                    types::ProjectListV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectListV1Error>::from_response::<
                    types::ProjectListV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List projects as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/projects` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn project_list_v1_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Project, Error<types::ProjectListV1Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_list_v1(limit, organization, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_list_v1(limit, None, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a project
    ///
    ///Sends a 'POST' request to '/v1/projects'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_create_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
        body: &'a types::ProjectCreate,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectCreateV1Error>> {
        let url = format!("{}/v1/projects", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_create_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectCreateV1Error>::from_response::<
                    types::ProjectCreateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectCreateV1Error>::from_response::<
                    types::ProjectCreateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a project
    ///
    ///Sends a 'GET' request to '/v1/projects/{project}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_view_v1<'a>(
        &'a self,
        project: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectViewV1Error>> {
        let url = format!(
            "{}/v1/projects/{}",
            self.baseurl(),
            encode_path(&project.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewV1Error>::from_response::<
                    types::ProjectViewV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewV1Error>::from_response::<
                    types::ProjectViewV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a project
    ///
    ///Sends a 'PUT' request to '/v1/projects/{project}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_update_v1<'a>(
        &'a self,
        project: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        body: &'a types::ProjectUpdate,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectUpdateV1Error>> {
        let url = format!(
            "{}/v1/projects/{}",
            self.baseurl(),
            encode_path(&project.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_update_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectUpdateV1Error>::from_response::<
                    types::ProjectUpdateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectUpdateV1Error>::from_response::<
                    types::ProjectUpdateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a project
    ///
    ///Sends a 'DELETE' request to '/v1/projects/{project}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_delete_v1<'a>(
        &'a self,
        project: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<()>, Error<types::ProjectDeleteV1Error>> {
        let url = format!(
            "{}/v1/projects/{}",
            self.baseurl(),
            encode_path(&project.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_delete_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectDeleteV1Error>::from_response::<
                    types::ProjectDeleteV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectDeleteV1Error>::from_response::<
                    types::ProjectDeleteV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a project's IAM policy
    ///
    ///Sends a 'GET' request to '/v1/projects/{project}/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_policy_view_v1<'a>(
        &'a self,
        project: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::ProjectPolicyViewV1Error>>
    {
        let url = format!(
            "{}/v1/projects/{}/policy",
            self.baseurl(),
            encode_path(&project.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_policy_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyViewV1Error>::from_response::<
                    types::ProjectPolicyViewV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyViewV1Error>::from_response::<
                    types::ProjectPolicyViewV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a project's IAM policy
    ///
    ///Sends a 'PUT' request to '/v1/projects/{project}/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_policy_update_v1<'a>(
        &'a self,
        project: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        body: &'a types::ProjectRolePolicy,
    ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::ProjectPolicyUpdateV1Error>>
    {
        let url = format!(
            "{}/v1/projects/{}/policy",
            self.baseurl(),
            encode_path(&project.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_policy_update_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyUpdateV1Error>::from_response::<
                    types::ProjectPolicyUpdateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyUpdateV1Error>::from_response::<
                    types::ProjectPolicyUpdateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///View version and update status of component tree
    ///
    ///Sends a 'GET' request to '/v1/system/update/components'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_component_version_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<
        ResponseValue<types::UpdateableComponentResultsPage>,
        Error<types::SystemComponentVersionListError>,
    > {
        let url = format!("{}/v1/system/update/components", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_component_version_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemComponentVersionListError>::from_response::<
                    types::SystemComponentVersionListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemComponentVersionListError>::from_response::<
                    types::SystemComponentVersionListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///View version and update status of component tree as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/system/update/components` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn system_component_version_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::UpdateableComponent, Error<types::SystemComponentVersionListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.system_component_version_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.system_component_version_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List all update deployments
    ///
    ///Sends a 'GET' request to '/v1/system/update/deployments'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn update_deployments_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<
        ResponseValue<types::UpdateDeploymentResultsPage>,
        Error<types::UpdateDeploymentsListError>,
    > {
        let url = format!("{}/v1/system/update/deployments", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_deployments_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UpdateDeploymentsListError>::from_response::<
                    types::UpdateDeploymentsListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UpdateDeploymentsListError>::from_response::<
                    types::UpdateDeploymentsListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List all update deployments as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/system/update/deployments` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn update_deployments_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::UpdateDeployment, Error<types::UpdateDeploymentsListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.update_deployments_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.update_deployments_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a system update deployment
    ///
    ///Sends a 'GET' request to '/v1/system/update/deployments/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn update_deployment_view<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::UpdateDeployment>, Error<types::UpdateDeploymentViewError>>
    {
        let url = format!(
            "{}/v1/system/update/deployments/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_deployment_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UpdateDeploymentViewError>::from_response::<
                    types::UpdateDeploymentViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UpdateDeploymentViewError>::from_response::<
                    types::UpdateDeploymentViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Refresh update data
    ///
    ///Sends a 'POST' request to '/v1/system/update/refresh'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_refresh<'a>(
        &'a self,
    ) -> Result<ResponseValue<()>, Error<types::SystemUpdateRefreshError>> {
        let url = format!("{}/v1/system/update/refresh", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_refresh",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateRefreshError>::from_response::<
                    types::SystemUpdateRefreshError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateRefreshError>::from_response::<
                    types::SystemUpdateRefreshError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Start system update
    ///
    ///Sends a 'POST' request to '/v1/system/update/start'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_start<'a>(
        &'a self,
        body: &'a types::SystemUpdateStart,
    ) -> Result<ResponseValue<types::UpdateDeployment>, Error<types::SystemUpdateStartError>> {
        let url = format!("{}/v1/system/update/start", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_start",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateStartError>::from_response::<
                    types::SystemUpdateStartError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateStartError>::from_response::<
                    types::SystemUpdateStartError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Stop system update
    ///
    ///If there is no update in progress, do nothing.
    ///
    ///Sends a 'POST' request to '/v1/system/update/stop'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_stop<'a>(
        &'a self,
    ) -> Result<ResponseValue<()>, Error<types::SystemUpdateStopError>> {
        let url = format!("{}/v1/system/update/stop", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_stop",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateStopError>::from_response::<
                    types::SystemUpdateStopError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateStopError>::from_response::<
                    types::SystemUpdateStopError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List all updates
    ///
    ///Sends a 'GET' request to '/v1/system/update/updates'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::SystemUpdateResultsPage>, Error<types::SystemUpdateListError>>
    {
        let url = format!("{}/v1/system/update/updates", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateListError>::from_response::<
                    types::SystemUpdateListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateListError>::from_response::<
                    types::SystemUpdateListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List all updates as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/system/update/updates` until there
    /// are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn system_update_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::SystemUpdate, Error<types::SystemUpdateListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.system_update_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.system_update_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///View system update
    ///
    ///Sends a 'GET' request to '/v1/system/update/updates/{version}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_view<'a>(
        &'a self,
        version: &'a types::SemverVersion,
    ) -> Result<ResponseValue<types::SystemUpdate>, Error<types::SystemUpdateViewError>> {
        let url = format!(
            "{}/v1/system/update/updates/{}",
            self.baseurl(),
            encode_path(&version.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateViewError>::from_response::<
                    types::SystemUpdateViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateViewError>::from_response::<
                    types::SystemUpdateViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///View system update component tree
    ///
    ///Sends a 'GET' request to
    /// '/v1/system/update/updates/{version}/components'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_components_list<'a>(
        &'a self,
        version: &'a types::SemverVersion,
    ) -> Result<
        ResponseValue<types::ComponentUpdateResultsPage>,
        Error<types::SystemUpdateComponentsListError>,
    > {
        let url = format!(
            "{}/v1/system/update/updates/{}/components",
            self.baseurl(),
            encode_path(&version.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_components_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateComponentsListError>::from_response::<
                    types::SystemUpdateComponentsListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateComponentsListError>::from_response::<
                    types::SystemUpdateComponentsListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///View system version and update status
    ///
    ///Sends a 'GET' request to '/v1/system/update/version'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_version<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::SystemVersion>, Error<types::SystemVersionError>> {
        let url = format!("{}/v1/system/update/version", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_version",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemVersionError>::from_response::<
                    types::SystemVersionError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemVersionError>::from_response::<
                    types::SystemVersionError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }
}

#[cfg(feature = "middleware")]
#[allow(clippy::all)]
#[allow(mismatched_lifetime_syntaxes)]
impl MiddlewareClient {
    ///Fetch a disk by id
    ///
    ///Use `GET /v1/disks/{disk}` instead
    ///
    ///Sends a 'GET' request to '/by-id/disks/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Disk>, Error<types::DiskViewByIdError>> {
        let url = format!(
            "{}/by-id/disks/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskViewByIdError>::from_response::<
                        types::DiskViewByIdError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskViewByIdError>::from_response::<
                        types::DiskViewByIdError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an image by id
    ///
    ///Sends a 'GET' request to '/by-id/images/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn image_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Image>, Error<types::ImageViewByIdError>> {
        let url = format!(
            "{}/by-id/images/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "image_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageViewByIdError>::from_response::<
                    types::ImageViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageViewByIdError>::from_response::<
                    types::ImageViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an instance by id
    ///
    ///Sends a 'GET' request to '/by-id/instances/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceViewByIdError>> {
        let url = format!(
            "{}/by-id/instances/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceViewByIdError>::from_response::<
                    types::InstanceViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceViewByIdError>::from_response::<
                    types::InstanceViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a network interface by id
    ///
    ///Sends a 'GET' request to '/by-id/network-interfaces/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<
        ResponseValue<types::NetworkInterface>,
        Error<types::InstanceNetworkInterfaceViewByIdError>,
    > {
        let url = format!(
            "{}/by-id/network-interfaces/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceViewByIdError>::from_response::<
                    types::InstanceNetworkInterfaceViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceViewByIdError>::from_response::<
                    types::InstanceNetworkInterfaceViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an organization by id
    ///
    ///Use `GET /v1/organizations/{organization}` instead
    ///
    ///Sends a 'GET' request to '/by-id/organizations/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationViewByIdError>> {
        let url = format!(
            "{}/by-id/organizations/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewByIdError>::from_response::<
                    types::OrganizationViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewByIdError>::from_response::<
                    types::OrganizationViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a project by id
    ///
    ///Use `GET /v1/projects/{project}` instead
    ///
    ///Sends a 'GET' request to '/by-id/projects/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectViewByIdError>> {
        let url = format!(
            "{}/by-id/projects/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewByIdError>::from_response::<
                    types::ProjectViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewByIdError>::from_response::<
                    types::ProjectViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a snapshot by id
    ///
    ///Sends a 'GET' request to '/by-id/snapshots/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn snapshot_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Snapshot>, Error<types::SnapshotViewByIdError>> {
        let url = format!(
            "{}/by-id/snapshots/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "snapshot_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotViewByIdError>::from_response::<
                    types::SnapshotViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotViewByIdError>::from_response::<
                    types::SnapshotViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a route by id
    ///
    ///Sends a 'GET' request to '/by-id/vpc-router-routes/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::VpcRouterRouteViewByIdError>> {
        let url = format!(
            "{}/by-id/vpc-router-routes/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteViewByIdError>::from_response::<
                    types::VpcRouterRouteViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteViewByIdError>::from_response::<
                    types::VpcRouterRouteViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Get a router by id
    ///
    ///Sends a 'GET' request to '/by-id/vpc-routers/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::VpcRouterViewByIdError>> {
        let url = format!(
            "{}/by-id/vpc-routers/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterViewByIdError>::from_response::<
                    types::VpcRouterViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterViewByIdError>::from_response::<
                    types::VpcRouterViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a subnet by id
    ///
    ///Sends a 'GET' request to '/by-id/vpc-subnets/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::VpcSubnetViewByIdError>> {
        let url = format!(
            "{}/by-id/vpc-subnets/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetViewByIdError>::from_response::<
                    types::VpcSubnetViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetViewByIdError>::from_response::<
                    types::VpcSubnetViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a VPC
    ///
    ///Sends a 'GET' request to '/by-id/vpcs/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::VpcViewByIdError>> {
        let url = format!(
            "{}/by-id/vpcs/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcViewByIdError>::from_response::<types::VpcViewByIdError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcViewByIdError>::from_response::<types::VpcViewByIdError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Start an OAuth 2.0 Device Authorization Grant
    ///
    ///This endpoint is designed to be accessed from an *unauthenticated* API
    /// client. It generates and records a `device_code` and `user_code` which
    /// must be verified and confirmed prior to a token being granted.
    ///
    ///Sends a 'POST' request to '/device/auth'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn device_auth_request<'a>(
        &'a self,
        body: &'a types::DeviceAuthRequest,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!("{}/device/auth", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .form_urlencoded(&body)?
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "device_auth_request",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::ErrorResponse(ResponseValue::empty(response))),
        }
    }

    ///Confirm an OAuth 2.0 Device Authorization Grant
    ///
    ///This endpoint is designed to be accessed by the user agent (browser),
    /// not the client requesting the token. So we do not actually return the
    /// token here; it will be returned in response to the poll on
    /// `/device/token`.
    ///
    ///Sends a 'POST' request to '/device/confirm'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn device_auth_confirm<'a>(
        &'a self,
        body: &'a types::DeviceAuthVerify,
    ) -> Result<ResponseValue<()>, Error<types::DeviceAuthConfirmError>> {
        let url = format!("{}/device/confirm", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "device_auth_confirm",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DeviceAuthConfirmError>::from_response::<
                    types::DeviceAuthConfirmError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DeviceAuthConfirmError>::from_response::<
                    types::DeviceAuthConfirmError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Request a device access token
    ///
    ///This endpoint should be polled by the client until the user code is
    /// verified and the grant is confirmed.
    ///
    ///Sends a 'POST' request to '/device/token'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn device_access_token<'a>(
        &'a self,
        body: &'a types::DeviceAccessTokenRequest,
    ) -> Result<ResponseValue<ByteStream>, Error<()>> {
        let url = format!("{}/device/token", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .form_urlencoded(&body)?
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "device_access_token",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            _ => Err(Error::ErrorResponse(ResponseValue::empty(response))),
        }
    }

    ///List groups
    ///
    ///Sends a 'GET' request to '/groups'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn group_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::GroupListError>> {
        let url = format!("{}/groups", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "group_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::GroupListError>::from_response::<types::GroupListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::GroupListError>::from_response::<types::GroupListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List groups as a Stream
    ///
    ///Sends repeated `GET` requests to `/groups` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn group_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Group, Error<types::GroupListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.group_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.group_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Sends a 'POST' request to '/login'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn login_spoof<'a>(
        &'a self,
        body: &'a types::SpoofLoginBody,
    ) -> Result<ResponseValue<()>, Error<types::LoginSpoofError>> {
        let url = format!("{}/login", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "login_spoof",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSpoofError>::from_response::<types::LoginSpoofError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSpoofError>::from_response::<types::LoginSpoofError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Authenticate a user (i.e., log in) via username and password
    ///
    ///Sends a 'POST' request to '/login/{silo_name}/local'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn login_local<'a>(
        &'a self,
        silo_name: &'a types::Name,
        body: &'a types::UsernamePasswordCredentials,
    ) -> Result<ResponseValue<ByteStream>, Error<types::LoginLocalError>> {
        let url = format!(
            "{}/login/{}/local",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "login_local",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginLocalError>::from_response::<types::LoginLocalError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginLocalError>::from_response::<types::LoginLocalError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Prompt user login
    ///
    ///Either display a page asking a user for their credentials, or redirect
    /// them to their identity provider.
    ///
    ///Sends a 'GET' request to '/login/{silo_name}/saml/{provider_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn login_saml_begin<'a>(
        &'a self,
        silo_name: &'a types::Name,
        provider_name: &'a types::Name,
    ) -> Result<ResponseValue<ByteStream>, Error<types::LoginSamlBeginError>> {
        let url = format!(
            "{}/login/{}/saml/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&provider_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self.client().get(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "login_saml_begin",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSamlBeginError>::from_response::<
                    types::LoginSamlBeginError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSamlBeginError>::from_response::<
                    types::LoginSamlBeginError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Authenticate a user (i.e., log in) via SAML
    ///
    ///Sends a 'POST' request to '/login/{silo_name}/saml/{provider_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn login_saml<'a, B: Into<reqwest::Body>>(
        &'a self,
        silo_name: &'a types::Name,
        provider_name: &'a types::Name,
        body: B,
    ) -> Result<ResponseValue<ByteStream>, Error<types::LoginSamlError>> {
        let url = format!(
            "{}/login/{}/saml/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&provider_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/octet-stream"),
            )
            .body(body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "login_saml",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200..=299 => Ok(ResponseValue::stream(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSamlError>::from_response::<types::LoginSamlError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LoginSamlError>::from_response::<types::LoginSamlError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Sends a 'POST' request to '/logout'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn logout<'a>(&'a self) -> Result<ResponseValue<()>, Error<types::LogoutError>> {
        let url = format!("{}/logout", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "logout",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LogoutError>::from_response::<types::LogoutError>(response)
                    .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LogoutError>::from_response::<types::LogoutError>(response)
                    .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List organizations
    ///
    ///Use `GET /v1/organizations` instead
    ///
    ///Sends a 'GET' request to '/organizations'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::OrganizationResultsPage>, Error<types::OrganizationListError>>
    {
        let url = format!("{}/organizations", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationListError>::from_response::<
                    types::OrganizationListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationListError>::from_response::<
                    types::OrganizationListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List organizations as a Stream
    ///
    ///Use `GET /v1/organizations` instead
    ///
    ///Sends repeated `GET` requests to `/organizations` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn organization_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Organization, Error<types::OrganizationListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.organization_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.organization_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an organization
    ///
    ///Use `POST /v1/organizations` instead
    ///
    ///Sends a 'POST' request to '/organizations'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_create<'a>(
        &'a self,
        body: &'a types::OrganizationCreate,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationCreateError>> {
        let url = format!("{}/organizations", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationCreateError>::from_response::<
                    types::OrganizationCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationCreateError>::from_response::<
                    types::OrganizationCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an organization
    ///
    ///Use `GET /v1/organizations/{organization}` instead
    ///
    ///Sends a 'GET' request to '/organizations/{organization_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationViewError>> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewError>::from_response::<
                    types::OrganizationViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewError>::from_response::<
                    types::OrganizationViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update an organization
    ///
    ///Use `PUT /v1/organizations/{organization}` instead
    ///
    ///Sends a 'PUT' request to '/organizations/{organization_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        body: &'a types::OrganizationUpdate,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationUpdateError>> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationUpdateError>::from_response::<
                    types::OrganizationUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationUpdateError>::from_response::<
                    types::OrganizationUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an organization
    ///
    ///Use `DELETE /v1/organizations/{organization}` instead
    ///
    ///Sends a 'DELETE' request to '/organizations/{organization_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::OrganizationDeleteError>> {
        let url = format!(
            "{}/organizations/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationDeleteError>::from_response::<
                    types::OrganizationDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationDeleteError>::from_response::<
                    types::OrganizationDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an organization's IAM policy
    ///
    ///Use `GET /v1/organizations/{organization}/policy` instead
    ///
    ///Sends a 'GET' request to '/organizations/{organization_name}/policy'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_policy_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
    ) -> Result<
        ResponseValue<types::OrganizationRolePolicy>,
        Error<types::OrganizationPolicyViewError>,
    > {
        let url = format!(
            "{}/organizations/{}/policy",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_policy_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyViewError>::from_response::<
                    types::OrganizationPolicyViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyViewError>::from_response::<
                    types::OrganizationPolicyViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update an organization's IAM policy
    ///
    ///Use `PUT /v1/organizations/{organization}/policy` instead
    ///
    ///Sends a 'PUT' request to '/organizations/{organization_name}/policy'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_policy_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        body: &'a types::OrganizationRolePolicy,
    ) -> Result<
        ResponseValue<types::OrganizationRolePolicy>,
        Error<types::OrganizationPolicyUpdateError>,
    > {
        let url = format!(
            "{}/organizations/{}/policy",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_policy_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyUpdateError>::from_response::<
                    types::OrganizationPolicyUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyUpdateError>::from_response::<
                    types::OrganizationPolicyUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List projects
    ///
    ///Use `GET /v1/projects` instead
    ///
    ///Sends a 'GET' request to '/organizations/{organization_name}/projects'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::ProjectListError>> {
        let url = format!(
            "{}/organizations/{}/projects",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectListError>::from_response::<types::ProjectListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectListError>::from_response::<types::ProjectListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List projects as a Stream
    ///
    ///Use `GET /v1/projects` instead
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn project_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Project, Error<types::ProjectListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_list(organization_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_list(organization_name, limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a project
    ///
    ///Use `POST /v1/projects` instead
    ///
    ///Sends a 'POST' request to '/organizations/{organization_name}/projects'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        body: &'a types::ProjectCreate,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectCreateError>::from_response::<
                    types::ProjectCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectCreateError>::from_response::<
                    types::ProjectCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a project
    ///
    ///Use `GET /v1/projects/{project}` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewError>::from_response::<types::ProjectViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewError>::from_response::<types::ProjectViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a project
    ///
    ///Use `PUT /v1/projects/{project}` instead
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::ProjectUpdate,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectUpdateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectUpdateError>::from_response::<
                    types::ProjectUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectUpdateError>::from_response::<
                    types::ProjectUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a project
    ///
    ///Use `DELETE /v1/projects/{project}` instead
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::ProjectDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectDeleteError>::from_response::<
                    types::ProjectDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectDeleteError>::from_response::<
                    types::ProjectDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List disks
    ///
    ///Use `GET /v1/disks` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/disks'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::DiskListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskListError>::from_response::<types::DiskListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskListError>::from_response::<types::DiskListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List disks as a Stream
    ///
    ///Use `GET /v1/disks` instead
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/disks` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn disk_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::DiskListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.disk_list(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.disk_list(
                            organization_name,
                            project_name,
                            limit,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Use `POST /v1/disks` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/disks'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::DiskCreate,
    ) -> Result<ResponseValue<types::Disk>, Error<types::DiskCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskCreateError>::from_response::<types::DiskCreateError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskCreateError>::from_response::<types::DiskCreateError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a disk
    ///
    ///Use `GET /v1/disks/{disk}` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Disk>, Error<types::DiskViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&disk_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskViewError>::from_response::<types::DiskViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskViewError>::from_response::<types::DiskViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Use `DELETE /v1/disks/{disk}` instead
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::DiskDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&disk_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskDeleteError>::from_response::<types::DiskDeleteError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskDeleteError>::from_response::<types::DiskDeleteError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch disk metrics
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}/metrics/{metric_name}'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `disk_name`
    /// - `metric_name`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `start_time`: An inclusive start time of metrics.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_metrics_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
        metric_name: types::DiskMetricName,
        end_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        start_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
    ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::DiskMetricsListError>>
    {
        let url = format!(
            "{}/organizations/{}/projects/{}/disks/{}/metrics/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&disk_name.to_string()),
            encode_path(&metric_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("end_time", &end_time))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new(
                "start_time",
                &start_time,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_metrics_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskMetricsListError>::from_response::<
                    types::DiskMetricsListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskMetricsListError>::from_response::<
                    types::DiskMetricsListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch disk metrics as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/disks/
    /// {disk_name}/metrics/{metric_name}` until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `disk_name`
    /// - `metric_name`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `start_time`: An inclusive start time of metrics.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn disk_metrics_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        disk_name: &'a types::Name,
        metric_name: types::DiskMetricName,
        end_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
        limit: Option<::std::num::NonZeroU32>,
        start_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
    ) -> impl futures::Stream<Item = Result<types::Measurement, Error<types::DiskMetricsListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.disk_metrics_list(
            organization_name,
            project_name,
            disk_name,
            metric_name,
            end_time,
            limit,
            None,
            start_time,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.disk_metrics_list(
                        organization_name,
                        project_name,
                        disk_name,
                        metric_name,
                        None,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///List images
    ///
    ///List images in a project. The images are returned sorted by creation
    /// date, with the most recent images appearing first.
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/images'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn image_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::ImageResultsPage>, Error<types::ImageListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/images",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "image_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageListError>::from_response::<types::ImageListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageListError>::from_response::<types::ImageListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List images as a Stream
    ///
    ///List images in a project. The images are returned sorted by creation
    /// date, with the most recent images appearing first.
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/images`
    /// until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn image_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Image, Error<types::ImageListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.image_list(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.image_list(
                            organization_name,
                            project_name,
                            limit,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an image
    ///
    ///Create a new image in a project.
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/images'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn image_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::ImageCreate,
    ) -> Result<ResponseValue<types::Image>, Error<types::ImageCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/images",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "image_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageCreateError>::from_response::<types::ImageCreateError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageCreateError>::from_response::<types::ImageCreateError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an image
    ///
    ///Fetch the details for a specific image in a project.
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/images/
    /// {image_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn image_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        image_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Image>, Error<types::ImageViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/images/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&image_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "image_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageViewError>::from_response::<types::ImageViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageViewError>::from_response::<types::ImageViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an image
    ///
    ///Permanently delete an image from a project. This operation cannot be
    /// undone. Any instances in the project using the image will continue to
    /// run, however new instances can not be created with this image.
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/images/
    /// {image_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn image_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        image_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::ImageDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/images/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&image_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "image_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageDeleteError>::from_response::<types::ImageDeleteError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ImageDeleteError>::from_response::<types::ImageDeleteError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List instances
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::InstanceListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceListError>::from_response::<
                        types::InstanceListError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceListError>::from_response::<
                        types::InstanceListError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List instances as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/instances`
    /// until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn instance_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::InstanceListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_list(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.instance_list(
                            organization_name,
                            project_name,
                            limit,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an instance
    ///
    ///Use `POST /v1/instances` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::InstanceCreate,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceCreateError>::from_response::<
                    types::InstanceCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceCreateError>::from_response::<
                    types::InstanceCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an instance
    ///
    ///Use `GET /v1/instances/{instance}` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceViewError>::from_response::<
                        types::InstanceViewError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceViewError>::from_response::<
                        types::InstanceViewError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an instance
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::InstanceDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDeleteError>::from_response::<
                    types::InstanceDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDeleteError>::from_response::<
                    types::InstanceDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List an instance's disks
    ///
    ///Use `GET /v1/instances/{instance}/disks` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::InstanceDiskListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskListError>::from_response::<
                    types::InstanceDiskListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskListError>::from_response::<
                    types::InstanceDiskListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List an instance's disks as a Stream
    ///
    ///Use `GET /v1/instances/{instance}/disks` instead
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks` until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn instance_disk_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::InstanceDiskListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_disk_list(
            organization_name,
            project_name,
            instance_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.instance_disk_list(
                        organization_name,
                        project_name,
                        instance_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Attach a disk to an instance
    ///
    ///Use `POST /v1/instances/{instance}/disks/attach` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks/attach'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_attach<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::DiskIdentifier,
    ) -> Result<ResponseValue<types::Disk>, Error<types::InstanceDiskAttachError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks/attach",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_attach",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskAttachError>::from_response::<
                    types::InstanceDiskAttachError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskAttachError>::from_response::<
                    types::InstanceDiskAttachError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Detach a disk from an instance
    ///
    ///Use `POST /v1/disks/{disk}/detach` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/disks/detach'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_detach<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::DiskIdentifier,
    ) -> Result<ResponseValue<types::Disk>, Error<types::InstanceDiskDetachError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/disks/detach",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_detach",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskDetachError>::from_response::<
                    types::InstanceDiskDetachError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskDetachError>::from_response::<
                    types::InstanceDiskDetachError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List external IP addresses
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/external-ips'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_external_ip_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<
        ResponseValue<types::ExternalIpResultsPage>,
        Error<types::InstanceExternalIpListError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/external-ips",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_external_ip_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceExternalIpListError>::from_response::<
                    types::InstanceExternalIpListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceExternalIpListError>::from_response::<
                    types::InstanceExternalIpListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Migrate an instance
    ///
    ///Use `POST /v1/instances/{instance}/migrate` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/migrate'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_migrate<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::InstanceMigrate,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceMigrateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/migrate",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_migrate",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceMigrateError>::from_response::<
                    types::InstanceMigrateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceMigrateError>::from_response::<
                    types::InstanceMigrateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List network interfaces
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<
        ResponseValue<types::NetworkInterfaceResultsPage>,
        Error<types::InstanceNetworkInterfaceListError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceListError>::from_response::<
                    types::InstanceNetworkInterfaceListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceListError>::from_response::<
                    types::InstanceNetworkInterfaceListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List network interfaces as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces` until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn instance_network_interface_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::NetworkInterface, Error<types::InstanceNetworkInterfaceListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_network_interface_list(
            organization_name,
            project_name,
            instance_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.instance_network_interface_list(
                        organization_name,
                        project_name,
                        instance_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Create a network interface
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        body: &'a types::NetworkInterfaceCreate,
    ) -> Result<
        ResponseValue<types::NetworkInterface>,
        Error<types::InstanceNetworkInterfaceCreateError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceCreateError>::from_response::<
                    types::InstanceNetworkInterfaceCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceCreateError>::from_response::<
                    types::InstanceNetworkInterfaceCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a network interface
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        interface_name: &'a types::Name,
    ) -> Result<
        ResponseValue<types::NetworkInterface>,
        Error<types::InstanceNetworkInterfaceViewError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
            encode_path(&interface_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceViewError>::from_response::<
                    types::InstanceNetworkInterfaceViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceViewError>::from_response::<
                    types::InstanceNetworkInterfaceViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a network interface
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        interface_name: &'a types::Name,
        body: &'a types::NetworkInterfaceUpdate,
    ) -> Result<
        ResponseValue<types::NetworkInterface>,
        Error<types::InstanceNetworkInterfaceUpdateError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
            encode_path(&interface_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceUpdateError>::from_response::<
                    types::InstanceNetworkInterfaceUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceUpdateError>::from_response::<
                    types::InstanceNetworkInterfaceUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a network interface
    ///
    ///Note that the primary interface for an instance cannot be deleted if
    /// there are any secondary interfaces. A new primary interface must be
    /// designated first. The primary interface can be deleted if there are no
    /// secondary interfaces.
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/network-interfaces/{interface_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_network_interface_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        interface_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::InstanceNetworkInterfaceDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
            encode_path(&interface_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_network_interface_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceDeleteError>::from_response::<
                    types::InstanceNetworkInterfaceDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceNetworkInterfaceDeleteError>::from_response::<
                    types::InstanceNetworkInterfaceDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Reboot an instance
    ///
    ///Use `POST /v1/instances/{instance}/reboot` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/reboot'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_reboot<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceRebootError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/reboot",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_reboot",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceRebootError>::from_response::<
                    types::InstanceRebootError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceRebootError>::from_response::<
                    types::InstanceRebootError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an instance's serial console
    ///
    ///Use `GET /v1/instances/{instance}/serial-console` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/serial-console'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `instance_name`
    /// - `from_start`: Character index in the serial buffer from which to read,
    ///   counting the bytes output since instance start. If this is not
    ///   provided, `most_recent` must be provided, and if this *is* provided,
    ///   `most_recent` must *not* be provided.
    /// - `max_bytes`: Maximum number of bytes of buffered serial console
    ///   contents to return. If the requested range runs to the end of the
    ///   available buffer, the data returned will be shorter than `max_bytes`.
    /// - `most_recent`: Character index in the serial buffer from which to
    ///   read, counting *backward* from the most recently buffered data
    ///   retrieved from the instance. (See note on `from_start` about mutual
    ///   exclusivity)
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_serial_console<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
        from_start: Option<u64>,
        max_bytes: Option<u64>,
        most_recent: Option<u64>,
    ) -> Result<
        ResponseValue<types::InstanceSerialConsoleData>,
        Error<types::InstanceSerialConsoleError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/serial-console",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "from_start",
                &from_start,
            ))
            .query(&progenitor_client::QueryParam::new("max_bytes", &max_bytes))
            .query(&progenitor_client::QueryParam::new(
                "most_recent",
                &most_recent,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_serial_console",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceSerialConsoleError>::from_response::<
                    types::InstanceSerialConsoleError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceSerialConsoleError>::from_response::<
                    types::InstanceSerialConsoleError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Connect to an instance's serial console
    ///
    ///Use `GET /v1/instances/{instance}/serial-console/stream` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/serial-console/stream'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_serial_console_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<reqwest::Upgraded>, Error<()>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/serial-console/stream",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .headers(header_map)
            .header(::reqwest::header::CONNECTION, "Upgrade")
            .header(::reqwest::header::UPGRADE, "websocket")
            .header(::reqwest::header::SEC_WEBSOCKET_VERSION, "13")
            .header(
                ::reqwest::header::SEC_WEBSOCKET_KEY,
                ::base64::Engine::encode(
                    &::base64::engine::general_purpose::STANDARD,
                    ::rand::random::<[u8; 16]>(),
                ),
            )
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_serial_console_stream",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            101u16 => ResponseValue::upgrade(response).await,
            200..=299 => ResponseValue::upgrade(response).await,
            _ => Err(Error::ErrorResponse(ResponseValue::empty(response))),
        }
    }

    ///Boot an instance
    ///
    ///Use `POST /v1/instances/{instance}/start` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/start'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_start<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceStartError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/start",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_start",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStartError>::from_response::<
                    types::InstanceStartError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStartError>::from_response::<
                    types::InstanceStartError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Halt an instance
    ///
    ///Use `POST /v1/instances/{instance}/stop` instead
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/instances/
    /// {instance_name}/stop'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_stop<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        instance_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceStopError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/instances/{}/stop",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&instance_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_stop",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceStopError>::from_response::<
                        types::InstanceStopError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::InstanceStopError>::from_response::<
                        types::InstanceStopError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a project's IAM policy
    ///
    ///Use `GET /v1/projects/{project}/policy` instead
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/policy'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_policy_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
    ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::ProjectPolicyViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/policy",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_policy_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyViewError>::from_response::<
                    types::ProjectPolicyViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyViewError>::from_response::<
                    types::ProjectPolicyViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a project's IAM policy
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/policy'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_policy_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::ProjectRolePolicy,
    ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::ProjectPolicyUpdateError>>
    {
        let url = format!(
            "{}/organizations/{}/projects/{}/policy",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_policy_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyUpdateError>::from_response::<
                    types::ProjectPolicyUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyUpdateError>::from_response::<
                    types::ProjectPolicyUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List snapshots
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/snapshots'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn snapshot_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::SnapshotResultsPage>, Error<types::SnapshotListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "snapshot_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SnapshotListError>::from_response::<
                        types::SnapshotListError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SnapshotListError>::from_response::<
                        types::SnapshotListError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List snapshots as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/snapshots`
    /// until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn snapshot_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Snapshot, Error<types::SnapshotListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.snapshot_list(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.snapshot_list(
                            organization_name,
                            project_name,
                            limit,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a snapshot
    ///
    ///Creates a point-in-time snapshot from a disk.
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/snapshots'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn snapshot_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::SnapshotCreate,
    ) -> Result<ResponseValue<types::Snapshot>, Error<types::SnapshotCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "snapshot_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotCreateError>::from_response::<
                    types::SnapshotCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotCreateError>::from_response::<
                    types::SnapshotCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a snapshot
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/snapshots/
    /// {snapshot_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn snapshot_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        snapshot_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Snapshot>, Error<types::SnapshotViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&snapshot_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "snapshot_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SnapshotViewError>::from_response::<
                        types::SnapshotViewError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SnapshotViewError>::from_response::<
                        types::SnapshotViewError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a snapshot
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/snapshots/
    /// {snapshot_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn snapshot_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        snapshot_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::SnapshotDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/snapshots/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&snapshot_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "snapshot_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotDeleteError>::from_response::<
                    types::SnapshotDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SnapshotDeleteError>::from_response::<
                    types::SnapshotDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List VPCs
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::VpcResultsPage>, Error<types::VpcListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcListError>::from_response::<types::VpcListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcListError>::from_response::<types::VpcListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List VPCs as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn vpc_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Vpc, Error<types::VpcListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_list(organization_name, project_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.vpc_list(
                            organization_name,
                            project_name,
                            limit,
                            state.as_deref(),
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a VPC
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs'
    ///
    ///Arguments:
    /// - `organization_name`: The organization's unique name.
    /// - `project_name`: The project's unique name within the organization.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        body: &'a types::VpcCreate,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::VpcCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcCreateError>::from_response::<types::VpcCreateError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcCreateError>::from_response::<types::VpcCreateError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a VPC
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::VpcViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcViewError>::from_response::<types::VpcViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcViewError>::from_response::<types::VpcViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a VPC
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcUpdate,
    ) -> Result<ResponseValue<types::Vpc>, Error<types::VpcUpdateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcUpdateError>::from_response::<types::VpcUpdateError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcUpdateError>::from_response::<types::VpcUpdateError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a VPC
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::VpcDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcDeleteError>::from_response::<types::VpcDeleteError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcDeleteError>::from_response::<types::VpcDeleteError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List firewall rules
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/firewall/rules'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_firewall_rules_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
    ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::VpcFirewallRulesViewError>>
    {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_firewall_rules_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcFirewallRulesViewError>::from_response::<
                    types::VpcFirewallRulesViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcFirewallRulesViewError>::from_response::<
                    types::VpcFirewallRulesViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Replace firewall rules
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/firewall/rules'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_firewall_rules_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcFirewallRuleUpdateParams,
    ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::VpcFirewallRulesUpdateError>>
    {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_firewall_rules_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcFirewallRulesUpdateError>::from_response::<
                    types::VpcFirewallRulesUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcFirewallRulesUpdateError>::from_response::<
                    types::VpcFirewallRulesUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List routers
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::VpcRouterResultsPage>, Error<types::VpcRouterListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterListError>::from_response::<
                    types::VpcRouterListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterListError>::from_response::<
                    types::VpcRouterListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List routers as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers` until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn vpc_router_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::VpcRouter, Error<types::VpcRouterListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_router_list(
            organization_name,
            project_name,
            vpc_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_router_list(
                        organization_name,
                        project_name,
                        vpc_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Create a router
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcRouterCreate,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::VpcRouterCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterCreateError>::from_response::<
                    types::VpcRouterCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterCreateError>::from_response::<
                    types::VpcRouterCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Get a router
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::VpcRouterViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterViewError>::from_response::<
                    types::VpcRouterViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterViewError>::from_response::<
                    types::VpcRouterViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a router
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        body: &'a types::VpcRouterUpdate,
    ) -> Result<ResponseValue<types::VpcRouter>, Error<types::VpcRouterUpdateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterUpdateError>::from_response::<
                    types::VpcRouterUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterUpdateError>::from_response::<
                    types::VpcRouterUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a router
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::VpcRouterDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterDeleteError>::from_response::<
                    types::VpcRouterDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterDeleteError>::from_response::<
                    types::VpcRouterDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List routes
    ///
    ///List the routes associated with a router in a particular VPC.
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `router_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::RouterRouteResultsPage>, Error<types::VpcRouterRouteListError>>
    {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteListError>::from_response::<
                    types::VpcRouterRouteListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteListError>::from_response::<
                    types::VpcRouterRouteListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List routes as a Stream
    ///
    ///List the routes associated with a router in a particular VPC.
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `router_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn vpc_router_route_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::RouterRoute, Error<types::VpcRouterRouteListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_router_route_list(
            organization_name,
            project_name,
            vpc_name,
            router_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_router_route_list(
                        organization_name,
                        project_name,
                        vpc_name,
                        router_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Create a router
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        body: &'a types::RouterRouteCreateParams,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::VpcRouterRouteCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteCreateError>::from_response::<
                    types::VpcRouterRouteCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteCreateError>::from_response::<
                    types::VpcRouterRouteCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a route
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::VpcRouterRouteViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
            encode_path(&route_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteViewError>::from_response::<
                    types::VpcRouterRouteViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteViewError>::from_response::<
                    types::VpcRouterRouteViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a route
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
        body: &'a types::RouterRouteUpdateParams,
    ) -> Result<ResponseValue<types::RouterRoute>, Error<types::VpcRouterRouteUpdateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
            encode_path(&route_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteUpdateError>::from_response::<
                    types::VpcRouterRouteUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteUpdateError>::from_response::<
                    types::VpcRouterRouteUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a route
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/routers/{router_name}/routes/{route_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_router_route_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        router_name: &'a types::Name,
        route_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::VpcRouterRouteDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&router_name.to_string()),
            encode_path(&route_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_router_route_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteDeleteError>::from_response::<
                    types::VpcRouterRouteDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcRouterRouteDeleteError>::from_response::<
                    types::VpcRouterRouteDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List subnets
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_list<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::VpcSubnetResultsPage>, Error<types::VpcSubnetListError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetListError>::from_response::<
                    types::VpcSubnetListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetListError>::from_response::<
                    types::VpcSubnetListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List subnets as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets` until there are no more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn vpc_subnet_list_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::VpcSubnet, Error<types::VpcSubnetListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_subnet_list(
            organization_name,
            project_name,
            vpc_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_subnet_list(
                        organization_name,
                        project_name,
                        vpc_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Create a subnet
    ///
    ///Sends a 'POST' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_create<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        body: &'a types::VpcSubnetCreate,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::VpcSubnetCreateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetCreateError>::from_response::<
                    types::VpcSubnetCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetCreateError>::from_response::<
                    types::VpcSubnetCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a subnet
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_view<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::VpcSubnetViewError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&subnet_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetViewError>::from_response::<
                    types::VpcSubnetViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetViewError>::from_response::<
                    types::VpcSubnetViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a subnet
    ///
    ///Sends a 'PUT' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_update<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        body: &'a types::VpcSubnetUpdate,
    ) -> Result<ResponseValue<types::VpcSubnet>, Error<types::VpcSubnetUpdateError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&subnet_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetUpdateError>::from_response::<
                    types::VpcSubnetUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetUpdateError>::from_response::<
                    types::VpcSubnetUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a subnet
    ///
    ///Sends a 'DELETE' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_delete<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::VpcSubnetDeleteError>> {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&subnet_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetDeleteError>::from_response::<
                    types::VpcSubnetDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetDeleteError>::from_response::<
                    types::VpcSubnetDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List network interfaces
    ///
    ///Sends a 'GET' request to
    /// '/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}/network-interfaces'
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `subnet_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn vpc_subnet_list_network_interfaces<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<
        ResponseValue<types::NetworkInterfaceResultsPage>,
        Error<types::VpcSubnetListNetworkInterfacesError>,
    > {
        let url = format!(
            "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}/network-interfaces",
            self.baseurl(),
            encode_path(&organization_name.to_string()),
            encode_path(&project_name.to_string()),
            encode_path(&vpc_name.to_string()),
            encode_path(&subnet_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "vpc_subnet_list_network_interfaces",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetListNetworkInterfacesError>::from_response::<
                    types::VpcSubnetListNetworkInterfacesError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::VpcSubnetListNetworkInterfacesError>::from_response::<
                    types::VpcSubnetListNetworkInterfacesError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List network interfaces as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/organizations/{organization_name}/projects/{project_name}/vpcs/
    /// {vpc_name}/subnets/{subnet_name}/network-interfaces` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `organization_name`
    /// - `project_name`
    /// - `vpc_name`
    /// - `subnet_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn vpc_subnet_list_network_interfaces_stream<'a>(
        &'a self,
        organization_name: &'a types::Name,
        project_name: &'a types::Name,
        vpc_name: &'a types::Name,
        subnet_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::NetworkInterface, Error<types::VpcSubnetListNetworkInterfacesError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.vpc_subnet_list_network_interfaces(
            organization_name,
            project_name,
            vpc_name,
            subnet_name,
            limit,
            None,
            sort_by,
        )
        .map_ok(move |page| {
            let page = page.into_inner();
            let first = futures::stream::iter(page.items).map(Ok);
            let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                if state.is_none() {
                    Ok(None)
                } else {
                    self.vpc_subnet_list_network_interfaces(
                        organization_name,
                        project_name,
                        vpc_name,
                        subnet_name,
                        limit,
                        state.as_deref(),
                        None,
                    )
                    .map_ok(|page| {
                        let page = page.into_inner();
                        Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                    })
                    .await
                }
            })
            .try_flatten();
            first.chain(rest)
        })
        .try_flatten_stream()
        .boxed()
    }

    ///Fetch the current silo's IAM policy
    ///
    ///Sends a 'GET' request to '/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn policy_view<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::PolicyViewError>> {
        let url = format!("{}/policy", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "policy_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::PolicyViewError>::from_response::<types::PolicyViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::PolicyViewError>::from_response::<types::PolicyViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update the current silo's IAM policy
    ///
    ///Sends a 'PUT' request to '/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn policy_update<'a>(
        &'a self,
        body: &'a types::SiloRolePolicy,
    ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::PolicyUpdateError>> {
        let url = format!("{}/policy", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "policy_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::PolicyUpdateError>::from_response::<
                        types::PolicyUpdateError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::PolicyUpdateError>::from_response::<
                        types::PolicyUpdateError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List built-in roles
    ///
    ///Sends a 'GET' request to '/roles'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn role_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<ResponseValue<types::RoleResultsPage>, Error<types::RoleListError>> {
        let url = format!("{}/roles", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "role_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RoleListError>::from_response::<types::RoleListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RoleListError>::from_response::<types::RoleListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List built-in roles as a Stream
    ///
    ///Sends repeated `GET` requests to `/roles` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn role_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
    ) -> impl futures::Stream<Item = Result<types::Role, Error<types::RoleListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.role_list(limit, None)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.role_list(limit, state.as_deref())
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a built-in role
    ///
    ///Sends a 'GET' request to '/roles/{role_name}'
    ///
    ///Arguments:
    /// - `role_name`: The built-in role's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn role_view<'a>(
        &'a self,
        role_name: &'a str,
    ) -> Result<ResponseValue<types::Role>, Error<types::RoleViewError>> {
        let url = format!(
            "{}/roles/{}",
            self.baseurl(),
            encode_path(&role_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "role_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RoleViewError>::from_response::<types::RoleViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RoleViewError>::from_response::<types::RoleViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch the user associated with the current session
    ///
    ///Sends a 'GET' request to '/session/me'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_me<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::User>, Error<types::SessionMeError>> {
        let url = format!("{}/session/me", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_me",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionMeError>::from_response::<types::SessionMeError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionMeError>::from_response::<types::SessionMeError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch the silogroups the current user belongs to
    ///
    ///Sends a 'GET' request to '/session/me/groups'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_me_groups<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::SessionMeGroupsError>> {
        let url = format!("{}/session/me/groups", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_me_groups",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionMeGroupsError>::from_response::<
                    types::SessionMeGroupsError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionMeGroupsError>::from_response::<
                    types::SessionMeGroupsError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch the silogroups the current user belongs to as a Stream
    ///
    ///Sends repeated `GET` requests to `/session/me/groups` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn session_me_groups_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Group, Error<types::SessionMeGroupsError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.session_me_groups(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.session_me_groups(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List SSH public keys
    ///
    ///Lists SSH public keys for the currently authenticated user.
    ///
    ///Sends a 'GET' request to '/session/me/sshkeys'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_sshkey_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::SshKeyResultsPage>, Error<types::SessionSshkeyListError>> {
        let url = format!("{}/session/me/sshkeys", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_sshkey_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyListError>::from_response::<
                    types::SessionSshkeyListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyListError>::from_response::<
                    types::SessionSshkeyListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List SSH public keys as a Stream
    ///
    ///Lists SSH public keys for the currently authenticated user.
    ///
    ///Sends repeated `GET` requests to `/session/me/sshkeys` until there are
    /// no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn session_sshkey_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::SshKey, Error<types::SessionSshkeyListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.session_sshkey_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.session_sshkey_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an SSH public key
    ///
    ///Create an SSH public key for the currently authenticated user.
    ///
    ///Sends a 'POST' request to '/session/me/sshkeys'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_sshkey_create<'a>(
        &'a self,
        body: &'a types::SshKeyCreate,
    ) -> Result<ResponseValue<types::SshKey>, Error<types::SessionSshkeyCreateError>> {
        let url = format!("{}/session/me/sshkeys", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_sshkey_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyCreateError>::from_response::<
                    types::SessionSshkeyCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyCreateError>::from_response::<
                    types::SessionSshkeyCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an SSH public key
    ///
    ///Fetch an SSH public key associated with the currently authenticated
    /// user.
    ///
    ///Sends a 'GET' request to '/session/me/sshkeys/{ssh_key_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_sshkey_view<'a>(
        &'a self,
        ssh_key_name: &'a types::Name,
    ) -> Result<ResponseValue<types::SshKey>, Error<types::SessionSshkeyViewError>> {
        let url = format!(
            "{}/session/me/sshkeys/{}",
            self.baseurl(),
            encode_path(&ssh_key_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_sshkey_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyViewError>::from_response::<
                    types::SessionSshkeyViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyViewError>::from_response::<
                    types::SessionSshkeyViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an SSH public key
    ///
    ///Delete an SSH public key associated with the currently authenticated
    /// user.
    ///
    ///Sends a 'DELETE' request to '/session/me/sshkeys/{ssh_key_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn session_sshkey_delete<'a>(
        &'a self,
        ssh_key_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::SessionSshkeyDeleteError>> {
        let url = format!(
            "{}/session/me/sshkeys/{}",
            self.baseurl(),
            encode_path(&ssh_key_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "session_sshkey_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyDeleteError>::from_response::<
                    types::SessionSshkeyDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SessionSshkeyDeleteError>::from_response::<
                    types::SessionSshkeyDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a system-wide image by id
    ///
    ///Sends a 'GET' request to '/system/by-id/images/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_image_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::GlobalImage>, Error<types::SystemImageViewByIdError>> {
        let url = format!(
            "{}/system/by-id/images/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_image_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageViewByIdError>::from_response::<
                    types::SystemImageViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageViewByIdError>::from_response::<
                    types::SystemImageViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an IP pool by id
    ///
    ///Sends a 'GET' request to '/system/by-id/ip-pools/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::IpPool>, Error<types::IpPoolViewByIdError>> {
        let url = format!(
            "{}/system/by-id/ip-pools/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolViewByIdError>::from_response::<
                    types::IpPoolViewByIdError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolViewByIdError>::from_response::<
                    types::IpPoolViewByIdError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a silo by id
    ///
    ///Sends a 'GET' request to '/system/by-id/silos/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_view_by_id<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Silo>, Error<types::SiloViewByIdError>> {
        let url = format!(
            "{}/system/by-id/silos/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_view_by_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SiloViewByIdError>::from_response::<
                        types::SiloViewByIdError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SiloViewByIdError>::from_response::<
                        types::SiloViewByIdError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List system-wide certificates
    ///
    ///Returns a list of all the system-wide certificates. System-wide
    /// certificates are returned sorted by creation date, with the most recent
    /// certificates appearing first.
    ///
    ///Sends a 'GET' request to '/system/certificates'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn certificate_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::CertificateResultsPage>, Error<types::CertificateListError>>
    {
        let url = format!("{}/system/certificates", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "certificate_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateListError>::from_response::<
                    types::CertificateListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateListError>::from_response::<
                    types::CertificateListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List system-wide certificates as a Stream
    ///
    ///Returns a list of all the system-wide certificates. System-wide
    /// certificates are returned sorted by creation date, with the most recent
    /// certificates appearing first.
    ///
    ///Sends repeated `GET` requests to `/system/certificates` until there are
    /// no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn certificate_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Certificate, Error<types::CertificateListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.certificate_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.certificate_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a new system-wide x.509 certificate
    ///
    ///This certificate is automatically used by the Oxide Control plane to
    /// serve external connections.
    ///
    ///Sends a 'POST' request to '/system/certificates'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn certificate_create<'a>(
        &'a self,
        body: &'a types::CertificateCreate,
    ) -> Result<ResponseValue<types::Certificate>, Error<types::CertificateCreateError>> {
        let url = format!("{}/system/certificates", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "certificate_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateCreateError>::from_response::<
                    types::CertificateCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateCreateError>::from_response::<
                    types::CertificateCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a certificate
    ///
    ///Returns the details of a specific certificate
    ///
    ///Sends a 'GET' request to '/system/certificates/{certificate}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn certificate_view<'a>(
        &'a self,
        certificate: &'a types::NameOrId,
    ) -> Result<ResponseValue<types::Certificate>, Error<types::CertificateViewError>> {
        let url = format!(
            "{}/system/certificates/{}",
            self.baseurl(),
            encode_path(&certificate.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "certificate_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateViewError>::from_response::<
                    types::CertificateViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateViewError>::from_response::<
                    types::CertificateViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a certificate
    ///
    ///Permanently delete a certificate. This operation cannot be undone.
    ///
    ///Sends a 'DELETE' request to '/system/certificates/{certificate}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn certificate_delete<'a>(
        &'a self,
        certificate: &'a types::NameOrId,
    ) -> Result<ResponseValue<()>, Error<types::CertificateDeleteError>> {
        let url = format!(
            "{}/system/certificates/{}",
            self.baseurl(),
            encode_path(&certificate.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "certificate_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateDeleteError>::from_response::<
                    types::CertificateDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::CertificateDeleteError>::from_response::<
                    types::CertificateDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List physical disks
    ///
    ///Sends a 'GET' request to '/system/hardware/disks'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn physical_disk_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::PhysicalDiskResultsPage>, Error<types::PhysicalDiskListError>>
    {
        let url = format!("{}/system/hardware/disks", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "physical_disk_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::PhysicalDiskListError>::from_response::<
                    types::PhysicalDiskListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::PhysicalDiskListError>::from_response::<
                    types::PhysicalDiskListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List physical disks as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/hardware/disks` until there
    /// are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn physical_disk_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::PhysicalDisk, Error<types::PhysicalDiskListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.physical_disk_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.physical_disk_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List racks
    ///
    ///Sends a 'GET' request to '/system/hardware/racks'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn rack_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::RackResultsPage>, Error<types::RackListError>> {
        let url = format!("{}/system/hardware/racks", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "rack_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RackListError>::from_response::<types::RackListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RackListError>::from_response::<types::RackListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List racks as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/hardware/racks` until there
    /// are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn rack_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Rack, Error<types::RackListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.rack_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.rack_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a rack
    ///
    ///Sends a 'GET' request to '/system/hardware/racks/{rack_id}'
    ///
    ///Arguments:
    /// - `rack_id`: The rack's unique ID.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn rack_view<'a>(
        &'a self,
        rack_id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Rack>, Error<types::RackViewError>> {
        let url = format!(
            "{}/system/hardware/racks/{}",
            self.baseurl(),
            encode_path(&rack_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "rack_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RackViewError>::from_response::<types::RackViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::RackViewError>::from_response::<types::RackViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List sleds
    ///
    ///Sends a 'GET' request to '/system/hardware/sleds'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn sled_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::SledResultsPage>, Error<types::SledListError>> {
        let url = format!("{}/system/hardware/sleds", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "sled_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledListError>::from_response::<types::SledListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledListError>::from_response::<types::SledListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List sleds as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/hardware/sleds` until there
    /// are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn sled_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Sled, Error<types::SledListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.sled_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.sled_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a sled
    ///
    ///Sends a 'GET' request to '/system/hardware/sleds/{sled_id}'
    ///
    ///Arguments:
    /// - `sled_id`: The sled's unique ID.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn sled_view<'a>(
        &'a self,
        sled_id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Sled>, Error<types::SledViewError>> {
        let url = format!(
            "{}/system/hardware/sleds/{}",
            self.baseurl(),
            encode_path(&sled_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "sled_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledViewError>::from_response::<types::SledViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledViewError>::from_response::<types::SledViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List physical disks attached to sleds
    ///
    ///Sends a 'GET' request to '/system/hardware/sleds/{sled_id}/disks'
    ///
    ///Arguments:
    /// - `sled_id`: The sled's unique ID.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn sled_physical_disk_list<'a>(
        &'a self,
        sled_id: &'a ::uuid::Uuid,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<
        ResponseValue<types::PhysicalDiskResultsPage>,
        Error<types::SledPhysicalDiskListError>,
    > {
        let url = format!(
            "{}/system/hardware/sleds/{}/disks",
            self.baseurl(),
            encode_path(&sled_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "sled_physical_disk_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledPhysicalDiskListError>::from_response::<
                    types::SledPhysicalDiskListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SledPhysicalDiskListError>::from_response::<
                    types::SledPhysicalDiskListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List physical disks attached to sleds as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/system/hardware/sleds/{sled_id}/disks` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `sled_id`: The sled's unique ID.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn sled_physical_disk_list_stream<'a>(
        &'a self,
        sled_id: &'a ::uuid::Uuid,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::PhysicalDisk, Error<types::SledPhysicalDiskListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.sled_physical_disk_list(sled_id, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.sled_physical_disk_list(sled_id, limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List system-wide images
    ///
    ///Returns a list of all the system-wide images. System-wide images are
    /// returned sorted by creation date, with the most recent images appearing
    /// first.
    ///
    ///Sends a 'GET' request to '/system/images'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_image_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::GlobalImageResultsPage>, Error<types::SystemImageListError>>
    {
        let url = format!("{}/system/images", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_image_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageListError>::from_response::<
                    types::SystemImageListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageListError>::from_response::<
                    types::SystemImageListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List system-wide images as a Stream
    ///
    ///Returns a list of all the system-wide images. System-wide images are
    /// returned sorted by creation date, with the most recent images appearing
    /// first.
    ///
    ///Sends repeated `GET` requests to `/system/images` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn system_image_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::GlobalImage, Error<types::SystemImageListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.system_image_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.system_image_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a system-wide image
    ///
    ///Create a new system-wide image. This image can then be used by any user
    /// in any silo as a base for instances.
    ///
    ///Sends a 'POST' request to '/system/images'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_image_create<'a>(
        &'a self,
        body: &'a types::GlobalImageCreate,
    ) -> Result<ResponseValue<types::GlobalImage>, Error<types::SystemImageCreateError>> {
        let url = format!("{}/system/images", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_image_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageCreateError>::from_response::<
                    types::SystemImageCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageCreateError>::from_response::<
                    types::SystemImageCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a system-wide image
    ///
    ///Returns the details of a specific system-wide image.
    ///
    ///Sends a 'GET' request to '/system/images/{image_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_image_view<'a>(
        &'a self,
        image_name: &'a types::Name,
    ) -> Result<ResponseValue<types::GlobalImage>, Error<types::SystemImageViewError>> {
        let url = format!(
            "{}/system/images/{}",
            self.baseurl(),
            encode_path(&image_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_image_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageViewError>::from_response::<
                    types::SystemImageViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageViewError>::from_response::<
                    types::SystemImageViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a system-wide image
    ///
    ///Permanently delete a system-wide image. This operation cannot be undone.
    /// Any instances using the system-wide image will continue to run, however
    /// new instances can not be created with this image.
    ///
    ///Sends a 'DELETE' request to '/system/images/{image_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_image_delete<'a>(
        &'a self,
        image_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::SystemImageDeleteError>> {
        let url = format!(
            "{}/system/images/{}",
            self.baseurl(),
            encode_path(&image_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_image_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageDeleteError>::from_response::<
                    types::SystemImageDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemImageDeleteError>::from_response::<
                    types::SystemImageDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List IP pools
    ///
    ///Sends a 'GET' request to '/system/ip-pools'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::IpPoolResultsPage>, Error<types::IpPoolListError>> {
        let url = format!("{}/system/ip-pools", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolListError>::from_response::<types::IpPoolListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolListError>::from_response::<types::IpPoolListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List IP pools as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/ip-pools` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn ip_pool_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::IpPool, Error<types::IpPoolListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.ip_pool_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.ip_pool_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an IP pool
    ///
    ///Sends a 'POST' request to '/system/ip-pools'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_create<'a>(
        &'a self,
        body: &'a types::IpPoolCreate,
    ) -> Result<ResponseValue<types::IpPool>, Error<types::IpPoolCreateError>> {
        let url = format!("{}/system/ip-pools", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolCreateError>::from_response::<
                        types::IpPoolCreateError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolCreateError>::from_response::<
                        types::IpPoolCreateError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an IP pool
    ///
    ///Sends a 'GET' request to '/system/ip-pools/{pool_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_view<'a>(
        &'a self,
        pool_name: &'a types::Name,
    ) -> Result<ResponseValue<types::IpPool>, Error<types::IpPoolViewError>> {
        let url = format!(
            "{}/system/ip-pools/{}",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolViewError>::from_response::<types::IpPoolViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolViewError>::from_response::<types::IpPoolViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update an IP Pool
    ///
    ///Sends a 'PUT' request to '/system/ip-pools/{pool_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_update<'a>(
        &'a self,
        pool_name: &'a types::Name,
        body: &'a types::IpPoolUpdate,
    ) -> Result<ResponseValue<types::IpPool>, Error<types::IpPoolUpdateError>> {
        let url = format!(
            "{}/system/ip-pools/{}",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolUpdateError>::from_response::<
                        types::IpPoolUpdateError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolUpdateError>::from_response::<
                        types::IpPoolUpdateError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an IP Pool
    ///
    ///Sends a 'DELETE' request to '/system/ip-pools/{pool_name}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_delete<'a>(
        &'a self,
        pool_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::IpPoolDeleteError>> {
        let url = format!(
            "{}/system/ip-pools/{}",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolDeleteError>::from_response::<
                        types::IpPoolDeleteError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::IpPoolDeleteError>::from_response::<
                        types::IpPoolDeleteError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List ranges for an IP pool
    ///
    ///Ranges are ordered by their first address.
    ///
    ///Sends a 'GET' request to '/system/ip-pools/{pool_name}/ranges'
    ///
    ///Arguments:
    /// - `pool_name`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_range_list<'a>(
        &'a self,
        pool_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<ResponseValue<types::IpPoolRangeResultsPage>, Error<types::IpPoolRangeListError>>
    {
        let url = format!(
            "{}/system/ip-pools/{}/ranges",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_range_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeListError>::from_response::<
                    types::IpPoolRangeListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeListError>::from_response::<
                    types::IpPoolRangeListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List ranges for an IP pool as a Stream
    ///
    ///Ranges are ordered by their first address.
    ///
    ///Sends repeated `GET` requests to `/system/ip-pools/{pool_name}/ranges`
    /// until there are no more results.
    ///
    ///Arguments:
    /// - `pool_name`
    /// - `limit`: Maximum number of items returned by a single call
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn ip_pool_range_list_stream<'a>(
        &'a self,
        pool_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
    ) -> impl futures::Stream<Item = Result<types::IpPoolRange, Error<types::IpPoolRangeListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.ip_pool_range_list(pool_name, limit, None)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.ip_pool_range_list(pool_name, limit, state.as_deref())
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Add a range to an IP pool
    ///
    ///Sends a 'POST' request to '/system/ip-pools/{pool_name}/ranges/add'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_range_add<'a>(
        &'a self,
        pool_name: &'a types::Name,
        body: &'a types::IpRange,
    ) -> Result<ResponseValue<types::IpPoolRange>, Error<types::IpPoolRangeAddError>> {
        let url = format!(
            "{}/system/ip-pools/{}/ranges/add",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_range_add",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeAddError>::from_response::<
                    types::IpPoolRangeAddError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeAddError>::from_response::<
                    types::IpPoolRangeAddError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Remove a range from an IP pool
    ///
    ///Sends a 'POST' request to '/system/ip-pools/{pool_name}/ranges/remove'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_range_remove<'a>(
        &'a self,
        pool_name: &'a types::Name,
        body: &'a types::IpRange,
    ) -> Result<ResponseValue<()>, Error<types::IpPoolRangeRemoveError>> {
        let url = format!(
            "{}/system/ip-pools/{}/ranges/remove",
            self.baseurl(),
            encode_path(&pool_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_range_remove",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeRemoveError>::from_response::<
                    types::IpPoolRangeRemoveError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolRangeRemoveError>::from_response::<
                    types::IpPoolRangeRemoveError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch the IP pool used for Oxide services
    ///
    ///Sends a 'GET' request to '/system/ip-pools-service'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_service_view<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::IpPool>, Error<types::IpPoolServiceViewError>> {
        let url = format!("{}/system/ip-pools-service", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_service_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceViewError>::from_response::<
                    types::IpPoolServiceViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceViewError>::from_response::<
                    types::IpPoolServiceViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List ranges for the IP pool used for Oxide services
    ///
    ///Ranges are ordered by their first address.
    ///
    ///Sends a 'GET' request to '/system/ip-pools-service/ranges'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_service_range_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::IpPoolRangeResultsPage>,
        Error<types::IpPoolServiceRangeListError>,
    > {
        let url = format!("{}/system/ip-pools-service/ranges", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_service_range_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeListError>::from_response::<
                    types::IpPoolServiceRangeListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeListError>::from_response::<
                    types::IpPoolServiceRangeListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List ranges for the IP pool used for Oxide services as a Stream
    ///
    ///Ranges are ordered by their first address.
    ///
    ///Sends repeated `GET` requests to `/system/ip-pools-service/ranges` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn ip_pool_service_range_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
    ) -> impl futures::Stream<
        Item = Result<types::IpPoolRange, Error<types::IpPoolServiceRangeListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.ip_pool_service_range_list(limit, None)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.ip_pool_service_range_list(limit, state.as_deref())
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Add a range to an IP pool used for Oxide services
    ///
    ///Sends a 'POST' request to '/system/ip-pools-service/ranges/add'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_service_range_add<'a>(
        &'a self,
        body: &'a types::IpRange,
    ) -> Result<ResponseValue<types::IpPoolRange>, Error<types::IpPoolServiceRangeAddError>> {
        let url = format!("{}/system/ip-pools-service/ranges/add", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_service_range_add",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeAddError>::from_response::<
                    types::IpPoolServiceRangeAddError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeAddError>::from_response::<
                    types::IpPoolServiceRangeAddError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Remove a range from an IP pool used for Oxide services
    ///
    ///Sends a 'POST' request to '/system/ip-pools-service/ranges/remove'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn ip_pool_service_range_remove<'a>(
        &'a self,
        body: &'a types::IpRange,
    ) -> Result<ResponseValue<()>, Error<types::IpPoolServiceRangeRemoveError>> {
        let url = format!("{}/system/ip-pools-service/ranges/remove", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "ip_pool_service_range_remove",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeRemoveError>::from_response::<
                    types::IpPoolServiceRangeRemoveError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::IpPoolServiceRangeRemoveError>::from_response::<
                    types::IpPoolServiceRangeRemoveError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Access metrics data
    ///
    ///Sends a 'GET' request to '/system/metrics/{metric_name}'
    ///
    ///Arguments:
    /// - `metric_name`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `id`: The UUID of the container being queried
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `start_time`: An inclusive start time of metrics.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_metric<'a>(
        &'a self,
        metric_name: types::SystemMetricName,
        end_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
        id: &'a ::uuid::Uuid,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        start_time: Option<&'a ::chrono::DateTime<::chrono::offset::Utc>>,
    ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::SystemMetricError>> {
        let url = format!(
            "{}/system/metrics/{}",
            self.baseurl(),
            encode_path(&metric_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("end_time", &end_time))
            .query(&progenitor_client::QueryParam::new("id", &id))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new(
                "start_time",
                &start_time,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_metric",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SystemMetricError>::from_response::<
                        types::SystemMetricError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SystemMetricError>::from_response::<
                        types::SystemMetricError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch the top-level IAM policy
    ///
    ///Sends a 'GET' request to '/system/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_policy_view<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::SystemPolicyViewError>> {
        let url = format!("{}/system/policy", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_policy_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemPolicyViewError>::from_response::<
                    types::SystemPolicyViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemPolicyViewError>::from_response::<
                    types::SystemPolicyViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update the top-level IAM policy
    ///
    ///Sends a 'PUT' request to '/system/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_policy_update<'a>(
        &'a self,
        body: &'a types::FleetRolePolicy,
    ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::SystemPolicyUpdateError>> {
        let url = format!("{}/system/policy", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_policy_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemPolicyUpdateError>::from_response::<
                    types::SystemPolicyUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemPolicyUpdateError>::from_response::<
                    types::SystemPolicyUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List sagas
    ///
    ///Sends a 'GET' request to '/system/sagas'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn saga_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::SagaResultsPage>, Error<types::SagaListError>> {
        let url = format!("{}/system/sagas", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "saga_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SagaListError>::from_response::<types::SagaListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SagaListError>::from_response::<types::SagaListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List sagas as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/sagas` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn saga_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Saga, Error<types::SagaListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.saga_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.saga_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a saga
    ///
    ///Sends a 'GET' request to '/system/sagas/{saga_id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn saga_view<'a>(
        &'a self,
        saga_id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::Saga>, Error<types::SagaViewError>> {
        let url = format!(
            "{}/system/sagas/{}",
            self.baseurl(),
            encode_path(&saga_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "saga_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SagaViewError>::from_response::<types::SagaViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SagaViewError>::from_response::<types::SagaViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List silos
    ///
    ///Lists silos that are discoverable based on the current permissions.
    ///
    ///Sends a 'GET' request to '/system/silos'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::SiloResultsPage>, Error<types::SiloListError>> {
        let url = format!("{}/system/silos", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloListError>::from_response::<types::SiloListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloListError>::from_response::<types::SiloListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List silos as a Stream
    ///
    ///Lists silos that are discoverable based on the current permissions.
    ///
    ///Sends repeated `GET` requests to `/system/silos` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn silo_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Silo, Error<types::SiloListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.silo_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.silo_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a silo
    ///
    ///Sends a 'POST' request to '/system/silos'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_create<'a>(
        &'a self,
        body: &'a types::SiloCreate,
    ) -> Result<ResponseValue<types::Silo>, Error<types::SiloCreateError>> {
        let url = format!("{}/system/silos", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloCreateError>::from_response::<types::SiloCreateError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloCreateError>::from_response::<types::SiloCreateError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a silo
    ///
    ///Fetch a silo by name.
    ///
    ///Sends a 'GET' request to '/system/silos/{silo_name}'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_view<'a>(
        &'a self,
        silo_name: &'a types::Name,
    ) -> Result<ResponseValue<types::Silo>, Error<types::SiloViewError>> {
        let url = format!(
            "{}/system/silos/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloViewError>::from_response::<types::SiloViewError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloViewError>::from_response::<types::SiloViewError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a silo
    ///
    ///Delete a silo by name.
    ///
    ///Sends a 'DELETE' request to '/system/silos/{silo_name}'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_delete<'a>(
        &'a self,
        silo_name: &'a types::Name,
    ) -> Result<ResponseValue<()>, Error<types::SiloDeleteError>> {
        let url = format!(
            "{}/system/silos/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloDeleteError>::from_response::<types::SiloDeleteError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloDeleteError>::from_response::<types::SiloDeleteError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List a silo's IDPs
    ///
    ///Sends a 'GET' request to '/system/silos/{silo_name}/identity-providers'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_identity_provider_list<'a>(
        &'a self,
        silo_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<
        ResponseValue<types::IdentityProviderResultsPage>,
        Error<types::SiloIdentityProviderListError>,
    > {
        let url = format!(
            "{}/system/silos/{}/identity-providers",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_identity_provider_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloIdentityProviderListError>::from_response::<
                    types::SiloIdentityProviderListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloIdentityProviderListError>::from_response::<
                    types::SiloIdentityProviderListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List a silo's IDPs as a Stream
    ///
    ///Sends repeated `GET` requests to
    /// `/system/silos/{silo_name}/identity-providers` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn silo_identity_provider_list_stream<'a>(
        &'a self,
        silo_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::IdentityProvider, Error<types::SiloIdentityProviderListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.silo_identity_provider_list(silo_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.silo_identity_provider_list(silo_name, limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a user
    ///
    ///Users can only be created in Silos with `provision_type` == `Fixed`.
    /// Otherwise, Silo users are just-in-time (JIT) provisioned when a user
    /// first logs in using an external Identity Provider.
    ///
    ///Sends a 'POST' request to
    /// '/system/silos/{silo_name}/identity-providers/local/users'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn local_idp_user_create<'a>(
        &'a self,
        silo_name: &'a types::Name,
        body: &'a types::UserCreate,
    ) -> Result<ResponseValue<types::User>, Error<types::LocalIdpUserCreateError>> {
        let url = format!(
            "{}/system/silos/{}/identity-providers/local/users",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "local_idp_user_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserCreateError>::from_response::<
                    types::LocalIdpUserCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserCreateError>::from_response::<
                    types::LocalIdpUserCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a user
    ///
    ///Sends a 'DELETE' request to
    /// '/system/silos/{silo_name}/identity-providers/local/users/{user_id}'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `user_id`: The user's internal id
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn local_idp_user_delete<'a>(
        &'a self,
        silo_name: &'a types::Name,
        user_id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<()>, Error<types::LocalIdpUserDeleteError>> {
        let url = format!(
            "{}/system/silos/{}/identity-providers/local/users/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "local_idp_user_delete",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserDeleteError>::from_response::<
                    types::LocalIdpUserDeleteError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserDeleteError>::from_response::<
                    types::LocalIdpUserDeleteError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Set or invalidate a user's password
    ///
    ///Passwords can only be updated for users in Silos with identity mode
    /// `LocalOnly`.
    ///
    ///Sends a 'POST' request to
    /// '/system/silos/{silo_name}/identity-providers/local/users/{user_id}/
    /// set-password'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `user_id`: The user's internal id
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn local_idp_user_set_password<'a>(
        &'a self,
        silo_name: &'a types::Name,
        user_id: &'a ::uuid::Uuid,
        body: &'a types::UserPassword,
    ) -> Result<ResponseValue<()>, Error<types::LocalIdpUserSetPasswordError>> {
        let url = format!(
            "{}/system/silos/{}/identity-providers/local/users/{}/set-password",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "local_idp_user_set_password",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserSetPasswordError>::from_response::<
                    types::LocalIdpUserSetPasswordError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::LocalIdpUserSetPasswordError>::from_response::<
                    types::LocalIdpUserSetPasswordError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Create a SAML IDP
    ///
    ///Sends a 'POST' request to
    /// '/system/silos/{silo_name}/identity-providers/saml'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn saml_identity_provider_create<'a>(
        &'a self,
        silo_name: &'a types::Name,
        body: &'a types::SamlIdentityProviderCreate,
    ) -> Result<
        ResponseValue<types::SamlIdentityProvider>,
        Error<types::SamlIdentityProviderCreateError>,
    > {
        let url = format!(
            "{}/system/silos/{}/identity-providers/saml",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "saml_identity_provider_create",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SamlIdentityProviderCreateError>::from_response::<
                    types::SamlIdentityProviderCreateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SamlIdentityProviderCreateError>::from_response::<
                    types::SamlIdentityProviderCreateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a SAML IDP
    ///
    ///Sends a 'GET' request to
    /// '/system/silos/{silo_name}/identity-providers/saml/{provider_name}'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `provider_name`: The SAML identity provider's name
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn saml_identity_provider_view<'a>(
        &'a self,
        silo_name: &'a types::Name,
        provider_name: &'a types::Name,
    ) -> Result<
        ResponseValue<types::SamlIdentityProvider>,
        Error<types::SamlIdentityProviderViewError>,
    > {
        let url = format!(
            "{}/system/silos/{}/identity-providers/saml/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&provider_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "saml_identity_provider_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SamlIdentityProviderViewError>::from_response::<
                    types::SamlIdentityProviderViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SamlIdentityProviderViewError>::from_response::<
                    types::SamlIdentityProviderViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a silo's IAM policy
    ///
    ///Sends a 'GET' request to '/system/silos/{silo_name}/policy'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_policy_view<'a>(
        &'a self,
        silo_name: &'a types::Name,
    ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::SiloPolicyViewError>> {
        let url = format!(
            "{}/system/silos/{}/policy",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_policy_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloPolicyViewError>::from_response::<
                    types::SiloPolicyViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloPolicyViewError>::from_response::<
                    types::SiloPolicyViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a silo's IAM policy
    ///
    ///Sends a 'PUT' request to '/system/silos/{silo_name}/policy'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `body`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_policy_update<'a>(
        &'a self,
        silo_name: &'a types::Name,
        body: &'a types::SiloRolePolicy,
    ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::SiloPolicyUpdateError>> {
        let url = format!(
            "{}/system/silos/{}/policy",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_policy_update",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloPolicyUpdateError>::from_response::<
                    types::SiloPolicyUpdateError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloPolicyUpdateError>::from_response::<
                    types::SiloPolicyUpdateError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List users in a silo
    ///
    ///Sends a 'GET' request to '/system/silos/{silo_name}/users/all'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_users_list<'a>(
        &'a self,
        silo_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::SiloUsersListError>> {
        let url = format!(
            "{}/system/silos/{}/users/all",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_users_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloUsersListError>::from_response::<
                    types::SiloUsersListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SiloUsersListError>::from_response::<
                    types::SiloUsersListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List users in a silo as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/silos/{silo_name}/users/all`
    /// until there are no more results.
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn silo_users_list_stream<'a>(
        &'a self,
        silo_name: &'a types::Name,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::User, Error<types::SiloUsersListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.silo_users_list(silo_name, limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.silo_users_list(silo_name, limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a user
    ///
    ///Sends a 'GET' request to '/system/silos/{silo_name}/users/id/{user_id}'
    ///
    ///Arguments:
    /// - `silo_name`: The silo's unique name.
    /// - `user_id`: The user's internal id
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn silo_user_view<'a>(
        &'a self,
        silo_name: &'a types::Name,
        user_id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::User>, Error<types::SiloUserViewError>> {
        let url = format!(
            "{}/system/silos/{}/users/id/{}",
            self.baseurl(),
            encode_path(&silo_name.to_string()),
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "silo_user_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SiloUserViewError>::from_response::<
                        types::SiloUserViewError,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::SiloUserViewError>::from_response::<
                        types::SiloUserViewError,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List built-in users
    ///
    ///Sends a 'GET' request to '/system/user'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_user_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameSortMode>,
    ) -> Result<ResponseValue<types::UserBuiltinResultsPage>, Error<types::SystemUserListError>>
    {
        let url = format!("{}/system/user", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_user_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUserListError>::from_response::<
                    types::SystemUserListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUserListError>::from_response::<
                    types::SystemUserListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List built-in users as a Stream
    ///
    ///Sends repeated `GET` requests to `/system/user` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn system_user_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameSortMode>,
    ) -> impl futures::Stream<Item = Result<types::UserBuiltin, Error<types::SystemUserListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.system_user_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.system_user_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a built-in user
    ///
    ///Sends a 'GET' request to '/system/user/{user_name}'
    ///
    ///Arguments:
    /// - `user_name`: The built-in user's unique name.
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_user_view<'a>(
        &'a self,
        user_name: &'a types::Name,
    ) -> Result<ResponseValue<types::UserBuiltin>, Error<types::SystemUserViewError>> {
        let url = format!(
            "{}/system/user/{}",
            self.baseurl(),
            encode_path(&user_name.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_user_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUserViewError>::from_response::<
                    types::SystemUserViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUserViewError>::from_response::<
                    types::SystemUserViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List timeseries schema
    ///
    ///Sends a 'GET' request to '/timeseries/schema'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn timeseries_schema_get<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
    ) -> Result<
        ResponseValue<types::TimeseriesSchemaResultsPage>,
        Error<types::TimeseriesSchemaGetError>,
    > {
        let url = format!("{}/timeseries/schema", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "timeseries_schema_get",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::TimeseriesSchemaGetError>::from_response::<
                    types::TimeseriesSchemaGetError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::TimeseriesSchemaGetError>::from_response::<
                    types::TimeseriesSchemaGetError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List timeseries schema as a Stream
    ///
    ///Sends repeated `GET` requests to `/timeseries/schema` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn timeseries_schema_get_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
    ) -> impl futures::Stream<
        Item = Result<types::TimeseriesSchema, Error<types::TimeseriesSchemaGetError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.timeseries_schema_get(limit, None)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.timeseries_schema_get(limit, state.as_deref())
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List users
    ///
    ///Sends a 'GET' request to '/users'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn user_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::UserListError>> {
        let url = format!("{}/users", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "user_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UserListError>::from_response::<types::UserListError>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UserListError>::from_response::<types::UserListError>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List users as a Stream
    ///
    ///Sends repeated `GET` requests to `/users` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn user_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::User, Error<types::UserListError>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.user_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.user_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List disks
    ///
    ///Sends a 'GET' request to '/v1/disks'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_list_v1<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        page_token: Option<&'a str>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::DiskListV1Error>> {
        let url = format!("{}/v1/disks", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_list_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskListV1Error>::from_response::<types::DiskListV1Error>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskListV1Error>::from_response::<types::DiskListV1Error>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List disks as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/disks` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn disk_list_v1_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::DiskListV1Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.disk_list_v1(limit, organization, None, project, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.disk_list_v1(limit, None, state.as_deref(), None, None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a disk
    ///
    ///Sends a 'POST' request to '/v1/disks'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_create_v1<'a>(
        &'a self,
        organization: Option<&'a types::NameOrId>,
        project: &'a types::NameOrId,
        body: &'a types::DiskCreate,
    ) -> Result<ResponseValue<types::Disk>, Error<types::DiskCreateV1Error>> {
        let url = format!("{}/v1/disks", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_create_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskCreateV1Error>::from_response::<
                        types::DiskCreateV1Error,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskCreateV1Error>::from_response::<
                        types::DiskCreateV1Error,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a disk
    ///
    ///Sends a 'GET' request to '/v1/disks/{disk}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_view_v1<'a>(
        &'a self,
        disk: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Disk>, Error<types::DiskViewV1Error>> {
        let url = format!(
            "{}/v1/disks/{}",
            self.baseurl(),
            encode_path(&disk.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskViewV1Error>::from_response::<types::DiskViewV1Error>(
                    response,
                )
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::DiskViewV1Error>::from_response::<types::DiskViewV1Error>(
                    response,
                )
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a disk
    ///
    ///Sends a 'DELETE' request to '/v1/disks/{disk}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn disk_delete_v1<'a>(
        &'a self,
        disk: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<()>, Error<types::DiskDeleteV1Error>> {
        let url = format!(
            "{}/v1/disks/{}",
            self.baseurl(),
            encode_path(&disk.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "disk_delete_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskDeleteV1Error>::from_response::<
                        types::DiskDeleteV1Error,
                    >(response)
                    .await?,
                ))
            }
            500u16..=599u16 => {
                Err(Error::ErrorResponse(
                    ResponseValue::<types::DiskDeleteV1Error>::from_response::<
                        types::DiskDeleteV1Error,
                    >(response)
                    .await?,
                ))
            }
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List instances
    ///
    ///Sends a 'GET' request to '/v1/instances'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_list_v1<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        page_token: Option<&'a str>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::InstanceListV1Error>> {
        let url = format!("{}/v1/instances", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_list_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceListV1Error>::from_response::<
                    types::InstanceListV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceListV1Error>::from_response::<
                    types::InstanceListV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List instances as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/instances` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn instance_list_v1_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::InstanceListV1Error>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_list_v1(limit, organization, None, project, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.instance_list_v1(limit, None, state.as_deref(), None, None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an instance
    ///
    ///Sends a 'POST' request to '/v1/instances'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_create_v1<'a>(
        &'a self,
        organization: Option<&'a types::NameOrId>,
        project: &'a types::NameOrId,
        body: &'a types::InstanceCreate,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceCreateV1Error>> {
        let url = format!("{}/v1/instances", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_create_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceCreateV1Error>::from_response::<
                    types::InstanceCreateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceCreateV1Error>::from_response::<
                    types::InstanceCreateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an instance
    ///
    ///Sends a 'GET' request to '/v1/instances/{instance}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_view_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceViewV1Error>> {
        let url = format!(
            "{}/v1/instances/{}",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceViewV1Error>::from_response::<
                    types::InstanceViewV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceViewV1Error>::from_response::<
                    types::InstanceViewV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an instance
    ///
    ///Sends a 'DELETE' request to '/v1/instances/{instance}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_delete_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<()>, Error<types::InstanceDeleteV1Error>> {
        let url = format!(
            "{}/v1/instances/{}",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_delete_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDeleteV1Error>::from_response::<
                    types::InstanceDeleteV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDeleteV1Error>::from_response::<
                    types::InstanceDeleteV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List an instance's disks
    ///
    ///Sends a 'GET' request to '/v1/instances/{instance}/disks'
    ///
    ///Arguments:
    /// - `instance`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_list_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        page_token: Option<&'a str>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::InstanceDiskListV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/disks",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_list_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskListV1Error>::from_response::<
                    types::InstanceDiskListV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskListV1Error>::from_response::<
                    types::InstanceDiskListV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List an instance's disks as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/instances/{instance}/disks` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `instance`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `project`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn instance_disk_list_v1_stream<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::InstanceDiskListV1Error>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.instance_disk_list_v1(instance, limit, organization, None, project, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.instance_disk_list_v1(
                            instance,
                            limit,
                            None,
                            state.as_deref(),
                            None,
                            None,
                        )
                        .map_ok(|page| {
                            let page = page.into_inner();
                            Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                        })
                        .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Attach a disk to an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/disks/attach'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_attach_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        body: &'a types::DiskPath,
    ) -> Result<ResponseValue<types::Disk>, Error<types::InstanceDiskAttachV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/disks/attach",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_attach_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskAttachV1Error>::from_response::<
                    types::InstanceDiskAttachV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskAttachV1Error>::from_response::<
                    types::InstanceDiskAttachV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Detach a disk from an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/disks/detach'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_disk_detach_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        body: &'a types::DiskPath,
    ) -> Result<ResponseValue<types::Disk>, Error<types::InstanceDiskDetachV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/disks/detach",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_disk_detach_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskDetachV1Error>::from_response::<
                    types::InstanceDiskDetachV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceDiskDetachV1Error>::from_response::<
                    types::InstanceDiskDetachV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Migrate an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/migrate'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_migrate_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
        body: &'a types::InstanceMigrate,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceMigrateV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/migrate",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_migrate_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceMigrateV1Error>::from_response::<
                    types::InstanceMigrateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceMigrateV1Error>::from_response::<
                    types::InstanceMigrateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Reboot an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/reboot'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_reboot_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceRebootV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/reboot",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_reboot_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceRebootV1Error>::from_response::<
                    types::InstanceRebootV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceRebootV1Error>::from_response::<
                    types::InstanceRebootV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an instance's serial console
    ///
    ///Sends a 'GET' request to '/v1/instances/{instance}/serial-console'
    ///
    ///Arguments:
    /// - `instance`
    /// - `from_start`: Character index in the serial buffer from which to read,
    ///   counting the bytes output since instance start. If this is not
    ///   provided, `most_recent` must be provided, and if this *is* provided,
    ///   `most_recent` must *not* be provided.
    /// - `max_bytes`: Maximum number of bytes of buffered serial console
    ///   contents to return. If the requested range runs to the end of the
    ///   available buffer, the data returned will be shorter than `max_bytes`.
    /// - `most_recent`: Character index in the serial buffer from which to
    ///   read, counting *backward* from the most recently buffered data
    ///   retrieved from the instance. (See note on `from_start` about mutual
    ///   exclusivity)
    /// - `organization`
    /// - `project`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_serial_console_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        from_start: Option<u64>,
        max_bytes: Option<u64>,
        most_recent: Option<u64>,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<
        ResponseValue<types::InstanceSerialConsoleData>,
        Error<types::InstanceSerialConsoleV1Error>,
    > {
        let url = format!(
            "{}/v1/instances/{}/serial-console",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "from_start",
                &from_start,
            ))
            .query(&progenitor_client::QueryParam::new("max_bytes", &max_bytes))
            .query(&progenitor_client::QueryParam::new(
                "most_recent",
                &most_recent,
            ))
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_serial_console_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceSerialConsoleV1Error>::from_response::<
                    types::InstanceSerialConsoleV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceSerialConsoleV1Error>::from_response::<
                    types::InstanceSerialConsoleV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Stream an instance's serial console
    ///
    ///Sends a 'GET' request to
    /// '/v1/instances/{instance}/serial-console/stream'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_serial_console_stream_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<reqwest::Upgraded>, Error<()>> {
        let url = format!(
            "{}/v1/instances/{}/serial-console/stream",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .header(::reqwest::header::CONNECTION, "Upgrade")
            .header(::reqwest::header::UPGRADE, "websocket")
            .header(::reqwest::header::SEC_WEBSOCKET_VERSION, "13")
            .header(
                ::reqwest::header::SEC_WEBSOCKET_KEY,
                ::base64::Engine::encode(
                    &::base64::engine::general_purpose::STANDARD,
                    ::rand::random::<[u8; 16]>(),
                ),
            )
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_serial_console_stream_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            101u16 => ResponseValue::upgrade(response).await,
            200..=299 => ResponseValue::upgrade(response).await,
            _ => Err(Error::ErrorResponse(ResponseValue::empty(response))),
        }
    }

    ///Boot an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/start'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_start_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceStartV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/start",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_start_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStartV1Error>::from_response::<
                    types::InstanceStartV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStartV1Error>::from_response::<
                    types::InstanceStartV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Stop an instance
    ///
    ///Sends a 'POST' request to '/v1/instances/{instance}/stop'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn instance_stop_v1<'a>(
        &'a self,
        instance: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        project: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Instance>, Error<types::InstanceStopV1Error>> {
        let url = format!(
            "{}/v1/instances/{}/stop",
            self.baseurl(),
            encode_path(&instance.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new("project", &project))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "instance_stop_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStopV1Error>::from_response::<
                    types::InstanceStopV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::InstanceStopV1Error>::from_response::<
                    types::InstanceStopV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List organizations
    ///
    ///Sends a 'GET' request to '/v1/organizations'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_list_v1<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::OrganizationResultsPage>, Error<types::OrganizationListV1Error>>
    {
        let url = format!("{}/v1/organizations", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_list_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationListV1Error>::from_response::<
                    types::OrganizationListV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationListV1Error>::from_response::<
                    types::OrganizationListV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List organizations as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/organizations` until there are no
    /// more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn organization_list_v1_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::Organization, Error<types::OrganizationListV1Error>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.organization_list_v1(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.organization_list_v1(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create an organization
    ///
    ///Sends a 'POST' request to '/v1/organizations'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_create_v1<'a>(
        &'a self,
        body: &'a types::OrganizationCreate,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationCreateV1Error>> {
        let url = format!("{}/v1/organizations", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_create_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationCreateV1Error>::from_response::<
                    types::OrganizationCreateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationCreateV1Error>::from_response::<
                    types::OrganizationCreateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an organization
    ///
    ///Sends a 'GET' request to '/v1/organizations/{organization}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_view_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationViewV1Error>> {
        let url = format!(
            "{}/v1/organizations/{}",
            self.baseurl(),
            encode_path(&organization.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewV1Error>::from_response::<
                    types::OrganizationViewV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationViewV1Error>::from_response::<
                    types::OrganizationViewV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update an organization
    ///
    ///Sends a 'PUT' request to '/v1/organizations/{organization}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_update_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
        body: &'a types::OrganizationUpdate,
    ) -> Result<ResponseValue<types::Organization>, Error<types::OrganizationUpdateV1Error>> {
        let url = format!(
            "{}/v1/organizations/{}",
            self.baseurl(),
            encode_path(&organization.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_update_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationUpdateV1Error>::from_response::<
                    types::OrganizationUpdateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationUpdateV1Error>::from_response::<
                    types::OrganizationUpdateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete an organization
    ///
    ///Sends a 'DELETE' request to '/v1/organizations/{organization}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_delete_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
    ) -> Result<ResponseValue<()>, Error<types::OrganizationDeleteV1Error>> {
        let url = format!(
            "{}/v1/organizations/{}",
            self.baseurl(),
            encode_path(&organization.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_delete_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationDeleteV1Error>::from_response::<
                    types::OrganizationDeleteV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationDeleteV1Error>::from_response::<
                    types::OrganizationDeleteV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch an organization's IAM policy
    ///
    ///Sends a 'GET' request to '/v1/organizations/{organization}/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_policy_view_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
    ) -> Result<
        ResponseValue<types::OrganizationRolePolicy>,
        Error<types::OrganizationPolicyViewV1Error>,
    > {
        let url = format!(
            "{}/v1/organizations/{}/policy",
            self.baseurl(),
            encode_path(&organization.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_policy_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyViewV1Error>::from_response::<
                    types::OrganizationPolicyViewV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyViewV1Error>::from_response::<
                    types::OrganizationPolicyViewV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update an organization's IAM policy
    ///
    ///Sends a 'PUT' request to '/v1/organizations/{organization}/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn organization_policy_update_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
        body: &'a types::OrganizationRolePolicy,
    ) -> Result<
        ResponseValue<types::OrganizationRolePolicy>,
        Error<types::OrganizationPolicyUpdateV1Error>,
    > {
        let url = format!(
            "{}/v1/organizations/{}/policy",
            self.baseurl(),
            encode_path(&organization.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "organization_policy_update_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyUpdateV1Error>::from_response::<
                    types::OrganizationPolicyUpdateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::OrganizationPolicyUpdateV1Error>::from_response::<
                    types::OrganizationPolicyUpdateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List projects
    ///
    ///Sends a 'GET' request to '/v1/projects'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_list_v1<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        page_token: Option<&'a str>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::ProjectListV1Error>> {
        let url = format!("{}/v1/projects", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_list_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectListV1Error>::from_response::<
                    types::ProjectListV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectListV1Error>::from_response::<
                    types::ProjectListV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List projects as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/projects` until there are no more
    /// results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `organization`
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn project_list_v1_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        organization: Option<&'a types::NameOrId>,
        sort_by: Option<types::NameOrIdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::Project, Error<types::ProjectListV1Error>>> + Unpin + '_
    {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.project_list_v1(limit, organization, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.project_list_v1(limit, None, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Create a project
    ///
    ///Sends a 'POST' request to '/v1/projects'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_create_v1<'a>(
        &'a self,
        organization: &'a types::NameOrId,
        body: &'a types::ProjectCreate,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectCreateV1Error>> {
        let url = format!("{}/v1/projects", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_create_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            201u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectCreateV1Error>::from_response::<
                    types::ProjectCreateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectCreateV1Error>::from_response::<
                    types::ProjectCreateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a project
    ///
    ///Sends a 'GET' request to '/v1/projects/{project}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_view_v1<'a>(
        &'a self,
        project: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectViewV1Error>> {
        let url = format!(
            "{}/v1/projects/{}",
            self.baseurl(),
            encode_path(&project.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewV1Error>::from_response::<
                    types::ProjectViewV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectViewV1Error>::from_response::<
                    types::ProjectViewV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a project
    ///
    ///Sends a 'PUT' request to '/v1/projects/{project}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_update_v1<'a>(
        &'a self,
        project: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        body: &'a types::ProjectUpdate,
    ) -> Result<ResponseValue<types::Project>, Error<types::ProjectUpdateV1Error>> {
        let url = format!(
            "{}/v1/projects/{}",
            self.baseurl(),
            encode_path(&project.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_update_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectUpdateV1Error>::from_response::<
                    types::ProjectUpdateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectUpdateV1Error>::from_response::<
                    types::ProjectUpdateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Delete a project
    ///
    ///Sends a 'DELETE' request to '/v1/projects/{project}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_delete_v1<'a>(
        &'a self,
        project: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<()>, Error<types::ProjectDeleteV1Error>> {
        let url = format!(
            "{}/v1/projects/{}",
            self.baseurl(),
            encode_path(&project.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_delete_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectDeleteV1Error>::from_response::<
                    types::ProjectDeleteV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectDeleteV1Error>::from_response::<
                    types::ProjectDeleteV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Fetch a project's IAM policy
    ///
    ///Sends a 'GET' request to '/v1/projects/{project}/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_policy_view_v1<'a>(
        &'a self,
        project: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
    ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::ProjectPolicyViewV1Error>>
    {
        let url = format!(
            "{}/v1/projects/{}/policy",
            self.baseurl(),
            encode_path(&project.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_policy_view_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyViewV1Error>::from_response::<
                    types::ProjectPolicyViewV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyViewV1Error>::from_response::<
                    types::ProjectPolicyViewV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Update a project's IAM policy
    ///
    ///Sends a 'PUT' request to '/v1/projects/{project}/policy'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn project_policy_update_v1<'a>(
        &'a self,
        project: &'a types::NameOrId,
        organization: Option<&'a types::NameOrId>,
        body: &'a types::ProjectRolePolicy,
    ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::ProjectPolicyUpdateV1Error>>
    {
        let url = format!(
            "{}/v1/projects/{}/policy",
            self.baseurl(),
            encode_path(&project.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .put(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .query(&progenitor_client::QueryParam::new(
                "organization",
                &organization,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "project_policy_update_v1",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyUpdateV1Error>::from_response::<
                    types::ProjectPolicyUpdateV1Error,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::ProjectPolicyUpdateV1Error>::from_response::<
                    types::ProjectPolicyUpdateV1Error,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///View version and update status of component tree
    ///
    ///Sends a 'GET' request to '/v1/system/update/components'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_component_version_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<
        ResponseValue<types::UpdateableComponentResultsPage>,
        Error<types::SystemComponentVersionListError>,
    > {
        let url = format!("{}/v1/system/update/components", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_component_version_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemComponentVersionListError>::from_response::<
                    types::SystemComponentVersionListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemComponentVersionListError>::from_response::<
                    types::SystemComponentVersionListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///View version and update status of component tree as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/system/update/components` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn system_component_version_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::UpdateableComponent, Error<types::SystemComponentVersionListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.system_component_version_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.system_component_version_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///List all update deployments
    ///
    ///Sends a 'GET' request to '/v1/system/update/deployments'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn update_deployments_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<
        ResponseValue<types::UpdateDeploymentResultsPage>,
        Error<types::UpdateDeploymentsListError>,
    > {
        let url = format!("{}/v1/system/update/deployments", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_deployments_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UpdateDeploymentsListError>::from_response::<
                    types::UpdateDeploymentsListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UpdateDeploymentsListError>::from_response::<
                    types::UpdateDeploymentsListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List all update deployments as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/system/update/deployments` until
    /// there are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn update_deployments_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<
        Item = Result<types::UpdateDeployment, Error<types::UpdateDeploymentsListError>>,
    > + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.update_deployments_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.update_deployments_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///Fetch a system update deployment
    ///
    ///Sends a 'GET' request to '/v1/system/update/deployments/{id}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn update_deployment_view<'a>(
        &'a self,
        id: &'a ::uuid::Uuid,
    ) -> Result<ResponseValue<types::UpdateDeployment>, Error<types::UpdateDeploymentViewError>>
    {
        let url = format!(
            "{}/v1/system/update/deployments/{}",
            self.baseurl(),
            encode_path(&id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_deployment_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UpdateDeploymentViewError>::from_response::<
                    types::UpdateDeploymentViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::UpdateDeploymentViewError>::from_response::<
                    types::UpdateDeploymentViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Refresh update data
    ///
    ///Sends a 'POST' request to '/v1/system/update/refresh'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_refresh<'a>(
        &'a self,
    ) -> Result<ResponseValue<()>, Error<types::SystemUpdateRefreshError>> {
        let url = format!("{}/v1/system/update/refresh", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_refresh",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateRefreshError>::from_response::<
                    types::SystemUpdateRefreshError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateRefreshError>::from_response::<
                    types::SystemUpdateRefreshError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Start system update
    ///
    ///Sends a 'POST' request to '/v1/system/update/start'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_start<'a>(
        &'a self,
        body: &'a types::SystemUpdateStart,
    ) -> Result<ResponseValue<types::UpdateDeployment>, Error<types::SystemUpdateStartError>> {
        let url = format!("{}/v1/system/update/start", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .header(
                ::reqwest::header::CONTENT_TYPE,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .body(serde_json::to_string(&body).map_err(|e| Error::InvalidRequest(e.to_string()))?)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_start",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            202u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateStartError>::from_response::<
                    types::SystemUpdateStartError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateStartError>::from_response::<
                    types::SystemUpdateStartError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///Stop system update
    ///
    ///If there is no update in progress, do nothing.
    ///
    ///Sends a 'POST' request to '/v1/system/update/stop'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_stop<'a>(
        &'a self,
    ) -> Result<ResponseValue<()>, Error<types::SystemUpdateStopError>> {
        let url = format!("{}/v1/system/update/stop", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_stop",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateStopError>::from_response::<
                    types::SystemUpdateStopError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateStopError>::from_response::<
                    types::SystemUpdateStopError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List all updates
    ///
    ///Sends a 'GET' request to '/v1/system/update/updates'
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_list<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        page_token: Option<&'a str>,
        sort_by: Option<types::IdSortMode>,
    ) -> Result<ResponseValue<types::SystemUpdateResultsPage>, Error<types::SystemUpdateListError>>
    {
        let url = format!("{}/v1/system/update/updates", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new(
                "page_token",
                &page_token,
            ))
            .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateListError>::from_response::<
                    types::SystemUpdateListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateListError>::from_response::<
                    types::SystemUpdateListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///List all updates as a Stream
    ///
    ///Sends repeated `GET` requests to `/v1/system/update/updates` until there
    /// are no more results.
    ///
    ///Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `sort_by`
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub fn system_update_list_stream<'a>(
        &'a self,
        limit: Option<::std::num::NonZeroU32>,
        sort_by: Option<types::IdSortMode>,
    ) -> impl futures::Stream<Item = Result<types::SystemUpdate, Error<types::SystemUpdateListError>>>
           + Unpin
           + '_ {
        use futures::StreamExt;
        use futures::TryFutureExt;
        use futures::TryStreamExt;
        self.system_update_list(limit, None, sort_by)
            .map_ok(move |page| {
                let page = page.into_inner();
                let first = futures::stream::iter(page.items).map(Ok);
                let rest = futures::stream::try_unfold(page.next_page, move |state| async move {
                    if state.is_none() {
                        Ok(None)
                    } else {
                        self.system_update_list(limit, state.as_deref(), None)
                            .map_ok(|page| {
                                let page = page.into_inner();
                                Some((futures::stream::iter(page.items).map(Ok), page.next_page))
                            })
                            .await
                    }
                })
                .try_flatten();
                first.chain(rest)
            })
            .try_flatten_stream()
            .boxed()
    }

    ///View system update
    ///
    ///Sends a 'GET' request to '/v1/system/update/updates/{version}'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_view<'a>(
        &'a self,
        version: &'a types::SemverVersion,
    ) -> Result<ResponseValue<types::SystemUpdate>, Error<types::SystemUpdateViewError>> {
        let url = format!(
            "{}/v1/system/update/updates/{}",
            self.baseurl(),
            encode_path(&version.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_view",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateViewError>::from_response::<
                    types::SystemUpdateViewError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateViewError>::from_response::<
                    types::SystemUpdateViewError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///View system update component tree
    ///
    ///Sends a 'GET' request to
    /// '/v1/system/update/updates/{version}/components'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_update_components_list<'a>(
        &'a self,
        version: &'a types::SemverVersion,
    ) -> Result<
        ResponseValue<types::ComponentUpdateResultsPage>,
        Error<types::SystemUpdateComponentsListError>,
    > {
        let url = format!(
            "{}/v1/system/update/updates/{}/components",
            self.baseurl(),
            encode_path(&version.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_update_components_list",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateComponentsListError>::from_response::<
                    types::SystemUpdateComponentsListError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemUpdateComponentsListError>::from_response::<
                    types::SystemUpdateComponentsListError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }

    ///View system version and update status
    ///
    ///Sends a 'GET' request to '/v1/system/update/version'
    #[allow(unused_variables)]
    #[allow(irrefutable_let_patterns)]
    pub async fn system_version<'a>(
        &'a self,
    ) -> Result<ResponseValue<types::SystemVersion>, Error<types::SystemVersionError>> {
        let url = format!("{}/v1/system/update/version", self.baseurl(),);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        #[allow(unused_variables)]
        let mut request = self
            .client()
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "system_version",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            400u16..=499u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemVersionError>::from_response::<
                    types::SystemVersionError,
                >(response)
                .await?,
            )),
            500u16..=599u16 => Err(Error::ErrorResponse(
                ResponseValue::<types::SystemVersionError>::from_response::<
                    types::SystemVersionError,
                >(response)
                .await?,
            )),
            _ => Err(Error::UnexpectedResponse(Box::new(response))),
        }
    }
}

/// Items consumers will typically use such as the Client.
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
    #[cfg(feature = "middleware")]
    #[allow(unused_imports)]
    pub use super::MiddlewareClient;
}
